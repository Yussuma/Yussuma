// ==UserScript==
// @name         betteR20-core fix Yussuma
// @namespace    https://5e.tools/
// @license      MIT (https://opensource.org/licenses/MIT)
// @version      1.28.1
// @updateURL    https://github.com/TheGiddyLimit/betterR20/raw/development/dist/betteR20-core.user.js
// @downloadURL  https://github.com/TheGiddyLimit/betterR20/raw/development/dist/betteR20-core.user.js
// @description  Enhance your Roll20 experience
// @author       TheGiddyLimit

// @match        https://app.roll20.net/editor
// @match        https://app.roll20.net/editor#*
// @match        https://app.roll20.net/editor?*
// @match        https://app.roll20.net/editor/
// @match        https://app.roll20.net/editor/#*
// @match        https://app.roll20.net/editor/?*

// @grant        unsafeWindow
// @run-at       document-start

// @grant        GM_webRequest
// @webRequest   [{"selector": { "include": "*://www.google-analytics.com/analytics.js" },  "action": "cancel"}]
// @webRequest   [{"selector": { "include": "*://cdn.userleap.com/shim.js?*" },  "action": "cancel"}]

// ==/UserScript==


ART_HANDOUT = "betteR20-art";
CONFIG_HANDOUT = "betteR20-config";

// TODO automate to use mirror if main site is unavailable
// BASE_SITE_URL = "https://5e.tools/";
BASE_SITE_URL = "https://5etools-mirror-1.github.io/";

SITE_JS_URL = `${BASE_SITE_URL}js/`;
DATA_URL = `${BASE_SITE_URL}data/`;
DATA_URL_MODULES = `https://raw.githubusercontent.com/5etools-mirror-1/roll20-module/master`;

SCRIPT_EXTENSIONS = [];

EXT_LIB_SCRIPTS = [];
EXT_LIB_API_SCRIPTS = [];

JSON_DATA = {};

CONFIG_OPTIONS = {
	interface: {
		_name: "Interface",
		showCustomArtPreview: {
			name: "Show Custom Art Previews",
			default: true,
			_type: "boolean",
		},
	},
};

addConfigOptions = function (category, options) {
	if (!CONFIG_OPTIONS[category]) CONFIG_OPTIONS[category] = options;
	else CONFIG_OPTIONS[category] = Object.assign(CONFIG_OPTIONS[category], options);
};

OBJECT_DEFINE_PROPERTY = Object.defineProperty;
ACCOUNT_ORIGINAL_PERMS = {
	largefeats: false,
	xlfeats: false,
};
Object.defineProperty = function (obj, prop, vals) {
	try {
		if (prop === "largefeats" || prop === "xlfeats") {
			ACCOUNT_ORIGINAL_PERMS[prop] = vals.value;
			vals.value = true;
		}
		OBJECT_DEFINE_PROPERTY(obj, prop, vals);
	} catch (e) {
		// eslint-disable-next-line no-console
		console.log("failed to define property:", e, obj, prop, vals);
	}
};

FINAL_CANVAS_MOUSEDOWN_LIST = [];
FINAL_CANVAS_MOUSEMOVE_LIST = [];
FINAL_CANVAS_MOUSEDOWN = null;
FINAL_CANVAS_MOUSEMOVE = null;
EventTarget.prototype.addEventListenerBase = EventTarget.prototype.addEventListener;
EventTarget.prototype.addEventListener = function (type, listener, options, ...others) {
	if (typeof d20 !== "undefined") {
		if (type === "mousedown" && this === d20.engine.final_canvas) FINAL_CANVAS_MOUSEDOWN = listener;
		if (type === "mousemove" && this === d20.engine.final_canvas) FINAL_CANVAS_MOUSEMOVE = listener;
	} else {
		if (type === "mousedown") FINAL_CANVAS_MOUSEDOWN_LIST.push({listener, on: this});
		if (type === "mousemove") FINAL_CANVAS_MOUSEMOVE_LIST.push({listener, on: this});
	}
	this.addEventListenerBase(type, listener, options, ...others);
};


function baseUtil () {
	d20plus.ut = {};

	d20plus.ut.log = (...args) => {
		// eslint-disable-next-line no-console
		console.log("%cD20Plus > ", "color: #3076b9; font-size: large", ...args);
	};

	d20plus.ut.error = (...args) => {
		// eslint-disable-next-line no-console
		console.error("%cD20Plus > ", "color: #b93032; font-size: large", ...args);
	};

	d20plus.ut.chatLog = (arg) => {
		d20.textchat.incoming(
			false,
			{
				who: "betteR20",
				type: "general",
				content: (arg || "").toString(),
				playerid: window.currentPlayer.id,
				id: d20plus.ut.generateRowId(),
				target: window.currentPlayer.id,
				avatar: "https://i.imgur.com/bBhudno.png",
			},
		);
	};

	d20plus.ut.ascSort = (a, b) => {
		if (b === a) return 0;
		return b < a ? 1 : -1;
	};

	d20plus.ut.fix3dDice = () => {
        Object.defineProperty(Array.prototype, 'filter', {
            enumerable: false,
            value: Array.prototype.filter
        });

        Object.defineProperty(Array.prototype, 'map', {
            enumerable: false,
            value: Array.prototype.map
        });
    };
	
	d20plus.ut.checkVersion = () => {
		d20plus.ut.log("Checking current version");

		function cmpVersions (a, b) {
			const regExStrip0 = /(\.0+)+$/;
			const segmentsA = a.replace(regExStrip0, "").split(".");
			const segmentsB = b.replace(regExStrip0, "").split(".");
			const l = Math.min(segmentsA.length, segmentsB.length);

			for (let i = 0; i < l; i++) {
				const diff = parseInt(segmentsA[i], 10) - parseInt(segmentsB[i], 10);
				if (diff) {
					return diff;
				}
			}
			return segmentsA.length - segmentsB.length;
		}

		$.ajax({
			url: `https://raw.githubusercontent.com/TheGiddyLimit/betterR20/development/dist/betteR20-version`,
			success: (data) => {
				if (data) {
					const curr = d20plus.version;
					const avail = data;
					const cmp = cmpVersions(curr, avail);
					if (cmp < 0) {
						setTimeout(() => {
							const rawToolsInstallUrl = "https://github.com/TheGiddyLimit/betterR20/blob/development/dist/betteR20-5etools.user.js?raw=true";
							const rawCoreInstallUrl = "https://github.com/TheGiddyLimit/betterR20/blob/development/dist/betteR20-core.user.js?raw=true";
							d20plus.ut.sendHackerChat(`<br>A newer version of betteR20 is available.<br>Get ${avail} <a href="${rawToolsInstallUrl}">5etools</a> OR <a href="${rawCoreInstallUrl}">core</a>.<br><br>`);
							d20plus.ut.sendHackerChat(`For help and support, see our <a href="https://wiki.5e.tools/index.php/BetteR20_FAQ">wiki</a> or join our <a href="https://discord.gg/nGvRCDs">Discord</a>.`);
						}, 1000);
					}
				}
			},
			error: () => {
				d20plus.ut.log("Failed to check version");
			},
		})
	};

	d20plus.ut.chatTag = (message) => {
		const isStreamer = !!d20plus.cfg.get("interface", "streamerChatTag");
		d20plus.ut.sendHackerChat(`
				${isStreamer ? "Script" : message} initialised.
				${window.enhancementSuiteEnabled ? `<br><br>Roll20 Enhancement Suite detected.` : ""}
				${isStreamer ? "" : `
				<br>
				<br>
				Need help? Visit our <a href="https://wiki.5e.tools/index.php/Feature:_BetteR20">Wiki</a> or Join our <a href="https://discord.gg/nGvRCDs">Discord</a>.
				<br>
				<br>
				<span title="You'd think this would be obvious.">
				Please DO NOT post about this script or any related content in official channels, including the Roll20 forums.
				<br>
				<br>
				Before reporting a bug on the Roll20 forums, please disable the script and check if the problem persists.
				`}
				</span>
			`);
	};

	d20plus.ut.showLoadingMessage = (message) => {
		const isStreamer = !!d20plus.cfg.get("interface", "streamerChatTag");
		d20plus.ut.sendHackerChat(`
			${isStreamer ? "Script" : message} initialising, please wait...<br><br>
		`);
		d20plus.ut.sendHackerChat(`
			VTT Enhancement Suite version 1.15.35 or above is required.<br><br>
		`);
	};

	d20plus.ut.sendHackerChat = (message) => {
		d20.textchat.incoming(false, ({
			who: "system",
			type: "system",
			content: `<span class="hacker-chat">
				${message}
			</span>`,
		}));
	};

	d20plus.ut.addCSS = (sheet, selectors, rules) => {
		if (!(selectors instanceof Array)) selectors = [selectors];

		selectors.forEach(selector => {
			const index = sheet.cssRules.length;
			try {
				if ("insertRule" in sheet) {
					sheet.insertRule(`${selector}{${rules}}`, index);
				} else if ("addRule" in sheet) {
					sheet.addRule(selector, rules, index);
				}
			} catch (e) {
				if ((!selector && selector.startsWith("-webkit-"))) {
					// eslint-disable-next-line no-console
					console.error(`Selector was "${selector}"; rules were "${rules}"`, e);
				}
			}
		});
	};

	d20plus.ut.addAllCss = () => {
		d20plus.ut.log("Adding CSS");

		const targetSheet = [...window.document.styleSheets]
			.filter(it => it.href && (!it.href.startsWith("moz-extension") && !it.href.startsWith("chrome-extension")))
			.find(it => it.href.includes("app.css"));

		_.each(d20plus.css.baseCssRules, function (r) {
			d20plus.ut.addCSS(targetSheet, r.s, r.r);
		});
		if (!window.is_gm) {
			_.each(d20plus.css.baseCssRulesPlayer, function (r) {
				d20plus.ut.addCSS(targetSheet, r.s, r.r);
			});
		}
		_.each(d20plus.css.cssRules, function (r) {
			d20plus.ut.addCSS(targetSheet, r.s, r.r);
		});
	};

	d20plus.ut.getAntiCacheSuffix = () => {
		return `?${(new Date()).getTime()}`;
	};

	d20plus.ut.generateRowId = () => {
		return window.generateUUID().replace(/_/g, "Z");
	};

	d20plus.ut.randomRoll = (roll, success, error) => {
		d20.textchat.diceengine.process(roll, success, error);
	};

	d20plus.ut.getJournalFolderObj = () => {
		d20.journal.refreshJournalList();
		let journalFolder = d20.Campaign.get("journalfolder");
		if (journalFolder === "") {
			d20.journal.addFolderToFolderStructure("Characters");
			d20.journal.refreshJournalList();
			journalFolder = d20.Campaign.get("journalfolder");
		}
		return JSON.parse(journalFolder);
	};

	d20plus.ut._lastInput = null;
	d20plus.ut.getNumberRange = (promptText, min, max) => {
		function alertInvalid () {
			alert("Please enter a valid range.");
		}

		function isOutOfRange (num) {
			return num < min || num > max;
		}

		function addToRangeVal (range, num) {
			range.add(num);
		}

		function addToRangeLoHi (range, lo, hi) {
			for (let i = lo; i <= hi; ++i) {
				range.add(i);
			}
		}

		function alertOutOfRange () {
			alert(`Please enter numbers in the range ${min}-${max} (inclusive).`);
		}

		while (true) {
			const res = prompt(promptText, d20plus.ut._lastInput || "E.g. 1-5, 8, 11-13");
			if (res && res.trim()) {
				d20plus.ut._lastInput = res;
				const clean = res.replace(/\s*/g, "");
				if (/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean)) {
					const parts = clean.split(",");
					const out = new Set();
					let failed = false;

					for (const part of parts) {
						if (part.includes("-")) {
							const spl = part.split("-");
							const numLo = Number(spl[0]);
							const numHi = Number(spl[1]);

							if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi) {
								alertInvalid();
								failed = true;
								break;
							}

							if (isOutOfRange(numLo) || isOutOfRange(numHi)) {
								alertOutOfRange();
								failed = true;
								break;
							}

							if (numLo === numHi) {
								addToRangeVal(out, numLo);
							} else {
								addToRangeLoHi(out, numLo, numHi);
							}
						} else {
							const num = Number(part);
							if (isNaN(num) || num === 0) {
								alertInvalid();
								failed = true;
								break;
							} else {
								if (isOutOfRange(num)) {
									alertOutOfRange();
									failed = true;
									break;
								}
								addToRangeVal(out, num);
							}
						}
					}

					if (!failed) {
						d20plus.ut._lastInput = null;
						return out;
					}
				} else {
					alertInvalid();
				}
			} else {
				d20plus.ut._lastInput = null;
				return null;
			}
		}
	};

	d20plus.ut.getPathById = (pathId) => {
		return d20plus.ut._getCanvasElementById(pathId, "thepaths");
	};

	d20plus.ut.getTokenById = (tokenId) => {
		return d20plus.ut._getCanvasElementById(tokenId, "thegraphics");
	};

	d20plus.ut._getCanvasElementById = (id, prop) => {
		const foundArr = d20.Campaign.pages.models.map(model => model[prop] && model[prop].models ? model[prop].models.find(it => it.id === id) : null).filter(it => it);
		return foundArr.length ? foundArr[0] : null;
	};

	d20plus.ut.getMacroByName = (macroName) => {
		const macros = d20.Campaign.players.map(p => p.macros.find(m => m.get("name") === macroName && (p.id === window.currentPlayer.id || m.visibleToCurrentPlayer())))
			.filter(Boolean);
		if (macros.length) {
			return macros[0];
		}
		return null;
	};

	d20plus.ut._BYTE_UNITS = ["kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
	d20plus.ut.getReadableFileSizeString = (fileSizeInBytes) => {
		let i = -1;
		do {
			fileSizeInBytes = fileSizeInBytes / 1024;
			i++;
		} while (fileSizeInBytes > 1024);
		return Math.max(fileSizeInBytes, 0.1).toFixed(1) + d20plus.ut._BYTE_UNITS[i];
	};

	d20plus.ut.sanitizeFilename = function (str) {
		return str.trim().replace(/[^-\w]/g, "_");
	};

	d20plus.ut.saveAsJson = function (filename, data) {
		const blob = new Blob([JSON.stringify(data, null, "\t")], {type: "application/json"});
		d20plus.ut.saveAs(blob, `${filename}.json`);
	};

	// based on:
	/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/src/FileSaver.js */
	d20plus.ut.saveAs = (function () {
		const view = window;
		let
			doc = view.document;
			// only get URL when necessary in case Blob.js hasn't overridden it yet
		let get_URL = function () {
			return view.URL || view.webkitURL || view;
		};
		let save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
		let can_use_save_link = "download" in save_link;
		let click = function (node) {
			let event = new MouseEvent("click");
			node.dispatchEvent(event);
		};
		let is_safari = /constructor/i.test(view.HTMLElement) || view.safari;
		let is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent);
		let setImmediate = view.setImmediate || view.setTimeout;
		let throw_outside = function (ex) {
			setImmediate(function () {
				throw ex;
			}, 0);
		};
		let force_saveable_type = "application/octet-stream";
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		let arbitrary_revoke_timeout = 1000 * 40; // in ms
		let revoke = function (file) {
			let revoker = function () {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		};
		let dispatch = function (filesaver, event_types, event) {
			event_types = [].concat(event_types);
			let i = event_types.length;
			while (i--) {
				let listener = filesaver[`on${event_types[i]}`];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		};
		let auto_bom = function (blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		};
		let FileSaver = function (blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			let
				filesaver = this;
			let type = blob.type;
			let force = type === force_saveable_type;
			let object_url;
			let dispatch_all = function () {
				dispatch(filesaver, "writestart progress write writeend".split(" "));
			};
			// on any filesys errors revert to saving with object URLs
			let fs_error = function () {
				if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
					// Safari doesn't allow downloading of blob urls
					let reader = new FileReader();
					reader.onloadend = function () {
						let url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
						let popup = view.open(url, "_blank");
						if (!popup) view.location.href = url;
						url = undefined; // release reference before dispatching
						filesaver.readyState = filesaver.DONE;
						dispatch_all();
					};
					reader.readAsDataURL(blob);
					filesaver.readyState = filesaver.INIT;
					return;
				}
				// don't create more object URLs than needed
				if (!object_url) {
					object_url = get_URL().createObjectURL(blob);
				}
				if (force) {
					view.location.href = object_url;
				} else {
					let opened = view.open(object_url, "_blank");
					if (!opened) {
						// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
						view.location.href = object_url;
					}
				}
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
			};
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setImmediate(function () {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				}, 0);
				return;
			}

			fs_error();
		};
		let FS_proto = FileSaver.prototype;
		let saveAs = function (blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		};
		// IE 10+ (native saveAs)
		if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
			return function (blob, name, no_auto_bom) {
				name = name || blob.name || "download";

				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				return navigator.msSaveOrOpenBlob(blob, name);
			};
		}
		FS_proto.abort = function () {};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;
		FS_proto.error =
			FS_proto.onwritestart =
				FS_proto.onprogress =
					FS_proto.onwrite =
						FS_proto.onabort =
							FS_proto.onerror =
								FS_proto.onwriteend =
									null;

		return saveAs;
	}());

	d20plus.ut.promiseDelay = function (delay) {
		return new Promise(resolve => {
			setTimeout(() => resolve(), delay);
		})
	};

	d20plus.ut.LAYERS = ["map", "background", "objects", "foreground", "gmlayer", "walls", "weather"];
	d20plus.ut.layerToName = (l) => {
		switch (l) {
			case "map": return "Map";
			case "background": return "Background";
			case "objects": return "Objects & Tokens";
			case "foreground": return "Foreground";
			case "gmlayer": return "GM Info Overlay";
			case "walls": return "Dynamic Lighting";
			case "weather": return "Weather Exclusions";
		}
	};

	d20plus.ut.get$SelValue = ($sel) => {
		return $sel[0].options[$sel[0].selectedIndex].value;
	};

	d20plus.ut.isUseSharedJs = () => {
		return BASE_SITE_URL.includes("://5e.tools")
			|| BASE_SITE_URL.includes("://5etools.com")
			|| /:\/\/5etools-mirror-\d+\./.test(BASE_SITE_URL);
	};

	d20plus.ut.fixSidebarLayout = () => {
		$(`#textchat-input`).insertAfter(`#textchat`);
		const cached = d20.textchat.showPopout;
		d20.textchat.showPopout = function () {
			cached();
			const cached2 = d20.textchat.childWindow.onbeforeunload;
			d20.textchat.childWindow.onbeforeunload = function () {
				cached2();
				$(`#textchat-input`).insertAfter(`#textchat`);
			}
		}
	};

	/**
	* Assumes any other lists have been searched using the same term
	*/
	d20plus.ut.getSearchTermAndReset = (list, ...otherLists) => {
		let lastSearch = null;
		if (list.searched) {
			lastSearch = $(`#search`).val();
			list.search();
			otherLists.forEach(l => l.search());
		}
		list.filter();
		otherLists.forEach(l => l.filter());
		return lastSearch;
	};
}

SCRIPT_EXTENSIONS.push(baseUtil);

/*

map
afow
grid
background
objects
foreground
gmlayer
walls
weather

 */


function baseJsLoad () {
	d20plus.js = {};

	d20plus.js.scripts = [
		// {name: "listjs", url: "https://raw.githubusercontent.com/javve/list.js/v1.5.0/dist/list.min.js"},
		// {name: "localforage", url: "https://raw.githubusercontent.com/localForage/localForage/1.7.3/dist/localforage.min.js"},
		// {name: "JSZip", url: `https://raw.githubusercontent.com/Stuk/jszip/master/dist/jszip.min.js`},
	];

	if (d20plus.ut.isUseSharedJs()) {
		// d20plus.js.scripts.push({name: "5etoolsShared", url: `${SITE_JS_URL}shared.js`});
	} else {
		// d20plus.js.scripts.push({name: "5etoolsParser", url: `${SITE_JS_URL}parser.js`});
		// d20plus.js.scripts.push({name: "5etoolsUtils", url: `${SITE_JS_URL}utils.js`});
	}

	d20plus.js.apiScripts = [
		// {name: "VecMath", url: "https://raw.githubusercontent.com/Roll20/roll20-api-scripts/master/Vector%20Math/1.0/VecMath.js"},
		// {name: "MatrixMath", url: "https://raw.githubusercontent.com/Roll20/roll20-api-scripts/master/MatrixMath/1.0/matrixMath.js"},
		// {name: "PathMath", url: "https://raw.githubusercontent.com/Roll20/roll20-api-scripts/master/PathMath/1.5/PathMath.js"}
	];

	d20plus.js._unpackScript = script => {
		return script.trim().split("\n").slice(1, -1).join("\n");
	};

	d20plus.js.pAddScripts = async () => {
		d20plus.ut.log("Add JS");

		EXT_LIB_SCRIPTS.forEach(script => {
			d20plus.js._addScript("???", d20plus.js._unpackScript(script));
		});

		await Promise.all(d20plus.js.scripts.map(async it => {
			const js = await d20plus.js.pLoadWithRetries(it.name, it.url);
			d20plus.js._addScript(it.name, js)
		}));

		// Monkey patch JSON loading
		const cached = DataUtil.loadJSON;
		DataUtil.loadJSON = async (url, ...others) => {
			const xUrl = new URL(url);

			const cleanPathName = xUrl.pathname.replace(/^\//, "");
			if (JSON_DATA[cleanPathName]) {
				const out = JSON_DATA[cleanPathName];
				await DataUtil.pDoMetaMerge(cleanPathName, out);
				return out;
			}

			if (url.startsWith("data/")) {
				url = BASE_SITE_URL + url;
			}

			return cached.bind(DataUtil)(url, ...others);
		};
	};

	d20plus.js.pAddApiScripts = async () => {
		d20plus.ut.log("Add Builtin API Scripts");

		EXT_LIB_API_SCRIPTS.forEach(script => {
			d20plus.js._addScript("???", d20plus.js._unpackScript(script));
		});

		await Promise.all(d20plus.js.apiScripts.map(async it => {
			const js = await d20plus.js.pLoadWithRetries(it.name, it.url);
			d20plus.js._addScript(it.name, js);
		}));
	};

	d20plus.js._addScript = (name, js) => {
		// sanity check
		if (js instanceof Promise) throw new Error(`Promise was passed instead of text! This is a bug.`);
		try {
			// eslint-disable-next-line no-eval
			window.eval(js);
			d20plus.ut.log(`JS [${name}] Loaded`);
		} catch (e) {
			d20plus.ut.log(`Error loading [${name}]`);
			d20plus.ut.log(e);
			throw e;
		}
	};

	d20plus.js.pLoadWithRetries = async (name, url) => {
		let retries = 3;

		function pFetchData () {
			return new Promise((resolve, reject) => {
				$.ajax({
					type: "GET",
					url: `${url}${d20plus.ut.getAntiCacheSuffix()}${retries}`,
					success: function (data) {
						resolve(data);
					},
					error: function (resp, qq, pp) {
						if (resp && resp.status >= 400 && retries-- > 0) {
							// eslint-disable-next-line no-console
							console.error(resp, qq, pp);
							d20plus.ut.log(`Error loading ${name}; retrying`);
							setTimeout(() => {
								reject(new Error(`Loading "${name}" failed (status ${resp.status}): ${resp} ${qq} ${pp}`));
							}, 500);
						} else {
							// eslint-disable-next-line no-console
							console.error(resp, qq, pp);
							setTimeout(() => {
								reject(new Error(`Loading "${name}" failed (status ${resp.status}): ${resp} ${qq} ${pp}`));
							}, 500);
						}
					},
				});
			})
		}

		let data;
		do {
			try {
				data = await pFetchData();
			} catch (e) {
				// error handling is done as part of data fetching
			}
		} while (!data && --retries > 0);

		if (data) return data;
		else throw new Error(`Failed to load ${name} from URL ${url}`);
	};

	d20plus.js.pLoadJsonWithRetries = async (name, url) => {
		let retries = 3;

		let out;
		let lastErr = null;
		while (retries-- > 0) {
			try {
				out = await DataUtil.loadJSON(`${url}${d20plus.ut.getAntiCacheSuffix()}${retries}`);
			} catch (e) {
				lastErr = e;
			}

			if (lastErr && retries) {
				d20plus.ut.log(`Error loading ${name}; retrying after 100ms`);
				await MiscUtil.pDelay(100);
			}
		}

		if (!retries) {
			d20plus.ut.error(`Failed to load "${name}" (URL was: ${url} )`);
			throw lastErr;
		}

		return out;
	};
}

SCRIPT_EXTENSIONS.push(baseJsLoad);


function baseQpi () {
	const qpi = {
		_version: "0.01-pre-pre-alpha",
		_: {
			log: {
				_ (...args) {
					qpi._log(...args)
				},
				works: 1,
			},

			// Campaign: { // FIXME this overwrites the window's campaign, which breaks stuff
			// 	_ () {
			// 		return Campaign;
			// 	},
			// 	works: 0
			// },

			on: {
				_preInit () {
					qpi._on_chatHandlers = [];
					const seenMessages = new Set();
					d20.textchat.chatref = d20.textchat.shoutref.parent.child("chat");
					const handleChat = (e) => {
						if (!d20.textchat.chatstartingup) {
							e.id = e.key();
							if (!seenMessages.has(e.id)) {
								seenMessages.add(e.id);

								let t = e.val();
								if (t) {
									// eslint-disable-next-line no-console
									if (window.DEBUG) console.log("CHAT: ", t);

									qpi._on_chatHandlers.forEach(fn => fn(t));
								}
							}
						}
					};
					d20.textchat.chatref.on("child_added", handleChat);
					d20.textchat.chatref.on("child_changed", handleChat);
				},
				_ (evtType, fn, ...others) {
					switch (evtType) {
						case "chat:message":
							qpi._on_chatHandlers.push(fn);
							break;
						default:
							// eslint-disable-next-line no-console
							console.error("Unhandled message type: ", evtType, "with args", fn, others)
							break;
					}
				},
				works: 0.01,
				notes: [
					`"chat:message" is the only available event.`,
				],
			},

			createObj: {
				_ (objType, obj, ...others) {
					switch (objType) {
						case "path": {
							const page = d20.Campaign.pages._byId[obj._pageid];
							obj.scaleX = obj.scaleX || 1;
							obj.scaleY = obj.scaleY || 1;
							obj.path = obj.path || obj._path
							return page.thepaths.create(obj)
						}
						default:
							// eslint-disable-next-line no-console
							console.error("Unhandled object type: ", objType, "with args", obj, others)
							break;
					}
				},
				works: 0.01,
				notes: [
					`Only supports "path" obects.`,
				],
			},

			sendChat: { // TODO lift code from doChatInput
				_ (speakingAs, input, callback, options) {
					const message = {
						who: speakingAs,
						type: "general",
						content: input,
						playerid: window.currentPlayer.id,
						avatar: null,
						inlinerolls: [],
					};

					const key = d20.textchat.chatref.push().key();
					d20.textchat.chatref.child(key).setWithPriority(message, Firebase.ServerValue.TIMESTAMP)
				},
				works: 0.01,
				notes: [
					`speakingAs: String only.`,
					`input: String only.`,
					`callback: Unimplemented.`,
					`options: Unimplemented.`,
					`Messages are always sent with the player ID of the QPI user.`,
				],
			},

			// findObjs: {
			// 	_ (attrs) {
			// 		// TODO
			// 		// const getters = {
			// 		// 	attribute: () => {},
			// 		// 	character: () => {},
			// 		// 	handout: () => {}
			// 		// };
			// 		// const getAll = () => {
			// 		// 	const out = [];
			// 		// 	Object.values(getters).forEach(fn => out.push(...fn()));
			// 		// 	return out;
			// 		// };
			//
			// 		// let out = attrs._type ? getters[attrs._type]() : getAll();
			//
			// 		throw new Error("findObjs is unimplemented!");
			// 	},
			// 	works: 0.00,
			// 	notes: [
			// 		`Unimplemented.`
			// 	]
			// }
		},

		_loadedScripts: null,
		async _init () {
			Object.keys(qpi._).forEach(k => {
				const it = qpi._[k];
				if (it._preInit) it._preInit();
				window[k] = it._;
			});

			qpi._loadedScripts = await StorageUtil.pGet("VeQpi") || {};

			$(`body`).append(`
				<div id="qpi-manager" title="Better20 - QPI Script Manager - v${qpi._version}">
					<div class="qpi-table"></div>
					<div>
						<input placeholder="URL*" class="qpi-url">
						<button class="btn qpi-add-url">Add URL</button>
					</div>
					<hr>
					<div>
						<input placeholder="Name*" class="qpi-name">
						<button class="btn qpi-add-text">Load Script</button>
						<br>
						<textarea class="qpi-text" style="width: 100%; height: 300px; resize: vertical;"></textarea>
					</div>
					<hr>
					<button class="btn qpi-help">Help/README</button> <i>Note that this tool is a for-testing faceplate over some internal code. It is intended for internal use only.</i>
				</div>
			`);
			$(`#qpi-manager`).dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			$(`body`).append(`
				<div id="qpi-manager-readme" title="QPI README - v${qpi._version}">
					<div class="qpi-readme"></div>
				</div>
			`);
			$(`#qpi-manager-readme`).dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			qpi._log("Initialised!");
		},

		man (name) {
			if (!name) {
				qpi._log(`Showing all...\n==== Available API Mimics ====\n  - ${Object.keys(qpi._).join("()\n  - ")}()`);
				return;
			}

			const found = Object.keys(qpi._).find(k => k === name);
			if (!found) qpi._log(`No mimic with ${name} found -- perhaps it's unimplemented?`);
			else {
				const it = qpi._[found];
				qpi._log(`Showing "${name}"...\n==== ${name} :: ${it.works * 100}% functional ====\n${(it.notes || []).join("\n")}`);
			}
		},

		_manHtml () {
			let stack = "";
			Object.keys(qpi._).forEach(k => {
				stack += `<h5>${k}</h5>`;
				const it = qpi._[k];
				stack += `<p><i>Estimated ${it.works * 100}% functional</i><br>${(it.notes || []).join("<br>")}</p>`;
			});
			return stack;
		},

		_openManager () {
			const $win = $(`#qpi-manager`);

			$win.find(`.qpi-help`).off("click").on("click", () => {
				const $winReadme = $(`#qpi-manager-readme`);
				$winReadme.dialog("open");

				$winReadme.find(`.qpi-readme`).html(qpi._manHtml());
			});

			$win.find(`.qpi-add-url`).off("click").on("click", () => {
				const url = $win.find(`.qpi-url`).val();
				if (url && script.trim()) {
					qpi._log(`Attempting to load: "${url}"`);
					d20plus.js.pLoadWithRetries(
						url,
						url,
					).then(data => {
						d20plus.js._addScript(url, data).then(() => {
							alert("Loaded successfully!");
							$win.find(`.qpi-url`).val("");
						}).catch(() => {
							alert(`Failed to load script! ${VeCt.STR_SEE_CONSOLE}`);
						});
					})
				} else {
					alert("Please enter a URL!");
				}
			});

			$win.find(`.qpi-add-text`).off("click").on("click", () => {
				const name = $win.find(`.qpi-name`).val();
				const script = $win.find(`.qpi-text`).val();
				if (name && script && name.trim() && script.trim()) {
					qpi._log(`Attempting to eval user script: ${name}`);
					d20plus.js._addScript(name, script).then(() => {
						alert("Loaded successfully!");
						$win.find(`.qpi-name`).val("");
						$win.find(`.qpi-text`).val("");
					}).catch(() => {
						alert("Failed to load script! See the console for more details (CTRL-SHIFT-J on Chrome)");
					});
				} else {
					alert("Please enter a name and some code!");
				}
			});

			$win.dialog("open");
		},

		_log (...args) {
			// eslint-disable-next-line no-console
			console.log("%cQPI > ", "color: #ff00ff; font-size: large", ...args);
		},
	};
	window.qpi = qpi;

	d20plus.qpi = {};
	d20plus.qpi.pInitMockApi = async () => { // TODO check if this needs to be enabled for players too
		d20plus.ut.log("Initialising mock API");
		await qpi._init();
	};
}

SCRIPT_EXTENSIONS.push(baseQpi);


// Borrowed with <3 from Stormy's JukeboxIO
function baseJukebox () {
	d20plus.jukebox = {
		playPlaylist (playlistId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-folder[data-globalfolderid="${playlistId}"]`)
				.find("> .dd-content .play[data-isplaying=false]")
				.trigger("click");
		},

		playTrack (trackId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-item[data-itemid="${trackId}"]`)
				.find("> .dd-content .play[data-isplaying=false]")
				.trigger("click");
		},

		stopPlaylist (playlistId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-folder[data-globalfolderid="${playlistId}"]`)
				.find("> .dd-content .play[data-isplaying=true]")
				.trigger("click");
		},

		stopTrack (trackId) {
			$(document)
				.find(`#jukeboxfolderroot .dd-item[data-itemid="${trackId}"]`)
				.find("> .dd-content .play[data-isplaying=true]")
				.trigger("click");
		},

		play (id) {
			d20plus.jukebox.playPlaylist(id);
			d20plus.jukebox.playTrack(id);
		},

		stop (id) {
			d20plus.jukebox.stopPlaylist(id);
			d20plus.jukebox.stopTrack(id);
		},

		stopAll () {
			d20.jukebox.stopAllTracks();
		},

		skip () {
			const playlistId = d20plus.jukebox.getCurrentPlayingPlaylist();
			d20.jukebox.stopAllTracks();
			d20plus.jukebox.playPlaylist(playlistId);
		},

		getCurrentPlayingTracks () {
			let playlingTracks = [];
			window.Jukebox.playlist.each((track) => {
				if (track.get("playing")) {
					playlingTracks.push(track.attributes);
				}
			});
			return playlingTracks;
		},

		getCurrentPlayingPlaylist () {
			const id = d20.Campaign.attributes.jukeboxplaylistplaying;
			return id ? id.split("|")[0] : id;
		},

		addJukeboxChangeHandler (func) {
			d20plus.jukebox.addPlaylistChangeHandler(func);
			d20plus.jukebox.addTrackChangeHandler(func);
		},

		addPlaylistChangeHandler (func) {
			d20.Campaign.on("change:jukeboxplaylistplaying change:jukeboxfolder", func);
		},

		addTrackChangeHandler (func) {
			window.Jukebox.playlist.each((track) => {
				track.on("change:playing", func);
			});
		},

		getJukeboxFileStructure () {
			d20plus.jukebox.forceJukeboxRefresh();
			return window.d20.jukebox.lastFolderStructure;
		},

		getTrackById (id) {
			return window.Jukebox.playlist.get(id);
		},

		getJukeboxPlaylists () {
			const fs = d20plus.jukebox.getJukeboxFileStructure();
			const retVals = [];

			for (const fsItem of fs) {
				if (typeof (fsItem) === "string") continue;

				const rawPlaylist = fsItem;

				const playlist = {
					name: rawPlaylist.n,
					mode: rawPlaylist.s,
					tracks: [],
				};

				for (const trackId of rawPlaylist.i) {
					const track = d20plus.jukebox.getTrackById(trackId);
					if (!track) {
						// eslint-disable-next-line no-console
						console.warn(`Tried to get track id ${trackId} but the query returned a falsy value. Skipping`);
						continue;
					}

					playlist.tracks.push(track);
				}

				retVals.push(playlist);
			}

			return retVals;
		},

		getJukeboxTracks () {
			const fs = d20plus.jukebox.getJukeboxFileStructure();

			const retVals = [];

			for (const fsItem of fs) {
				if (typeof (fsItem) !== "string") continue;

				const track = d20plus.jukebox.getTrackById(fsItem);
				if (!track) {
					// eslint-disable-next-line no-console
					console.warn(`Tried to get track id ${fsItem} but the query returned a falsy value. Skipping`);
					continue;
				}

				retVals.push(track);
			}

			return retVals;
		},

		_getExportableTrack (s) {
			return {
				loop: s.attributes.loop,
				playing: s.attributes.playing,
				softstop: s.attributes.softstop,
				source: s.attributes.source,
				tags: s.attributes.tags,
				title: s.attributes.title,
				track_id: s.attributes.track_id,
				volume: s.attributes.volume,
			};
		},

		getExportablePlaylists () {
			return d20plus.jukebox.getJukeboxPlaylists().map(p => {
				return {
					name: p.name,
					mode: p.mode,
					tracks: p.tracks.map(d20plus.jukebox._getExportableTrack),
				};
			});
		},

		getExportableTracks () {
			return d20plus.jukebox.getJukeboxTracks().map(d20plus.jukebox._getExportableTrack);
		},

		importWrappedData (data) {
			d20plus.jukebox.forceJukeboxRefresh();

			const tracks = (data.tracks || []).map(t => d20plus.jukebox.createTrack(t).id);

			const playlists = (data.playlists || []).map(p => {
				const trackIds = p.tracks.map(s => d20plus.jukebox.createTrack(s).id);
				return d20plus.jukebox.makePlaylistStructure(p.name, p.mode, trackIds);
			});

			let fs = JSON.parse(d20.Campaign.attributes.jukeboxfolder);
			fs = fs.concat(tracks, playlists);

			d20.Campaign.save({
				jukeboxfolder: JSON.stringify(fs),
			});
		},

		createTrack (data) {
			return window.Jukebox.playlist.create(data);
		},

		makePlaylistStructure (name, mode, trackIds) {
			return {
				id: window.generateUUID(),
				n: name,
				s: mode,
				i: trackIds || [],
			};
		},

		forceJukeboxRefresh () {
			const $jukebox = $("#jukebox");
			const serializable = $jukebox.find("#jukeboxfolderroot").nestable("serialize");
			serializable && d20.Campaign.save({
				jukeboxfolder: JSON.stringify(serializable),
			});
		},
	};
}

SCRIPT_EXTENSIONS.push(baseJukebox);


function baseMath () {
	d20plus.math = {
		vec2: {
			/**
			 * Normalize a 2d vector.
			 * @param out Result storage
			 * @param a Vector to normalise
			 */
			normalize (out, a) {
				const x = a[0];
				const y = a[1];
				let len = x * x + y * y;
				if (len > 0) {
					len = 1 / Math.sqrt(len);
					out[0] = a[0] * len;
					out[1] = a[1] * len;
				}
				return out;
			},

			/**
			 * Scale a 2d vector.
			 * @param out Resulst storage
			 * @param a Vector to scale
			 * @param b Value to scale by
			 */
			scale (out, a, b) {
				out[0] = a[0] * b;
				out[1] = a[1] * b;
				return out;
			},

			/**
			 * Rotate a 2D vector
			 * @param {vec2} out The receiving vec2
			 * @param {vec2} a The vec2 point to rotate
			 * @param {vec2} b The origin of the rotation
			 * @param {Number} c The angle of rotation
			 * @returns {vec2} out
			 */
			rotate (out, a, b, c) {
				// Translate point to the origin
				let p0 = a[0] - b[0];
				let p1 = a[1] - b[1];
				let sinC = Math.sin(c);
				let cosC = Math.cos(c);

				// perform rotation and translate to correct position
				out[0] = p0 * cosC - p1 * sinC + b[0];
				out[1] = p0 * sinC + p1 * cosC + b[1];
				return out;
			},

			/**
			 * Adds two vec2's
			 *
			 * @param {vec2} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec2} out
			 */
			add (out, a, b) {
				out[0] = a[0] + b[0];
				out[1] = a[1] + b[1];
				return out;
			},

			/**
			 * Subtracts vector b from vector a
			 *
			 * @param {vec2} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec2} out
			 */
			sub (out, a, b) {
				out[0] = a[0] - b[0];
				out[1] = a[1] - b[1];
				return out;
			},

			/**
			 * Computes the cross product of two vec2's
			 * Note that the cross product must by definition produce a 3D vector
			 *
			 * @param {vec3} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec3} out
			 */
			cross (out, a, b) {
				let z = a[0] * b[1] - a[1] * b[0];
				out[0] = out[1] = 0;
				out[2] = z;
				return out;
			},

			/**
			 * Multiplies two vec2's
			 *
			 * @param {vec2} out the receiving vector
			 * @param {vec2} a the first operand
			 * @param {vec2} b the second operand
			 * @returns {vec2} out
			 */
			mult (out, a, b) {
				out[0] = a[0] * b[0];
				out[1] = a[1] * b[1];
				return out;
			},

			/**
			 * Calculates the length of a vec2
			 *
			 * @param {vec2} a vector to calculate length of
			 * @returns {Number} length of a
			 */
			len (a) {
				const x = a[0]; const y = a[1];
				return Math.sqrt(x * x + y * y);
			},
		},

		/**
		 * Helper function to determine whether there is an intersection between the two polygons described
		 * by the lists of vertices. Uses the Separating Axis Theorem
		 *
		 * @param a an array of connected points [[x, y], [x, y],...] that form a closed polygon
		 * @param b an array of connected points [[x, y], [x, y],...] that form a closed polygon
		 * @return boolean true if there is any intersection between the 2 polygons, false otherwise
		 */
		doPolygonsIntersect (a, b) {
			const polygons = [a, b];
			let minA, maxA, projected, i, i1, j, minB, maxB;

			for (i = 0; i < polygons.length; i++) {
				// for each polygon, look at each edge of the polygon, and determine if it separates
				// the two shapes
				const polygon = polygons[i];
				for (i1 = 0; i1 < polygon.length; i1++) {
					// grab 2 vertices to create an edge
					const i2 = (i1 + 1) % polygon.length;
					const p1 = polygon[i1];
					const p2 = polygon[i2];

					// find the line perpendicular to this edge
					const normal = [p2[1] - p1[1], p1[0] - p2[0]];

					minA = maxA = undefined;
					// for each vertex in the first shape, project it onto the line perpendicular to the edge
					// and keep track of the min and max of these values
					for (j = 0; j < a.length; j++) {
						projected = normal[0] * a[j][0] + normal[1] * a[j][1];
						if (minA === undefined || projected < minA) minA = projected;
						if (maxA === undefined || projected > maxA) maxA = projected;
					}

					// for each vertex in the second shape, project it onto the line perpendicular to the edge
					// and keep track of the min and max of these values
					minB = maxB = undefined;
					for (j = 0; j < b.length; j++) {
						projected = normal[0] * b[j][0] + normal[1] * b[j][1];
						if (minB === undefined || projected < minB) minB = projected;
						if (maxB === undefined || projected > maxB) maxB = projected;
					}

					// if there is no overlap between the projects, the edge we are looking at separates the two
					// polygons, and we know there is no overlap
					if (maxA < minB || maxB < minA) {
						return false;
					}
				}
			}
			return true;
		},
	};
}

SCRIPT_EXTENSIONS.push(baseMath);


function baseConfig () {
	d20plus.cfg = {current: {}};

	d20plus.cfg.pLoadConfigFailed = false;

	d20plus.cfg.pLoadConfig = async () => {
		d20plus.ut.log("Reading Config");
		let configHandout = d20plus.cfg.getConfigHandout();

		if (!configHandout) {
			d20plus.ut.log("No config found! Initialising new config...");
			await d20plus.cfg.pMakeDefaultConfig();
		}

		configHandout = d20plus.cfg.getConfigHandout();
		if (configHandout) {
			configHandout.view.render();
			return new Promise(resolve => {
				configHandout._getLatestBlob("gmnotes", async function (gmnotes) {
					try {
						const decoded = decodeURIComponent(gmnotes);

						d20plus.cfg.current = JSON.parse(decoded);

						d20plus.ut.log("Config Loaded:");
						d20plus.ut.log(d20plus.cfg.current);
						resolve();
					} catch (e) {
						// eslint-disable-next-line no-console
						console.error(e);
						if (!d20plus.cfg.pLoadConfigFailed) {
							// prevent infinite loops
							d20plus.cfg.pLoadConfigFailed = true;

							d20plus.ut.log("Corrupted config! Rebuilding...");
							await d20plus.cfg.pMakeDefaultConfig();
							await d20plus.cfg.pLoadConfig();
							resolve();
						} else {
							// if the config fails, continue to load anyway
							resolve();
						}
					}
				});
			});
		} else d20plus.ut.log("Failed to create config handout!");
	};

	d20plus.cfg.pLoadPlayerConfig = async () => {
		d20plus.ut.log("Reading player Config");
		const loaded = await StorageUtil.pGet(`Veconfig`);
		if (!loaded) {
			d20plus.ut.log("No player config found! Initialising new config...");
			const dfltConfig = d20plus.cfg.getDefaultConfig();
			d20plus.cfg.current = Object.assign(d20plus.cfg.current, dfltConfig);
			await StorageUtil.pSet(`Veconfig`, d20plus.cfg.current);
		} else {
			d20plus.cfg.current = loaded;
		}
		d20plus.ut.log("Player config Loaded:");
		d20plus.ut.log(d20plus.cfg.current);
	};

	d20plus.cfg.pMakeDefaultConfig = () => {
		return new Promise(resolve => {
			d20.Campaign.handouts.create({
				name: CONFIG_HANDOUT,
				archived: true,
			}, {
				success: function (handout) {
					notecontents = "The GM notes contain config options saved between sessions. If you want to wipe your saved settings, delete this handout and reload roll20. If you want to edit your settings, click the \"Edit Config\" button in the <b>Settings</b> (cog) panel.";

					// default settings
					// token settings mimic official content; other settings as vanilla as possible
					const gmnotes = JSON.stringify(d20plus.cfg.getDefaultConfig());

					handout.updateBlobs({notes: notecontents, gmnotes: gmnotes});
					handout.save({notes: (new Date()).getTime(), inplayerjournals: ""});

					resolve();
				},
			});
		});
	};

	d20plus.cfg.getConfigHandout = () => {
		d20plus.ut.getJournalFolderObj(); // ensure journal init

		return d20.Campaign.handouts.models.find(function (handout) {
			return handout.attributes.name === CONFIG_HANDOUT;
		});
	};

	d20plus.cfg.getCfgKey = (group, val) => {
		if (val === undefined || d20plus.cfg.current[group] === undefined) return undefined;
		const gr = d20plus.cfg.current[group];
		for (const key of Object.keys(d20plus.cfg.current[group])) {
			if (gr[key] !== undefined && gr[key] === val) {
				return key;
			}
		}
		return undefined;
	};

	d20plus.cfg.getRawCfgVal = (group, key) => {
		if (d20plus.cfg.current[group] === undefined) return undefined;
		if (d20plus.cfg.current[group][key] === undefined) return undefined;
		return d20plus.cfg.current[group][key];
	};

	d20plus.cfg.get = (group, key) => {
		if (d20plus.cfg.current[group] === undefined) return undefined;
		if (d20plus.cfg.current[group][key] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key]._type === "_SHEET_ATTRIBUTE") {
			if (!NPC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]]) return undefined;
			return NPC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]][d20plus.sheet];
		}
		if (CONFIG_OPTIONS[group][key]._type === "_SHEET_ATTRIBUTE_PC") {
			if (!PC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]]) return undefined;
			return PC_SHEET_ATTRIBUTES[d20plus.cfg.current[group][key]][d20plus.sheet];
		}
		return d20plus.cfg.current[group][key];
	};

	d20plus.cfg.getDefault = (group, key) => {
		return d20plus.cfg._getProp("default", group, key);
	};

	d20plus.cfg.getPlaceholder = (group, key) => {
		return d20plus.cfg._getProp("_placeholder", group, key);
	};

	d20plus.cfg._getProp = (prop, group, key) => {
		if (CONFIG_OPTIONS[group] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key] === undefined) return undefined;
		return CONFIG_OPTIONS[group][key][prop];
	};

	d20plus.cfg.getOrDefault = (group, key) => {
		if (d20plus.cfg.has(group, key)) return d20plus.cfg.get(group, key);
		return d20plus.cfg.getDefault(group, key);
	};

	d20plus.cfg.getCfgEnumVals = (group, key) => {
		if (CONFIG_OPTIONS[group] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key] === undefined) return undefined;
		return CONFIG_OPTIONS[group][key].__values
	};

	d20plus.cfg.getCfgSliderVals = (group, key) => {
		if (CONFIG_OPTIONS[group] === undefined) return undefined;
		if (CONFIG_OPTIONS[group][key] === undefined) return undefined;
		const it = CONFIG_OPTIONS[group][key];
		return {
			min: it.__sliderMin,
			max: it.__sliderMax,
			step: it.__sliderStep,
		}
	};

	d20plus.cfg.getDefaultConfig = () => {
		const outCpy = {};
		$.each(CONFIG_OPTIONS, (sectK, sect) => {
			if (window.is_gm || sect._player) {
				outCpy[sectK] = outCpy[sectK] || {};
				$.each(sect, (k, data) => {
					if (!k.startsWith("_") && (window.is_gm || data._player)) {
						outCpy[sectK][k] = data.default;
					}
				});
			}
		});
		return outCpy;
	};

	// Helpful for checking if a boolean option is set even if false
	d20plus.cfg.has = (group, key) => {
		if (d20plus.cfg.current[group] === undefined) return false;
		return d20plus.cfg.current[group][key] !== undefined;
	};

	d20plus.cfg.setCfgVal = (group, key, val) => {
		if (d20plus.cfg.current[group] === undefined) d20plus.cfg.current[group] = {};
		d20plus.cfg.current[group][key] = val;
	};

	d20plus.cfg.makeTabPane = ($addTo, headers, content) => {
		if (headers.length !== content.length) throw new Error("Tab header and content length were not equal!");

		if ($addTo.attr("hastabs") !== "YES") {
			const $tabBar = $(`<ul class="nav nav-tabs"/>`);

			const tabList = [];
			const paneList = [];
			const $tabPanes = $(`<div class="tabcontent"/>`);

			$.each(content, (i, e) => {
				const toAdd = $(`<div class="plustab${i} tab-pane" ${i === 0 ? "" : `style="display: none"`}/>`);
				toAdd.append(e);
				paneList[i] = toAdd;
				$tabPanes.append(toAdd);
			});

			$.each(headers, (i, e) => {
				const toAdd = $(`<li ${i === 0 ? `class="active"` : ""}><a data-tab="plustab${i}" href="#">${e}</a></li>`).on("click", () => {
					paneList.forEach((p, i2) => {
						if (i2 === i) {
							tabList[i2].addClass("active");
							paneList[i2].show();
						} else {
							tabList[i2].removeClass("active");
							paneList[i2].hide();
						}
					});
				});
				tabList[i] = (toAdd);
				$tabBar.append(toAdd);
			});

			$addTo
				.append($tabBar)
				.append($tabPanes);

			$addTo.attr("hastabs", "YES");
		}
	};

	d20plus.cfg.openConfigEditor = () => {
		const cEdit = $("#d20plus-configeditor");
		cEdit.dialog("open");

		if (cEdit.attr("hastabs") !== "YES") {
			cEdit.attr("hastabs", "YES");
			const appendTo = $(`<div/>`);
			cEdit.prepend(appendTo);

			const configFields = {};

			let sortedKeys = Object.keys(CONFIG_OPTIONS).sort((a, b) => d20plus.ut.ascSort(CONFIG_OPTIONS[a]._name, CONFIG_OPTIONS[b]._name));
			if (!window.is_gm) sortedKeys = sortedKeys.filter(k => CONFIG_OPTIONS[k]._player);

			const tabList = sortedKeys.map(k => CONFIG_OPTIONS[k]._name);

			const makeTab = (cfgK) => {
				const cfgGroup = CONFIG_OPTIONS[cfgK];
				configFields[cfgK] = {};

				const content = $(`
						<div class="config-table-wrapper">
							<table class="config-table">
								<thead><tr><th>Property</th><th>Value</th></tr></thead>
								<tbody></tbody>
							</table>
						</div>
					`);
				const tbody = content.find(`tbody`);

				let sortedTabKeys = Object.keys(cfgGroup).filter(k => !k.startsWith("_"));
				if (!window.is_gm) sortedTabKeys = sortedTabKeys.filter(k => cfgGroup[k]._player);

				sortedTabKeys.forEach((grpK, idx) => {
					const prop = cfgGroup[grpK];

					// IDs only used for label linking
					const toAdd = $(`<tr><td><label for="conf_field_${idx}" class="config-name">${prop.name}</label></td></tr>`);

					// Each config `_type` should have a case here. Each case should add a function to the map [configFields:[cfgK:grpK]]. These functions should return the value of the input.
					switch (prop._type) {
						case "boolean": {
							const field = $(`<input type="checkbox" id="conf_field_${idx}" ${d20plus.cfg.getOrDefault(cfgK, grpK) ? `checked` : ""}>`);

							configFields[cfgK][grpK] = () => {
								return field.prop("checked")
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "String": {
							const curr = d20plus.cfg.get(cfgK, grpK) || "";
							const placeholder = d20plus.cfg.getPlaceholder(cfgK, grpK);
							const def = d20plus.cfg.getDefault(cfgK, grpK) || "";
							const field = $(`<input id="conf_field_${idx}" value="${curr}" ${placeholder ? `placeholder="${placeholder}"` : def ? `placeholder="Default: ${def}"` : ""}>`);

							configFields[cfgK][grpK] = () => {
								return field.val() ? field.val().trim() : "";
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "_SHEET_ATTRIBUTE_PC":
						case "_SHEET_ATTRIBUTE": {
							const DICT = prop._type === "_SHEET_ATTRIBUTE" ? NPC_SHEET_ATTRIBUTES : PC_SHEET_ATTRIBUTES;
							const sortedNpcsAttKeys = Object.keys(DICT).sort((at1, at2) => d20plus.ut.ascSort(DICT[at1].name, DICT[at2].name));
							const field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${sortedNpcsAttKeys.map(npcK => `<option value="${npcK}">${DICT[npcK].name}</option>`)}</select>`);
							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return field.val()
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "float":
						case "integer": {
							const def = d20plus.cfg.getDefault(cfgK, grpK);
							const curr = d20plus.cfg.get(cfgK, grpK);
							const field = $(`<input id="conf_field_${idx}" type="number" ${curr != null ? `value="${curr}"` : ""} ${def != null ? `placeholder="Default: ${def}"` : ""} step="any">`);

							configFields[cfgK][grpK] = () => {
								return Number(field.val());
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "_FORMULA": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.formulas._options.sort().map(opt => `<option value="${opt}">${opt}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_WHISPERMODE": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.whisperModes.map(mode => `<option value="${mode}">${mode}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_ADVANTAGEMODE": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.advantageModes.map(mode => `<option value="${mode}">${mode}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_DAMAGEMODE": {
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.damageModes.map(mode => `<option value="${mode}">${mode}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_enum": { // for generic String enums not covered above
							const $field = $(`<select id="conf_field_${idx}" class="cfg_grp_${cfgK}" data-item="${grpK}">${d20plus.cfg.getCfgEnumVals(cfgK, grpK).map(it => `<option value="${it}">${it}</option>`)}</select>`);

							const cur = d20plus.cfg.get(cfgK, grpK);
							if (cur !== undefined) {
								$field.val(cur);
							} else {
								const def = d20plus.cfg.getDefault(cfgK, grpK);
								if (def !== undefined) {
									$field.val(def);
								}
							}

							configFields[cfgK][grpK] = () => {
								return $field.val();
							};

							const td = $(`<td/>`).append($field);
							toAdd.append(td);
							break;
						}
						case "_slider": {
							const def = d20plus.cfg.getDefault(cfgK, grpK);
							const curr = d20plus.cfg.get(cfgK, grpK);
							const sliderMeta = d20plus.cfg.getCfgSliderVals(cfgK, grpK);

							const field = $(`<input style="max-width: calc(100% - 40px);" type="range" min="${sliderMeta.min || 0}" max="${sliderMeta.max || 0}" step="${sliderMeta.step || 1}" value="${curr == null ? def : curr}">`);

							configFields[cfgK][grpK] = () => {
								return Number(field.val());
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
						case "_color": {
							const value = d20plus.cfg.getOrDefault(cfgK, grpK);

							const field = $(`<input type="color" value="${value == null ? "" : value}">`);

							configFields[cfgK][grpK] = () => {
								return field.val();
							};

							const td = $(`<td/>`).append(field);
							toAdd.append(td);
							break;
						}
					}
					tbody.append(toAdd);
				});

				return content;
			}

			const contentList = sortedKeys.map(k => makeTab(k));

			d20plus.cfg.makeTabPane(
				appendTo,
				tabList,
				contentList,
			);

			const saveButton = $(`#configsave`);
			saveButton.unbind("click");
			saveButton.bind("click", () => {
				function _updateLoadedConfig () {
					$.each(configFields, (cfgK, grp) => {
						$.each(grp, (grpK, grpVField) => {
							d20plus.cfg.setCfgVal(cfgK, grpK, grpVField());
						})
					});
				}

				if (window.is_gm) {
					const doSave = () => {
						_updateLoadedConfig();

						const gmnotes = JSON.stringify(d20plus.cfg.current).replace(/%/g, "%25");
						handout.updateBlobs({gmnotes: gmnotes});
						handout.save({notes: (new Date()).getTime()});

						d20plus.ut.log("Saved config");

						d20plus.cfg.baseHandleConfigChange();
						if (d20plus.cfg5e) d20plus.cfg5e.handleConfigChange();
					};

					let handout = d20plus.cfg.getConfigHandout();
					if (!handout) {
						d20plus.cfg.pMakeDefaultConfig(doSave);
					} else {
						doSave();
					}
				} else {
					_updateLoadedConfig();
					StorageUtil.pSet(`Veconfig`, d20plus.cfg.current);
					d20plus.cfg.baseHandleConfigChange();
					if (d20plus.cfg5e) d20plus.cfg5e.handleConfigChange();
				}
			});
		}
	};

	/*
	// Left here for future use, in case anything similar is required
	d20plus.cfg._handleWeatherConfigChange = () => {
		function handleProp (prop) {
			const campaignKey = `bR20cfg_${prop}`;
			if (d20plus.cfg.has("weather", prop)) {
				Campaign && Campaign.save({[campaignKey]: d20plus.cfg.get("weather", prop)});
			} else {
				if (Campaign) {
					delete Campaign[campaignKey];
					Campaign.save();
				}
			}
		}
		if (window.is_gm) {
			handleProp("weatherType1");
			handleProp("weatherTypeCustom1");
			handleProp("weatherSpeed1");
			handleProp("weatherDir1");
			handleProp("weatherDirCustom1");
			handleProp("weatherOscillate1");
			handleProp("weatherOscillateThreshold1");
			handleProp("weatherIntensity1");
			handleProp("weatherTint1");
			handleProp("weatherTintColor1");
			handleProp("weatherEffect1");
		}
	};
	*/

	d20plus.cfg.baseHandleConfigChange = () => {
		// d20plus.cfg._handleWeatherConfigChange();
		if (d20plus.cfg.has("interface", "toolbarOpacity")) {
			const v = Math.max(Math.min(Number(d20plus.cfg.get("interface", "toolbarOpacity")), 100), 0);
			$(`#secondary-toolbar`).css({opacity: v * 0.01});
		}

		$(`#floatinglayerbar`).toggle(d20plus.cfg.getOrDefault("interface", "quickLayerButtons"));
		$(`#init-quick-sort-desc`).toggle(d20plus.cfg.getOrDefault("interface", "quickInitButtons"));
		$(`input[placeholder="Search by tag or name..."]`).parent().toggle(!d20plus.cfg.getOrDefault("interface", "hideDefaultJournalSearch"))
	};

	d20plus.cfg.startPlayerConfigHandler = () => {
		function handlePlayerCfg () {
			d20plus.cfg.baseHandleConfigChange();
			if (d20plus.handleConfigChange) d20plus.handleConfigChange(true);
		}

		// every 5 seconds, poll and apply any config changes the GM might have made
		if (!window.is_gm) {
			setInterval(() => {
				handlePlayerCfg();
			}, 5000);
		}
		handlePlayerCfg();
	};
}

SCRIPT_EXTENSIONS.push(baseConfig);


function baseTool () {
	d20plus.tool = {};

	/**
	 * Each tool should have:
	 *  - `name` List display name.
	 *  - `desc` List display description.
	 *  - `html` The html created when the button is clicked
	 *  - `dialogFn` Function called to initialize dialog.
	 *  - `openFn` Function called when tool is opened.
	 */
	d20plus.tool.tools = [
		{
			name: "Journal Cleaner",
			desc: "Quickly select and delete journal items, especially useful for cleaning up loose items after deleting a folder.",
			html: `
				<div id="d20plus-quickdelete" title="BetteR20 - Journal Root Cleaner">
				<p>A list of characters and handouts in the journal folder root, which allows them to be quickly deleted.</p>
				<label class="bold">Root Only <input type="radio" name="cb-mode" class="cb-shallow cb-mode"></label>
				<label class="bold">All Items <input type="radio" name="cb-mode" class="cb-deep cb-mode"></label>
				<label class="bold">All Items and Folders<input type="radio" name="cb-mode" class="cb-folder cb-mode"></label>
				<label class="bold">Rollable Tables <input type="radio" name="cb-mode" class="cb-tables cb-mode"></label>
				<hr>
				<p style="display: flex; justify-content: space-between"><label><input type="checkbox" title="Select all" id="deletelist-selectall"> Select All</label> <a class="btn" href="#" id="quickdelete-btn-submit">Delete Selected</a></p>
				<div id="delete-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list deletelist" style="max-height: 420px; overflow-y: scroll; display: block; margin: 0;"></ul>
				</div>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-quickdelete").dialog({
					autoOpen: false,
					resizable: true,
					width: 800,
					height: 700,
				});
			},
			openFn: () => {
				const $win = $("#d20plus-quickdelete");
				$win.dialog("open");

				// Create a variable for each box
				const $cbMode = $win.find(".cb-mode");
				const $cbShallow = $win.find(`.cb-shallow`);
				const $cbDeep = $win.find(`.cb-deep`);
				const $cbTables = $win.find(`.cb-tables`);
				const $cbFolder = $win.find(`.cb-folder`);

				const $cbAll = $("#deletelist-selectall").unbind("click");

				const $btnDel = $(`#quickdelete-btn-submit`).off("click");

				// When a a different box gets checked, populate the list
				$cbMode.off("change").on("change", () => populateList());

				// Don't even ask why populateList needs to be called twice
				$cbShallow.prop("checked", true);
				populateList();

				function populateList () {
					// collect a list of all journal items
					function getAllJournalItems () {
						const out = [];

						function recurse (entry, pos, isRoot) {
							if (entry.i) {
								if (!isRoot) pos.push(entry.n);
								entry.i.forEach(nxt => recurse(nxt, pos));
								pos.pop();
							} else out.push({id: entry, path: MiscUtil.copy(pos)});
						}

						const root = {i: d20plus.ut.getJournalFolderObj()};
						recurse(root, [], true);
						return out.map(it => getItemFromId(it.id, it.path.join(" / ")));
					}

					function getFolderJournalItems () {
						// Similar to get all Journal Items, but lists folders as well
						const out = [];

						// Go through the directory structure recursively
						function recurse (entry, pos, isRoot) {
							// I property is list of children, only folders have it
							if (entry.i) {
								// Add the folder name to the path
								if (!isRoot) pos.push(entry.n);

								// This adds directory names to out
								if (!isRoot) out.push({id: entry, path: MiscUtil.copy(pos)});

								// Run through the directory on each of the children
								entry.i.forEach(nxt => recurse(nxt, pos));

								// Remove the folder from the path when done
								pos.pop();
							} 
							// Only triggers for non-folders, adds non-folders to list
							else out.push({id: entry, path: MiscUtil.copy(pos)});
						}

						// Get the directory structure and start traversal through it
						const root = {i: d20plus.ut.getJournalFolderObj()};
						recurse(root, [], true);
						return out.map(it => getItemFromId(it.id, it.path.join(" / ")));
					}

					function getRootJournalItems () {
						const rootItems = [];
						const journal = d20plus.ut.getJournalFolderObj();
						journal.forEach(it => {
							if (it.i) return; // skip folders
							rootItems.push(getItemFromId(it));
						});
						return rootItems;
					}

					function getItemFromId (itId, path = "") {
						// Get handout object, undefined if item is not a handout
						const handout = d20.Campaign.handouts.get(itId);
						if (handout && (handout.get("name") === CONFIG_HANDOUT || handout.get("name") === ART_HANDOUT)) return null; // skip 5etools handouts

						// Get character object, undefined if item is not a character
						const character = d20.Campaign.characters.get(itId);

						// Return based on which object isn't empty
						if (handout) return {type: "handouts", id: itId, name: handout.get("name"), path: path, archived: handout.attributes.archived};
						if (character) return {type: "characters", id: itId, name: character.get("name"), path: path, archived: character.attributes.archived};

						// If both are empty, check if item is a folder and return a folder type
						if (d20plus.journal.checkDirExistsByPath(path.split(" / "))) return {type: "folder", id: itId, name: "", path:path, archived: false, folder: true}
					}

					function getJournalItems () {
						// For the root only option
						if ($cbShallow.prop("checked")) return getRootJournalItems().filter(Boolean);

						// For the all files option
						if ($cbDeep.prop("checked")) return getAllJournalItems().filter(Boolean);

						// For the all files and folder option
						if ($cbFolder.prop("checked")) return getFolderJournalItems().filter(Boolean);

						// For the get rollable tables option
						if ($cbTables.prop("checked")) return getRollableTables().filter(Boolean);
					}

					// Allow for deleting tables as well
					function getRollableTables() {
						let tItems = [];
						if ($cbTables.prop("checked")) {
							// Get a tableobject from the d20 thing and loop through it
							const tableObject = d20.Campaign.rollabletables;
							for (i = 0; i < tableObject.length; i++) {
								// If it looks confusing, it is. Just trust that I got the objects properly
								const tAttr = tableObject.at(i).attributes;
								const tObj = {
									name: tAttr.name,
									id: tAttr.id,
									type: "rollabletables",
									table: true
								};
								tItems.push(tObj);
							}
						}
						return tItems;
					}

					// Populate different lists based on which box is checked
					const journalItems = getJournalItems();		

					// Display found items
					const $delList = $win.find(`.list`);
					$delList.empty();

					journalItems.forEach((it, i) => {
						$delList.append(`
							<label class="import-cb-label" data-listid="${i}">
								<input type="checkbox">
								<span class="name readable">${it.path ? `${it.path} / ` : ""}${it.name}</span>
								${it.archived ? `<span class="name readable">(archived)</span>` : ""}
								${it.table ? `<span class="name readable">(table)</span>` : ""}
								${it.folder ? `<span class="name readable">(folder)</span>` : ""}
							</label>
						`);
					});

					// init list library
					const delList = new List("delete-list-container", {
						valueNames: ["name"],
						listClass: "deletelist",
					});

					$cbAll.prop("checked", false);
					$cbAll.off("click").click(() => d20plus.importer._importToggleSelectAll(delList, $cbAll));

					$btnDel.off("click").on("click", () => {
						const sel = delList.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => journalItems[$(it.elm).attr("data-listid")]);

						if (!sel.length) {
							alert("No items selected!");
						} else if (confirm(`Are you sure you want to delete the ${sel.length} selected item${sel.length > 1 ? "s" : ""}?`)) {
							$win.dialog("close");
							$("a.ui-tabs-anchor[href='#journal']").trigger("click");
							sel.forEach(toDel => {
								// If the item is a folder, use the folder deletion functon
								if (toDel.folder) d20plus.journal.removeDirByPath(toDel.path.split(" / "));

								// Otherwise delete through d20 object
								else d20.Campaign[toDel.type].get(toDel.id).destroy();
							});
							$("#journalfolderroot").trigger("change");
						}
					});
				}
			},
		},
		{
			name: "SVG Draw",
			desc: "Paste SVG data as text to automatically draw the paths.",
			html: `
				<div id="d20plus-svgdraw" title="Better20 - SVG Drawing Tool">
				<p>Paste SVG data as text to automatically draw any included &lt;path&gt;s. Draws to the current layer, in the top-left corner, with no scaling. Takes colour information from &quot;stroke&quot; attributes.</p>
				<p>Line width (px; default values are 1, 3, 5, 8, 14): <input name="stroke-width" placeholder="5" value="5" type="number"></p>
				<textarea rows="10" cols="100" placeholder="Paste SVG data here"></textarea>
				<br>
				<button class="btn">Draw</button>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-svgdraw").dialog({
					autoOpen: false,
					resizable: true,
					width: 800,
					height: 650,
				});
			},
			openFn: () => {
				// adapted from `d20.engine.finishCurrentPolygon`
				function addShape (path, pathStroke, strokeWidth) {
					let i = d20.engine.convertAbsolutePathStringtoFabric(path);
					i = _.extend(i, {
						strokeWidth: strokeWidth,
						fill: "transparent",
						stroke: pathStroke,
						path: JSON.parse(i.path),
					});
					d20.Campaign.activePage().addPath(i);
					d20.engine.redrawScreenNextTick();
				}

				const $win = $("#d20plus-svgdraw");
				$win.dialog("open");

				$win.find(`button`).off("click").on("click", () => {
					d20plus.ut.log("Drawing paths");
					const input = $win.find(`textarea`).val();
					const svg = $.parseXML(input);

					const toDraw = $(svg).find("path").map((i, e) => {
						const $e = $(e);
						return {stroke: $e.attr("stroke") || "black", d: $e.attr("d")}
					}).get();

					const strokeWidth = Math.max(1, Number($win.find(`input[name="stroke-width"]`).val()));

					toDraw.forEach(it => {
						addShape(it.d, it.stroke, strokeWidth)
					});
				});
			},
		},
		{
			name: "Multi-Whisper",
			desc: "Send whispers to multiple players ",
			html: `
				<div id="d20plus-whispers" title="Better20 - Multi-Whisper Tool">
				<div>
					<button class="btn toggle-dc">Show Disconnected Players</button>
					<button class="btn send-all">Send All Messages</button>
					<button class="btn clear-all">Clear All Messages</button>
				</div>
				<hr>
				<div class="messages" style="max-height: 600px; overflow-y: auto; overflow-x: hidden; transform: translateZ(0)">
					<!-- populate with JS -->
				</div>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-whispers").dialog({
					autoOpen: false,
					resizable: true,
					width: 1000,
					height: 760,
				});
			},
			openFn: () => {
				$("a.ui-tabs-anchor[href='#textchat']").trigger("click");

				const $win = $("#d20plus-whispers");
				$win.dialog("open");

				const $btnToggleDc = $win.find(`.toggle-dc`).off("click").text("Show Disconnected Players");
				const $btnSendAll = $win.find(`.send-all`).off("click");
				const $btnClearAll = $win.find(`.clear-all`).off("click");

				const $pnlMessages = $win.find(`.messages`).empty();
				const players = d20.Campaign.players.toJSON();
				players.forEach((p, i) => {
					const $btnSend = $(`<button class="btn send" style="margin-right: 5px;">Send</button>`).on("click", function () {
						const $btn = $(this);
						const $wrp = $btn.closest(`.wrp-message`);
						const toMsg = $wrp.find(`input[data-player-id]:checked`).filter(":visible").map((ii, e) => $(e).attr("data-player-id")).get();
						const content = $wrp.find(`.message`).val().trim();
						toMsg.forEach(targetId => {
							d20.textchat.doChatInput(`/w ${d20.Campaign.players.get(targetId).get("displayname").split(" ")[0]} ${content}`);

							// This only posts to local player's chat, sadly
							// d20.textchat.incoming(
							// 	false,
							// 	{
							// 		avatar: `/users/avatar/${window.currentPlayer.get("d20userid")}/30`,
							// 		who: d20.textchat.$speakingas.find("option:first-child").text(),
							// 		type: "whisper",
							// 		content: content,
							// 		playerid: window.currentPlayer.id,
							// 		id: d20plus.ut.generateRowId(),
							// 		target: targetId,
							// 		target_name: d20.Campaign.players.get(targetId).get("displayname") || ""
							// 	}
							// );
						})
					});

					const $btnClear = $(`<button class="btn msg-clear">Clear</button>`).on("click", function () {
						$(this).closest(`.wrp-message`).find(`.message`).val("");
					});

					$pnlMessages.append($(`
							<div ${p.online || `style="display: none;"`} data-online="${p.online}" class="wrp-message">
								<div>
									${players.map((pp, ii) => `<label style="margin-right: 10px; ${pp.online || ` display: none;`}" data-online="${pp.online}" class="display-inline-block">${pp.displayname} <input data-player-id="${pp.id}" type="checkbox" ${i === ii ? `checked="true"` : ""}></label>`).join("")}
								</div>
								<textarea style="display: block; width: 95%;" placeholder="Enter whisper" class="message"></textarea>
							</div>
						`).append($btnSend).append($btnClear).append(`<hr>`));
				});

				$btnToggleDc.on("click", () => {
					$btnToggleDc.text($btnToggleDc.text().startsWith("Show") ? "Hide Disconnected Players" : "Show Disconnected Players");
					$pnlMessages.find(`[data-online="false"]`).toggle();
				});

				$btnSendAll.on("click", () => {
					$pnlMessages.find(`button.send`).click();
				});

				$btnClearAll.on("click", () => $pnlMessages.find(`button.msg-clear`).click());
			},
		},
		{
			name: "Table Importer Expanded",
			desc: "Import TableExport data from an expanded list",
			html: `
				<div id="d20plus-expanded" title="Table Importer Expanded">
					<div id="table-list-expanded">
						<input type="search" class="search" placeholder="Search tables...">
						<div class="list" style="transform: translateZ(0); max-height: 490px; overflow-y: scroll; overflow-x: hidden;"><i>Loading...</i></div>
					</div>
				<br>
				<button class="btn start-import">Import</button>
				</div>

				<div id="d20plus-expanded-clipboard" title="Paste from Clipboard"/>
				`,
			dialogFn: () => {
				$("#d20plus-expanded").dialog({
					autoOpen: false,
					resizable: true,
					width: 650,
					height: 720,
				});
				$(`#d20plus-expanded-clipboard`).dialog({
					autoOpen: false,
					resizable: true,
					width: 640,
					height: 480,
				});
			},
			openFn: () => {
				const $win = $("#d20plus-expanded");
				$win.dialog("open");

				const $btnImport = $win.find(`.start-import`).off("click");

				const url = "https://raw.githubusercontent.com/TheGiddyLimit/TheGiddyLimit.github.io/master/data/generated/gendata-tables.json";
				DataUtil.loadJSON(url).then((data) => {
					// The function in charge of generating and saving the full table
					function createTable (t) {
						// Creates the table, with data for the full table
						const r20t = d20.Campaign.rollabletables.create({
							name: t.name.replace(/\s+/g, "-"),
							id: d20plus.ut.generateRowId(),
						});

						labels = t.colLabels;
						// Gets the index of the first column labeled with a dice roll
						// For example, finds the d100 column
						const dplace = labels.findIndex(l => /d[0-9]+/.test(l));
						const tlen = labels.length;

						r20t.tableitems.reset(t.rows.map(i => {
							// Create the return value
							const out = {
								id: d20plus.ut.generateRowId(),
								name: "",
							};

							// Set the name
							for (let col = 0; col < tlen; col++) {
								// Add a seperator for cases of multiple columns
								if (out.name.length > 0) {
									out.name += " | "
								}
								// Add each column to out.name
								if (col !== dplace) {
									// Get rid of ugly notation
									clean = i[col].replace(/\{@[\w\d]* (.*)}/, "$1");
									out.name += clean;
								}
							}

							// Set the weight
							if (dplace !== -1) {
								weight = i[dplace];
								dash = weight.indexOf("–"); // Note: – is different from -

								// If the weight is a range
								if (dash !== -1) {
									// Get the two numbers in the range, subtract them, add 1
									low = parseInt(weight.substring(0, dash));
									high = parseInt(weight.substring(dash + 1));
									if (high === 0) high = 100;
									out.weight = high - low + 1;
								} else { // If the weight is a single value
									out.weight = 1;
								}
							} else { // If the weight is unlisted
								out.weight = 1;
							}

							if (i.avatar) out.avatar = i.avatar;
							return out;
						}));
						r20t.tableitems.forEach(it => it.save());
					}

					// Official tables
					const $lst = $win.find(`.list`);
					const tables = data.table.sort((a, b) => SortUtil.ascSort(a.name, b.name));
					let tmp = "";
					tables.forEach((t, i) => {
						tmp += `
								<label class="import-cb-label" data-listid="${i}">
									<input type="checkbox">
									<span class="name col-10">${t.name}</span>
									<span title="${t.source ? Parser.sourceJsonToFull(t.source) : "Unknown Source"}" class="source">SRC[${t.source ? Parser.sourceJsonToAbv(t.source) : "UNK"}]</span>
								</label>
							`;
					});
					$lst.html(tmp);
					tmp = null;

					const tableList = new List("table-list-expanded", {
						valueNames: ["name", "source"],
					});

					$btnImport.on("click", () => {
						$("a.ui-tabs-anchor[href='#deckstables']").trigger("click");
						const sel = tableList.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => tables[$(it.elm).attr("data-listid")]);

						sel.forEach(t => createTable(t));
					});
				});
			},
		},
		{
			name: "Table Importer",
			desc: "Import TableExport data",
			html: `
				<div id="d20plus-tables" title="Better20 - Table Importer">
					<div>
					<button class="btn paste-clipboard">Paste from Clipboard</button> <i>Accepts <a href="https://app.roll20.net/forum/post/1144568/script-tableexport-a-script-for-exporting-and-importing-rollable-tables-between-accounts">TableExport</a> format.</i>
					</div>
					<br>
					<div id="table-list">
						<input type="search" class="search" placeholder="Search tables...">
						<div class="list" style="transform: translateZ(0); max-height: 490px; overflow-y: scroll; overflow-x: hidden;"><i>Loading...</i></div>
					</div>
				<br>
				<button class="btn start-import">Import</button>
				</div>

				<div id="d20plus-tables-clipboard" title="Paste from Clipboard"/>
				`,
			dialogFn: () => {
				$("#d20plus-tables").dialog({
					autoOpen: false,
					resizable: true,
					width: 650,
					height: 720,
				});
				$(`#d20plus-tables-clipboard`).dialog({
					autoOpen: false,
					resizable: true,
					width: 640,
					height: 480,
				});
			},
			openFn: () => {
				const $win = $("#d20plus-tables");
				$win.dialog("open");

				const $btnImport = $win.find(`.start-import`).off("click");
				const $btnClipboard = $win.find(`.paste-clipboard`).off("click");

				const url = `${BASE_SITE_URL}/data/roll20-tables.json`;
				DataUtil.loadJSON(url).then((data) => {
					function createTable (t) {
						const r20t = d20.Campaign.rollabletables.create({
							name: t.name.replace(/\s+/g, "-"),
							showplayers: t.isShown,
							id: d20plus.ut.generateRowId(),
						});

						r20t.tableitems.reset(t.items.map(i => {
							const out = {
								id: d20plus.ut.generateRowId(),
								name: i.row,
							};
							if (i.weight !== undefined) out.weight = i.weight;
							if (i.avatar) out.avatar = i.avatar;
							return out;
						}));
						r20t.tableitems.forEach(it => it.save());
					}

					// Allow pasting of custom tables
					$btnClipboard.on("click", () => {
						const $wrpClip = $(`#d20plus-tables-clipboard`);
						const $iptClip = $(`<textarea placeholder="Paste TableExport data here" style="display: block; width: 600px; height: 340px;"/>`).appendTo($wrpClip);
						const $btnCheck = $(`<button class="btn" style="margin-right: 5px;">Check if Valid</button>`).on("click", () => {
							let error = false;
							try {
								getFromPaste($iptClip.val());
							} catch (e) {
								// eslint-disable-next-line no-console
								console.error(e);
								window.alert(e.message);
								error = true;
							}
							if (!error) window.alert("Looking good!");
						}).appendTo($wrpClip);
						const $btnImport = $(`<button class="btn">Import</button>`).on("click", () => {
							$("a.ui-tabs-anchor[href='#deckstables']").trigger("click");
							const ts = getFromPaste($iptClip.val());
							ts.forEach(t => createTable(t));
							window.alert("Import complete");
						}).appendTo($wrpClip);

						$wrpClip.dialog("open");
					});

					function getFromPaste (paste) {
						const tables = [];
						let tbl = null;

						paste.split("\n").forEach(line => parseLine(line.trim()));
						parseLine(""); // ensure trailing newline
						return tables;

						function parseLine (line) {
							if (line.startsWith("!import-table-item")) {
								if (!tbl) {
									throw new Error("No !import-table statement found");
								}
								const [junk, tblName, row, weight, avatar] = line.split("--").map(it => it.trim());
								tbl.items.push({
									row,
									weight,
									avatar,
								})
							} else if (line.startsWith("!import-table")) {
								if (tbl) {
									throw new Error("No blank line found between tables")
								}
								const [junk, tblName, showHide] = line.split("--").map(it => it.trim());
								tbl = {
									name: tblName,
									isShown: (showHide || "").toLowerCase() === "show",
								};
								tbl.items = [];
							} else if (line.trim()) {
								throw new Error("Non-empty line which didn't match !import-table or !import-table-item")
							} else {
								if (tbl) {
									tables.push(tbl);
									tbl = null;
								}
							}
						}
					}

					// Official tables
					const $lst = $win.find(`.list`);
					const tables = data.table.sort((a, b) => SortUtil.ascSort(a.name, b.name));
					let tmp = "";
					tables.forEach((t, i) => {
						tmp += `
								<label class="import-cb-label" data-listid="${i}">
									<input type="checkbox">
									<span class="name col-10">${t.name}</span>
									<span title="${t.source ? Parser.sourceJsonToFull(t.source) : "Unknown Source"}" class="source">SRC[${t.source ? Parser.sourceJsonToAbv(t.source) : "UNK"}]</span>
								</label>
							`;
					});
					$lst.html(tmp);
					tmp = null;

					const tableList = new List("table-list", {
						valueNames: ["name", "source"],
					});

					$btnImport.on("click", () => {
						$("a.ui-tabs-anchor[href='#deckstables']").trigger("click");
						const sel = tableList.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => tables[$(it.elm).attr("data-listid")]);

						sel.forEach(t => createTable(t));
					});
				});
			},
		},
		{
			name: "Token Avatar URL Fixer",
			desc: "Change the root URL for tokens en-masse.",
			html: `
				<div id="d20plus-avatar-fixer" title="Better20 - Avatar Fixer">
				<p><b>Warning:</b> this thing doesn't really work.</p>
				<p>Current URLs (view only): <select class="view-only"></select></p>
				<p><label>Replace:<br><input name="search" value="https://5e.tools/"></label></p>
				<p><label>With:<br><input name="replace" value="https://5etools-mirror-1.github.io/"></label></p>
				<p><button class="btn">Go!</button></p>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-avatar-fixer").dialog({
					autoOpen: false,
					resizable: true,
					width: 400,
					height: 400,
				});
			},
			openFn: () => {
				function replaceAll (str, search, replacement) {
					return str.split(search).join(replacement);
				}

				const $win = $("#d20plus-avatar-fixer");
				$win.dialog("open");

				const $selView = $win.find(`.view-only`);
				const toView = [];
				d20.Campaign.characters.toJSON().forEach(c => {
					if (c.avatar && c.avatar.trim()) {
						toView.push(c.avatar);
					}
				});
				toView.sort(SortUtil.ascSort).forEach(url => $selView.append(`<option disabled>${url}</option>`));

				const $btnGo = $win.find(`button`).off("click");
				$btnGo.on("click", () => {
					let count = 0;
					$("a.ui-tabs-anchor[href='#journal']").trigger("click");

					const search = $win.find(`[name="search"]`).val();
					const replace = $win.find(`[name="replace"]`).val();

					d20.Campaign.characters.toJSON().forEach(c => {
						const id = c.id;

						const realC = d20.Campaign.characters.get(id);

						const curr = realC.get("avatar");
						let toSave = false;
						if (curr.includes(search)) {
							count++;
							realC.set("avatar", replaceAll(curr, search, replace));
							toSave = true;
						}
						if (realC.get("defaulttoken")) {
							realC._getLatestBlob("defaulttoken", (bl) => {
								bl = bl && bl.trim() ? JSON.parse(bl) : {};
								if (bl && bl.imgsrc && bl.imgsrc.includes(search)) {
									count++;
									realC.updateBlobs({imgsrc: replaceAll(bl.imgsrc, search, replace)});
									toSave = true;
								}
							});
						}

						if (toSave) {
							realC.save();
						}

						for (const page of d20.Campaign.pages.models) {
							if (page.thegraphics && page.thegraphics.models) {
								for (const token of page.thegraphics.models) {
									const tokenImgsrc = token.get("imgsrc");
									if (tokenImgsrc.includes(search)) {
										token.set("imgsrc", tokenImgsrc.replace(search, replace));
										token.save();
										count++;
									}
								}
							}
						}
					});
					window.alert(`Replaced ${count} item${count === 0 || count > 1 ? "s" : ""}.`)
				});
			},
		},
		{
			name: "Mass-Delete Pages",
			desc: "Quickly delete multiple pages.",
			html: `
				<div id="d20plus-mass-page-delete" title="Better20 - Mass-Delete Pages">
					<div id="del-pages-list">
						<div class="list" style="transform: translateZ(0); max-height: 490px; overflow-y: scroll; overflow-x: hidden; margin-bottom: 10px;"><i>Loading...</i></div>
					</div>
					<hr>
					<p><label class="ib"><input type="checkbox" class="select-all"> Select All</label> | <button class="btn btn-danger deleter">Delete</button></p>
					<p><i>This tool will delete neither your active page, nor a page active for players.</i></p>
				</div>
				`,
			dialogFn: () => {
				$("#d20plus-mass-page-delete").dialog({
					autoOpen: false,
					resizable: true,
					width: 600,
					height: 800,
				});
			},
			openFn: () => {
				function deletePage (model, pageList) {
					if ($(`#page-toolbar .availablepage[data-pageid=${model.id}]`).remove()) {
						let n = d20.Campaign.getPageIndex(model.id);
						if (model.thegraphics) {
							model.thegraphics.massdelete = true;
							model.thegraphics.backboneFirebase.reference.set(null);
						}
						if (model.thetexts) {
							model.thetexts.massdelete = true;
							model.thetexts.backboneFirebase.reference.set(null);
						}
						if (model.thepaths) {
							model.thepaths.backboneFirebase.reference.set(null);
							model.thepaths.massdelete = true;
						}
						let i = d20.Campaign.get("playerspecificpages");
						let o = false;
						_.each(i, function (e, n) {
							if (e === model.id) {
								delete i[n];
								o = true;
							}
						});
						o && d20.Campaign.save({
							playerspecificpages: i,
						});
						model.destroy();
						d20.Campaign.activePageIndex > n && (d20.Campaign.activePageIndex -= 1);

						pageList.remove("page-id", model.id);
					}
				}

				const $win = $("#d20plus-mass-page-delete");
				$win.dialog("open");

				const $lst = $win.find(`.list`).empty();

				d20.Campaign.pages.models.forEach(m => {
					$lst.append(`
							<label class="import-cb-label import-cb-label--img" data-listid="${m.id}">
								<input type="checkbox">
								<img class="import-label__img" src="${m.attributes.thumbnail}">
								<span class="name col-9">${m.attributes.name}</span>
								<span style="display: none;" class="page-id">${m.id}</span>
							</label>
						`);
				});

				const pageList = new List("del-pages-list", {
					valueNames: ["name", "page-id"],
				});

				const $cbAll = $win.find(`.select-all`).off("click").click(() => {
					pageList.items.forEach(it => {
						$(it.elm).find(`input[type="checkbox"]`).prop("checked", $cbAll.prop("checked"));
					});
				});

				const $btnDel = $win.find(`.deleter`).off("click").click(() => {
					const sel = pageList.items
						.filter(it => $(it.elm).find(`input`).prop("checked"))
						.map(it => $(it.elm).attr("data-listid"))
						.map(pId => d20.Campaign.pages.models.find(it => it.id === pId))
						.filter(it => it);

					sel.forEach(m => {
						if (m.id !== d20.Campaign.get("playerpageid") && m.id !== d20.Campaign.activePage().id) {
							deletePage(m, pageList);
						}
					});
					$cbAll.prop("checked", false);
				});
			},
		},
		{
			name: "Quantum Token Entangler",
			desc: "Connect tokens between pages, linking their positions.",
			html: `
				<div id="d20plus-token-entangle" title="Better20 - Quantum Token Entangler">
					<p><i>Please note that this feature is highly experimental.
					<br>
					You can learn Token IDs by rightclicking a token -> "Advanced" -> "View Token ID."</i></p>
					<hr>
					<input id="token-entangle-id-1" placeholder="Master ID">
					Type:
					<select id="token-entangle-type-1">
						<option value="0">Token</option>
						<option value="1">Path</option>
					</select>
					<br>
					<input id="token-entangle-id-2" placeholder="Slave ID">
					Type:
					<select id="token-entangle-type-2">
						<option value="0">Token</option>
						<option value="1">Path</option>
					</select>
					<br>
					<button class="btn btn-default" id="token-entangle-go">Entangle</button>
					<hr>
					<input id="token-clear-entangles" placeholder="ID to Clear">
					Type:
					<select id="token-clear-type">
						<option value="0">Token</option>
						<option value="1">Path</option>
					</select>
					<button class="btn btn-default" id="token-entangle-clear">Clear Entangles</button>
				</div>
				`,
			dialogFn: () => {
				const $win = $("#d20plus-token-entangle");

				const entangleTracker = {};
				const ALLOWED_TYPES = ["path", "image"];
				const SYNCABLE_ATTRS_IMAGE = [
					"rotation",
					"width",
					"height",
					"top",
					"left",
					"scaleX",
					"scaleY",
					"fliph",
					"flipv",
				];
				const SYNCABLE_ATTRS_PATH = [
					"rotation",
					"top",
					"left",
					"scaleX",
					"scaleY",
				];

				$win.data("VE_DO_ENTANGLE", (master) => {
					if (!ALLOWED_TYPES.includes(master.attributes.type)) return;

					// prevent double-binding
					if (entangleTracker[master.id]) return;

					const TO_SYNC = master.attributes.type === "image" ? SYNCABLE_ATTRS_IMAGE : SYNCABLE_ATTRS_PATH;

					master.on("change", (it) => {
						let anyUpdates = false;

						if (master.attributes.entangledImages && master.attributes.entangledImages.length) {
							if (TO_SYNC.filter(attr => it.changed[attr] !== undefined).length) {
								master.attributes.entangledImages = master.attributes.entangledImages.filter(id => {
									const slave = d20plus.ut.getTokenById(id);
									const SLAVE_ATTRS = slave.attributes.type === "image" ? SYNCABLE_ATTRS_IMAGE : SYNCABLE_ATTRS_PATH;
									if (slave) {
										TO_SYNC
											.filter(attr => SLAVE_ATTRS.includes(attr))
											.filter(attr => master.attributes[attr] != null)
											.forEach(attr => slave.attributes[attr] = master.attributes[attr]);
										slave.save();
										return true;
									} else {
										// eslint-disable-next-line no-console
										console.warn(`Could not find entangled token with ID "${id}", removing...`);
										anyUpdates = true;
									}
								});
							}
						}

						if (master.attributes.entangledPaths && master.attributes.entangledPaths.length) {
							if (TO_SYNC.filter(attr => it.changed[attr] !== undefined).length) {
								master.attributes.entangledPaths = master.attributes.entangledPaths.filter(id => {
									const slave = d20plus.ut.getPathById(id);
									const SLAVE_ATTRS = slave.attributes.type === "image" ? SYNCABLE_ATTRS_IMAGE : SYNCABLE_ATTRS_PATH;
									if (slave) {
										TO_SYNC
											.filter(attr => SLAVE_ATTRS.includes(attr))
											.filter(attr => master.attributes[attr] != null)
											.forEach(attr => slave.attributes[attr] = master.attributes[attr]);
										slave.save();
										return true;
									} else {
										// eslint-disable-next-line no-console
										console.warn(`Could not find entangled path with ID "${id}", removing...`);
										anyUpdates = true;
									}
								});
							}
						}

						if (anyUpdates) master.save();
					})
				});

				// do initial entangles
				const runInitial = () => {
					const pages = d20.Campaign.pages;
					if (pages && pages.models) {
						d20plus.ut.log("Initialisng existing entangles...");
						d20.Campaign.pages.models
							.forEach(model => {
								const PROPS = {
									thegraphics: "entangledImages",
									thepaths: "entangledPaths",
								};
								Object.keys(PROPS).forEach(prop => {
									Object.values(PROPS).forEach(attrK => {
										if (model[prop] && model[prop].models) {
											model[prop].models.filter(it => it.attributes[attrK] && it.attributes[attrK].length).forEach(it => {
												$win.data("VE_DO_ENTANGLE")(it);
											})
										}
									});
								});
							});
					} else {
						// eslint-disable-next-line no-console
						console.log("Pages uninitialised, waiting...");
						setTimeout(runInitial, 1000);
					}
				};

				runInitial();

				$win.dialog({
					autoOpen: false,
					resizable: true,
					width: 800,
					height: 400,
				});
			},
			openFn: () => {
				const ATTR_PROPS = ["entangledImages", "entangledPaths"];

				const notFound = (id, type) => alert(`${type === "image" ? "Token" : "Path"} with ID ${id} didn't exist!`);

				const $win = $("#d20plus-token-entangle");
				$win.dialog("open");

				const $ipt1 = $(`#token-entangle-id-1`);
				const $ipt2 = $(`#token-entangle-id-2`);
				const $selType1 = $(`#token-entangle-type-1`);
				const $selType2 = $(`#token-entangle-type-2`);

				const $btnGo = $(`#token-entangle-go`)
					.off("click")
					.click(() => {
						const id1 = $ipt1.val();
						const id2 = $ipt2.val();
						const checkExisting = (a, b) => {
							const _check = (p, q) => ATTR_PROPS.some(prop => p.attributes[prop] && a.attributes[prop].includes(q.id));

							if (_check(a, b)) return `"${a.id}" is already entangled to "${b.id}"!`;
							if (_check(b, a)) return `"${b.id}" is already entangled to "${a.id}"!`;
							return false;
						};

						const entity1 = $selType1.val() === "0" ? d20plus.ut.getTokenById(id1) : d20plus.ut.getPathById(id1);
						const entity2 = $selType2.val() === "0" ? d20plus.ut.getTokenById(id2) : d20plus.ut.getPathById(id2);

						if (!entity1) return notFound(id1, $selType1.val() === "0" ? "image" : "path");
						if (!entity2) return notFound(id2, $selType2.val() === "0" ? "image" : "path");

						const existing = checkExisting(entity1, entity2);
						if (existing) return alert(existing);

						const prop1 = entity2.attributes.type === "image" ? "entangledImages" : "entangledPaths";
						const prop2 = entity1.attributes.type === "image" ? "entangledImages" : "entangledPaths";

						(entity1.attributes[prop1] = entity1.attributes[prop1] || []).push(id2);
						entity1.save();
						(entity2.attributes[prop2] = entity2.attributes[prop2] || []).push(id1);
						entity2.save();

						$win.data("VE_DO_ENTANGLE")(entity1);
						$win.data("VE_DO_ENTANGLE")(entity2);
						alert("Entangled!");
					});

				const $iptClear = $(`#token-clear-entangles`);

				const $selTypeClear = $(`#token-clear-type`);

				const $btnClear = $(`#token-entangle-clear`)
					.off("click")
					.click(() => {
						const id = $iptClear.val();
						const entity = $selTypeClear.val() === "0" ? d20plus.ut.getTokenById(id) : d20plus.ut.getPathById(id);
						if (!entity) return notFound(id, $selTypeClear.val() === "0" ? "image" : "path");

						const count = (entity.attributes.entangledImages ? entity.attributes.entangledImages.length : 0) + (entity.attributes.entangledPaths ? entity.attributes.entangledPaths.length : 0);

						(entity.attributes.entangledImages || []).forEach(eId => {
							const ent = d20plus.ut.getTokenById(eId);
							if (ent && ent.attributes.entangledImages && ent.attributes.entangledImages.includes(id)) {
								ent.attributes.entangledImages.splice(ent.attributes.entangledImages.indexOf(id), 1);
								ent.save();
							}
						});

						(entity.attributes.entangledPaths || []).forEach(eId => {
							const ent = d20plus.ut.getPathById(eId);
							if (ent && ent.attributes.entangledPaths && ent.attributes.entangledPaths.includes(id)) {
								ent.attributes.entangledPaths.splice(ent.attributes.entangledPaths.indexOf(id), 1);
								ent.save();
							}
						});

						entity.attributes.entangledImages = [];
						entity.attributes.entangledPaths = [];
						entity.save();
						alert(`${count} entangle${count === 1 ? "" : "s"} cleared.`);
					});
			},
		},
	];

	d20plus.tool.get = (toolId) => {
		return d20plus.tool.tools.find(it => it.toolId === toolId);
	};

	d20plus.tool.addTools = () => {
		const $body = $(`body`);
		const $tools = $(`#d20-tools-list`);
		const $toolsList = $tools.find(`.tools-list`);
		d20plus.tool.tools.sort((a, b) => SortUtil.ascSortLower(a.name || "", b.name || "")).forEach(t => {
			$body.append(t.html); // add HTML
			try {
				t.dialogFn(); // init window
				// add tool row
				const $wrp = $(`<div class="tool-row"/>`);
				$wrp.append(`<span style="width: 20%; padding: 4px;">${t.name}</span>`);
				$wrp.append(`<span style="width: calc(60% - 8px); padding: 4px;">${t.desc}</span>`);
				$(`<a style="width: 15%;" class="btn" href="#">Open</a>`).on(mousedowntype, () => {
					t.openFn.bind(t)();
					$tools.dialog("close");
				}).appendTo($wrp);
				$toolsList.append($wrp);
			} catch (e) {
				// eslint-disable-next-line no-console
				console.error(`Failed to initialise tool "${t.name}"`, e);
			}
		});

		$tools.dialog({
			autoOpen: false,
			resizable: true,
			width: 800,
			height: 660,
		});
		$(`#button-view-tools`).on(mousedowntype, () => {
			$tools.dialog("open");
		});
	};
}

SCRIPT_EXTENSIONS.push(baseTool);


function baseToolModule () {
	d20plus.tool.tools.push({
		toolId: "MODULES",
		name: "Module Importer/Exporter",
		desc: "Import full games (modules), or import/export custom games",
		html: `
				<div id="d20plus-module-importer" title="Better20 - Module Importer/Exporter">
				<p style="margin-bottom: 4px;"><b style="font-size: 110%;">Exporter: </b> <button class="btn" name="export">Export Game to File</button> <i>The exported file can later be used with the "Upload File" option, below.</i></p>
				<hr style="margin: 4px;">
				<p style="margin-bottom: 4px;">
					<b style="font-size: 110%;">Importer:</b>
					<button class="btn readme" style="float: right;">Help/README</button>
					<div style="clear: both;"></div>
				</p>
				<div style="border-bottom: 1px solid #ccc; margin-bottom: 3px; padding-bottom: 3px;">
					<button class="btn" name="load-Vetools">Load from 5etools</button>
					<button class="btn" name="load-dmsguild">Load from R20 Repo</button>
					<button class="btn" name="load-file">Upload File</button>
				</div>
				<div>
					<div name="data-loading-message"></div>
					<select name="data-type" disabled style="margin-bottom: 0;">
						<option value="characters">Characters</option>
						<option value="decks">Decks</option>
						<option value="handouts">Handouts</option>
						<option value="playlists">Jukebox Playlists</option>
						<option value="tracks">Jukebox Tracks</option>
						<option value="maps">Maps</option>
						<option value="rolltables">Rollable Tables</option>
					</select>
					<button class="btn" name="view-select-entries">View/Select Entries</button>
					<br>
					<button class="btn" name="select-all-entries">Select Everything</button>
					<div name="selection-summary" style="margin-top: 5px;"></div>
				</div>
				<hr>
				<p><button class="btn" style="float: right;" name="import">Import Selected</button></p>
				</div>

				<div id="d20plus-module-importer-list" title="Select Entries">
					<div id="module-importer-list">
						<input type="search" class="search" placeholder="Search..." disabled>
						<div class="list" style="transform: translateZ(0); max-height: 650px; overflow-y: auto; overflow-x: hidden; margin-bottom: 10px;">
						<i>Load a file to view the contents here</i>
						</div>
					</div>
					<div>
						<label class="ib"><input type="checkbox" class="select-all"> Select All</label>
						<button class="btn" style="float: right;" name="confirm-selection">Confirm Selection</button>
					</div>
				</div>

				<div id="d20plus-module-importer-progress" title="Import Progress">
					<h3 class="name"></h3>
					<span class="remaining"></span>
					<p>Errors: <span class="errors">0</span> <span class="error-names"></span></p>
					<p><button class="btn cancel">Cancel</button></p>
				</div>

				<div id="d20plus-module-importer-help" title="Readme">
					<p>First, either load a module from 5etools, or upload one from a file. Then, choose the category you wish to import, and "View/Select Entries." Once you've selected everything you wish to import from the module, hit "Import Selected." This ensures entries are imported in the correct order.</p>
					<p><b>Note:</b> The script-wide configurable "rest time" options affect how quickly each category of entries is imported (tables and decks use the "Handout" rest time).</p>
					<p><b>Note:</b> Configuration options (aside from "rest time" as detailed above) <i>do not</i> affect the module importer. It effectively "clones" the content as-exported from the original module, including any whisper/advantage/etc settings.</p>
				</div>

				<div id="d20plus-module-importer-5etools" title="Select Module">
					<div id="module-importer-list-5etools">
						<input type="search" class="search" placeholder="Search modules...">
						<div>
							<div style="display: inline-block; width: 13px; height: 1px;"></div>
							<div class="col-5 col">Name</div>
							<div class="col-1 col" style="text-align: center;">Version</div>
							<div class="col-2 col" style="text-align: center;">Last Modified</div>
							<div class="col-1 col" style="text-align: center;">Size</div>
							<div class="col-2 col" style="text-align: center;">Source</div>
						</div>
						<div class="list" style="transform: translateZ(0); max-height: 480px; overflow-y: auto; overflow-x: hidden; margin-bottom: 10px;">
						<i>Loading...</i>
						</div>
					</div>
					<p><button class="btn load">Load Module Data</button></p>
				</div>

				<div id="d20plus-module-importer-select-exports-p1" title="Select Categories to Export">
					<div>
						<label>Characters <input type="checkbox" class="float-right" name="cb-characters"></label>
						<label>Decks <input type="checkbox" class="float-right" name="cb-decks"></label>
						<label>Handouts <input type="checkbox" class="float-right" name="cb-handouts"></label>
						<label>Jukebox Playlists <input type="checkbox" class="float-right" name="cb-playlists"></label>
						<label>Jukebox Tracks <input type="checkbox" class="float-right" name="cb-tracks"></label>
						<label>Maps <input type="checkbox" class="float-right" name="cb-maps"></label>
						<label>Rollable Tables <input type="checkbox" class="float-right" name="cb-rolltables"></label>
					</div>
					<div class="clear" style="width: 100%; border-bottom: #ccc solid 1px;"></div>
					<p style="margin-top: 5px;"><label>Select All <input type="checkbox" class="float-right" name="cb-all"></label></p>
					<p><button class="btn">Export</button></p>
				</div>
				`,
		dialogFn: () => {
			$("#d20plus-module-importer").dialog({
				autoOpen: false,
				resizable: true,
				width: 750,
				height: 360,
			});
			$(`#d20plus-module-importer-progress`).dialog({
				autoOpen: false,
				resizable: false,
			});
			$("#d20plus-module-importer-5etools").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});
			$("#d20plus-module-importer-help").dialog({
				autoOpen: false,
				resizable: true,
				width: 600,
				height: 400,
			});
			$("#d20plus-module-importer-select-exports-p1").dialog({
				autoOpen: false,
				resizable: true,
				width: 400,
				height: 275,
			});
			$("#d20plus-module-importer-list").dialog({
				autoOpen: false,
				resizable: true,
				width: 600,
				height: 800,
			});
		},
		openFn: () => {
			const DISPLAY_NAMES = {
				maps: "Maps",
				rolltables: "Rollable Tables",
				decks: "Decks",
				handouts: "Handouts",
				playlists: "Jukebox Playlists",
				tracks: "Jukebox Tracks",
				characters: "Characters",
			};

			const $win = $("#d20plus-module-importer");
			$win.dialog("open");

			const $winProgress = $(`#d20plus-module-importer-progress`);
			const $btnCancel = $winProgress.find(".cancel").off("click");

			const $win5etools = $(`#d20plus-module-importer-5etools`);

			const $winHelp = $(`#d20plus-module-importer-help`);
			const $btnHelp = $win.find(`.readme`).off("click").click(() => $winHelp.dialog("open"));

			const $winList = $(`#d20plus-module-importer-list`);
			const $wrpLst = $(`#module-importer-list`);
			const $lst = $winList.find(`.list`).empty();
			const $cbAll = $winList.find(`.select-all`).off("click").prop("disabled", true);
			const $iptSearch = $winList.find(`.search`).prop("disabled", true);
			const $btnConfirmSel = $winList.find(`[name="confirm-selection"]`).off("click");

			const $wrpSummary = $win.find(`[name="selection-summary"]`);
			const $wrpDataLoadingMessage = $win.find(`[name="data-loading-message"]`);

			const $btnImport = $win.find(`[name="import"]`).off("click").prop("disabled", true);
			const $btnViewCat = $win.find(`[name="view-select-entries"]`).off("click").prop("disabled", true);
			const $btnSelAllContent = $win.find(`[name="select-all-entries"]`).off("click").prop("disabled", true);

			const $selDataType = $win.find(`[name="data-type"]`).prop("disabled", true);
			let lastDataType = $selDataType.val();
			let genericFolder;
			let lastLoadedData = null;

			const getFreshSelected = () => ({
				characters: [],
				decks: [],
				handouts: [],
				maps: [],
				playlists: [],
				tracks: [],
				rolltables: [],
			});

			let selected = getFreshSelected();

			function handleLoadedData (data) {
				lastLoadedData = data;
				selected = getFreshSelected();
				$selDataType.prop("disabled", false);

				function updateSummary () {
					$wrpSummary.text(Object.entries(selected).filter(([prop, ents]) => ents && ents.length).map(([prop, ents]) => `${DISPLAY_NAMES[prop]}: ${ents.length} selected`).join("; "));
				}

				$btnViewCat.prop("disabled", false);
				$btnViewCat.off("click").click(() => {
					$winList.dialog("open");
					$iptSearch.prop("disabled", false);

					let prop = "";
					switch (lastDataType) {
						case "rolltables":
						case "decks":
						case "playlists":
						case "tracks":
						case "maps": {
							prop = lastDataType;
							break;
						}
						case "handouts": {
							prop = "handouts";
							genericFolder = d20plus.journal.makeDirTree(`Handouts`);
							break;
						}
						case "characters": {
							prop = "characters";
							genericFolder = d20plus.journal.makeDirTree(`Characters`);
							break;
						}
						default: throw new Error(`Unhandled data type: ${lastDataType}`);
					}

					const moduleData = data[prop] || [];
					moduleData.sort((a, b) => SortUtil.ascSortLower(
						(a.attributes && a.attributes.name) || a.name || a.title || "",
						(b.attributes && a.attributes.name) || a.name || b.title || "",
					));

					$lst.empty();
					moduleData.forEach((m, i) => {
						const img = lastDataType === "maps" ? m.attributes.thumbnail
							: (lastDataType === "characters" || lastDataType === "handouts" || lastDataType === "decks") ? m.attributes.avatar : "";

						$lst.append(`
									<label class="import-cb-label ${img ? `import-cb-label--img` : ""}" data-listid="${i}">
										<input type="checkbox">
										${img && img.trim() ? `<img class="import-label__img" src="${img}">` : ""}
										<span class="name col-9 readable">${(m.attributes && m.attributes.name) || m.name || m.title || ""}</span>
									</label>
								`);
					});

					const entryList = new List("module-importer-list", {
						valueNames: ["name"],
					});

					$cbAll.prop("disabled", false).off("click").click(() => {
						entryList.items.forEach(it => {
							$(it.elm).find(`input[type="checkbox"]`).prop("checked", $cbAll.prop("checked"));
						});
					});

					$btnConfirmSel.off("click").click(() => {
						const sel = entryList.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => moduleData[$(it.elm).attr("data-listid")]);

						$cbAll.prop("checked", false);
						$winList.dialog("close");
						selected[prop] = sel;
						updateSummary();
					});
				});

				$btnSelAllContent.prop("disabled", false);
				$btnSelAllContent.off("click").click(() => {
					Object.keys(selected).forEach(k => {
						selected[k] = data[k];
						updateSummary();
					});
				});

				$btnImport.prop("disabled", false).off("click").click(() => {
					const totalSelected = Object.values(selected).map(it => it ? it.length : 0).reduce((a, b) => a + b, 0);
					if (!totalSelected) return alert("No entries selected!");

					const $name = $winProgress.find(`.name`);
					const $remain = $winProgress.find(`.remaining`).text(`${totalSelected} remaining...`);
					const $errCount = $winProgress.find(`.errors`);
					const $errReasons = $winProgress.find(`.error-names`);
					let errCount = 0;

					$winProgress.dialog("open");

					const journal = data.journal ? MiscUtil.copy(data.journal).reverse() : null;

					let queue = [];
					let jukebox = {};
					Object.entries(selected).filter(([k, v]) => v && v.length).forEach(([prop, ents]) => {
						if (prop === "playlists") return jukebox.playlists = (jukebox.playlists || []).concat(ents);
						else if (prop === "tracks") return jukebox.tracks = (jukebox.tracks || []).concat(ents);

						ents = MiscUtil.copy(ents);

						// if importing journal items, make sure they get put back in the right order
						if (journal && (prop === "characters" || prop === "handouts")) {
							const nuQueue = [];

							journal.forEach(jIt => {
								const qIx = ents.findIndex(qIt => qIt.attributes.id === jIt.id);
								if (~qIx) nuQueue.push(ents.splice(qIx, 1)[0]);
							});
							ents.forEach(qIt => nuQueue.push(qIt)); // add anything that wasn't in the journal to the end of the queue
							ents = nuQueue;
						}

						const toAdd = ents.map(entry => ({entry, prop}));
						// do maps first
						if (prop === "maps") queue = toAdd.concat(queue);
						else queue = queue.concat(toAdd);
					});

					// reset the tool
					selected = getFreshSelected();
					$wrpSummary.text("");

					let isCancelled = false;
					let lastTimeout = null;
					$btnCancel.off("click").click(() => {
						isCancelled = true;
						if (lastTimeout != null) {
							clearTimeout(lastTimeout);
							doImport();
						}
					});
					const mapTimeout = d20plus.cfg.get("import", "importIntervalMap") || d20plus.cfg.getDefault("import", "importIntervalMap");
					const charTimeout = d20plus.cfg.get("import", "importIntervalCharacter") || d20plus.cfg.getDefault("import", "importIntervalCharacter");
					const handoutTimeout = d20plus.cfg.get("import", "importIntervalHandout") || d20plus.cfg.getDefault("import", "importIntervalHandout");
					const timeouts = {
						characters: charTimeout,
						decks: handoutTimeout,
						handouts: handoutTimeout,
						playlists: 0,
						tracks: 0,
						maps: mapTimeout,
						rolltables: handoutTimeout,
					};

					const addToJournal = (originalId, itId) => {
						let handled = false;
						if (journal) {
							const found = journal.find(it => it.id === originalId);
							if (found) {
								const rawPath = found.path;
								const cleanPath = rawPath.slice(1); // paths start with "Root"
								const folder = d20plus.journal.makeDirTree(...cleanPath);
								d20.journal.addItemToFolderStructure(itId, folder.id);
								handled = true;
							}
						}

						if (!handled) d20.journal.addItemToFolderStructure(itId, genericFolder.id);
					};

					const doImport = () => {
						if (isCancelled) {
							$name.text("Import cancelled.");
							$remain.text(`Cancelled with ${queue.length} remaining.`);
						} else if (queue.length && !isCancelled) {
							$remain.text(`${queue.length} remaining...`);
							const {entry, prop} = queue.shift();
							const timeout = timeouts[prop];
							const name = entry.attributes.name;
							try {
								$name.text(`Importing ${name}`);

								switch (prop) {
									case "maps": {
										const map = d20.Campaign.pages.create(entry.attributes);
										entry.graphics.forEach(it => map.thegraphics.create(it));
										entry.paths.forEach(it => map.thepaths.create(it));
										entry.text.forEach(it => map.thetexts.create(it));
										map.save();
										break;
									}
									case "rolltables": {
										const table = d20.Campaign.rollabletables.create(entry.attributes);
										table.tableitems.reset();
										const toSave = entry.tableitems.map(it => table.tableitems.push(it));
										toSave.forEach(s => s.save());
										table.save();
										break;
									}
									case "decks": {
										const deck = d20.Campaign.decks.create(entry.attributes);
										deck.cards.reset();
										const toSave = entry.cards.map(it => deck.cards.push(it));
										toSave.forEach(s => s.save());
										deck.save();
										break;
									}
									case "handouts": {
										d20.Campaign.handouts.create(entry.attributes,
											{
												success: function (handout) {
													handout.updateBlobs({
														notes: entry.blobNotes,
														gmnotes: entry.blobGmNotes,
													});

													addToJournal(entry.attributes.id, handout.id);
												},
											},
										);
										break;
									}
									case "characters": {
										d20.Campaign.characters.create(entry.attributes,
											{
												success: function (character) {
													character.attribs.reset();
													const toSave = entry.attribs.map(a => character.attribs.push(a));
													toSave.forEach(s => s.syncedSave());

													character.abilities.reset();
													if (entry.abilities) entry.abilities.map(a => character.abilities.push(a)).forEach(s => s.save());

													character.updateBlobs({
														bio: entry.blobBio,
														gmnotes: entry.blobGmNotes,
														defaulttoken: entry.blobDefaultToken,
													});

													addToJournal(entry.attributes.id, character.id);
												},
											},
										);
										break;
									}
									default: throw new Error(`Unhandled data type: ${prop}`);
								}
							} catch (e) {
								// eslint-disable-next-line no-console
								console.error(e);

								errCount++;
								$errCount.text(errCount);
								const prevReasons = $errReasons.text().trim();
								$errReasons.append(`${prevReasons.length ? ", " : ""}${name}: "${e.message}"`)
							}

							// queue up the next import
							lastTimeout = setTimeout(doImport, timeout);
						} else {
							$name.text("Import complete!");
							$remain.text(`${queue.length} remaining.`);
						}
					};

					if (Object.keys(jukebox).length) d20plus.jukebox.importWrappedData(jukebox);
					doImport();
				});
			}

			$selDataType.off("change").on("change", () => {
				lastDataType = $selDataType.val();
			});

			const $btnLoadVetools = $win.find(`[name="load-Vetools"]`);
			$btnLoadVetools.off("click").click(() => {
				$win5etools.dialog("open");
				const $btnLoad = $win5etools.find(`.load`).off("click");

				DataUtil.loadJSON(`${DATA_URL_MODULES}/roll20-module-index.json`).then(data => {
					const $lst = $win5etools.find(`.list`);
					const modules = data.map.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));
					let tmp = "";
					modules.forEach((t, i) => {
						tmp += `
								<label class="import-cb-label" data-listid="${i}">
									<input type="radio" name="map-5etools">
									<span class="name col-5 readable">${t.name}</span>
									<span class="version col-1 readable" style="text-align: center;">${t.version || ""}</span>
									<span class="lat-modified col-2 readable" style="text-align: center;">${t.dateLastModified ? DatetimeUtil.getDateStr(new Date(t.dateLastModified * 1000), true) : ""}</span>
									<span class="size col-1 readable" style="text-align: right;">${d20plus.ut.getReadableFileSizeString(t.size)}</span>
									<span title="${Parser.sourceJsonToFull(t.id)}" class="source readable" style="text-align: right;">SRC[${Parser.sourceJsonToAbv(t.id)}]</span>
								</label>
							`;
					});
					$lst.html(tmp);
					tmp = null;

					const list5etools = new List("module-importer-list-5etools", {
						valueNames: ["name"],
					});

					$btnLoad.on("click", () => {
						const sel = list5etools.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => modules[$(it.elm).attr("data-listid")])[0];

						$win5etools.dialog("close");
						$win.dialog("open");
						$wrpDataLoadingMessage.html("<i>Loading...</i>");
						DataUtil.loadJSON(`${DATA_URL_MODULES}/roll20-module-${sel.id.toLowerCase()}.json`)
							.then(moduleFile => {
								$wrpDataLoadingMessage.html("");
								return handleLoadedData(moduleFile);
							})
							.catch(e => {
								$wrpDataLoadingMessage.html("");
								// eslint-disable-next-line no-console
								console.error(e);
								alert(`Failed to load data! See the console for more information.`);
							});
					});
				}).catch(e => {
					// eslint-disable-next-line no-console
					console.error(e);
					alert(`Failed to load data! See the console for more information.`);
				});
			});

			// For content loaded from the R20 repo
			const $btnLoadDmsguild = $win.find(`[name="load-dmsguild"]`);
			$btnLoadDmsguild.off("click").click(() => {
				$win5etools.dialog("open");
				const $btnLoad = $win5etools.find(`.load`).off("click");
				// url for the repo
				const urlbase = "https://raw.githubusercontent.com/DMsGuild201/Roll20_resources/master/Module/";

				DataUtil.loadJSON(`${urlbase}index.json`).then(data => {
					const $lst = $win5etools.find(`.list`);
					const modules = data.map.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));
					let tmp = "";
					// Display each module in the selector
					modules.forEach((t, i) => {
						tmp += `
								<label class="import-cb-label" data-listid="${i}">
									<input type="radio" name="map-5etools">
									<span class="name col-5 readable">${t.name}</span>
									<span class="version col-1 readable" style="text-align: center;">${t.version || ""}</span>
									<span class="lat-modified col-2 readable" style="text-align: center;">${t.dateLastModified ? DatetimeUtil.getDateStr(new Date(t.dateLastModified * 1000), true) : ""}</span>
									<span class="size col-1 readable" style="text-align: right;">${t.size ? d20plus.ut.getReadableFileSizeString(t.size) : ""}</span>
									<span title="${Parser.sourceJsonToFull(t.id)}" class="source readable" style="text-align: right;">SRC[${Parser.sourceJsonToAbv(t.id)}]</span>
								</label>
							`;
					});
					$lst.html(tmp);
					tmp = null;

					const list5etools = new List("module-importer-list-5etools", {
						valueNames: ["name"],
					});

					$btnLoad.on("click", () => {
						const sel = list5etools.items
							.filter(it => $(it.elm).find(`input`).prop("checked"))
							.map(it => modules[$(it.elm).attr("data-listid")])[0];

						$win5etools.dialog("close");
						$win.dialog("open");
						$wrpDataLoadingMessage.html("<i>Loading...</i>");
						// Load the chosen module
						DataUtil.loadJSON(`${urlbase}${sel.filename}`)
							.then(moduleFile => {
								$wrpDataLoadingMessage.html("");
								return handleLoadedData(moduleFile);
							})
							.catch(e => {
								$wrpDataLoadingMessage.html("");
								// eslint-disable-next-line no-console
								console.error(e);
								alert(`Failed to load data! See the console for more information.`);
							});
					});
				}).catch(e => {
					// eslint-disable-next-line no-console
					console.error(e);
					alert(`Failed to load data! See the console for more information.`);
				});
			});

			// Load from file
			const $btnLoadFile = $win.find(`[name="load-file"]`);
			$btnLoadFile.off("click").click(async () => {
				const data = await DataUtil.pUserUpload();
				// Due to the new util functon, need to account for data being an array
				data.jsons.forEach(d => handleLoadedData(d));
			});

			const $winExportP1 = $("#d20plus-module-importer-select-exports-p1");
			const $cbAllExport = $winExportP1.find(`[name="cb-all"]`);

			const $btnExport = $win.find(`[name="export"]`);
			$btnExport.off("click").click(() => {
				const CATS = [
					"characters",
					"decks",
					"handouts",
					"playlists",
					"tracks",
					"maps",
					"rolltables",
				];

				$winExportP1.dialog("open");

				$cbAllExport.off("change").on("change", () => {
					CATS.forEach(cat => $winExportP1.find(`input[name="cb-${cat}"]`).prop("checked", $cbAllExport.prop("checked")))
				});

				$winExportP1.find("button").off("click").click(async () => {
					const isCatSelected = (name) => $winExportP1.find(`input[name="cb-${name}"]`).prop("checked");

					const catsToExport = new Set(CATS.filter(it => isCatSelected(it)));

					// eslint-disable-next-line no-console
					console.log("Exporting journal...");
					const journal = d20plus.journal.getExportableJournal();

					let maps;
					if (catsToExport.has("maps")) {
						// eslint-disable-next-line no-console
						console.log("Exporting maps..."); // shoutouts to Stormy
						maps = await Promise.all(d20.Campaign.pages.models.map(async map => {
							const getOut = () => {
								return {
									attributes: map.attributes,
									graphics: (map.thegraphics || []).map(g => g.attributes),
									text: (map.thetexts || []).map(t => t.attributes),
									paths: (map.thepaths || []).map(p => p.attributes),
								};
							};

							if (map.get("archived")) {
								map.set({archived: false});
								await d20plus.ut.promiseDelay(d20plus.cfg.getOrDefault("import", "importIntervalHandout") * 2);
								const out = getOut();
								map.set({archived: true});
								return out;
							} else {
								return getOut();
							}
						}));
					}

					let rolltables;
					if (catsToExport.has("rolltables")) {
						// eslint-disable-next-line no-console
						console.log("Exporting rolltables...");
						rolltables = d20.Campaign.rollabletables.models.map(rolltable => ({
							attributes: rolltable.attributes,
							tableitems: (rolltable.tableitems.models || []).map(tableitem => tableitem.attributes),
						}));
					}

					let decks;
					if (catsToExport.has("decks")) {
						// eslint-disable-next-line no-console
						console.log("Exporting decks...");
						decks = d20.Campaign.decks.models.map(deck => {
							if (deck.name && deck.name.toLowerCase() === "playing cards") return;
							return {
								attributes: deck.attributes,
								cards: (deck.cards.models || []).map(card => card.attributes),
							};
						}).filter(it => it);
					}

					let playlists;
					if (catsToExport.has("playlists")) {
						// eslint-disable-next-line no-console
						console.log("Exporting jukebox playlists...");
						playlists = d20plus.jukebox.getExportablePlaylists();
					}

					let tracks;
					if (catsToExport.has("tracks")) {
						// eslint-disable-next-line no-console
						console.log("Exporting jukebox tracks...");
						tracks = d20plus.jukebox.getExportableTracks();
					}

					let blobCount = 0;
					let onBlobsReady = null;
					let anyBlobs = false;

					const handleBlob = (addTo, asKey, data) => {
						addTo[asKey] = data;
						blobCount--;
						if (onBlobsReady && blobCount === 0) onBlobsReady();
					};

					let characters;
					if (catsToExport.has("characters")) {
						anyBlobs = true;
						// eslint-disable-next-line no-console
						console.log("Exporting characters...");
						characters = d20.Campaign.characters.models.map(character => {
							const out = {
								attributes: character.attributes,
								attribs: character.attribs,
							};
							const abilities = (character.abilities || {models: []}).models.map(ability => ability.attributes);
							if (abilities && abilities.length) out.abilities = abilities;
							blobCount += 3;
							character._getLatestBlob("bio", (data) => handleBlob(out, "blobBio", data));
							character._getLatestBlob("gmnotes", (data) => handleBlob(out, "blobGmNotes", data));
							character._getLatestBlob("defaulttoken", (data) => handleBlob(out, "blobDefaultToken", data));
							return out;
						});
					}

					let handouts;
					if (catsToExport.has("handouts")) {
						anyBlobs = true;
						// eslint-disable-next-line no-console
						console.log("Exporting handouts...");
						handouts = d20.Campaign.handouts.models.map(handout => {
							if (handout.attributes.name === ART_HANDOUT || handout.attributes.name === CONFIG_HANDOUT) return;

							const out = {
								attributes: handout.attributes,
							};
							blobCount += 2;
							handout._getLatestBlob("notes", (data) => handleBlob(out, "blobNotes", data));
							handout._getLatestBlob("gmnotes", (data) => handleBlob(out, "blobGmNotes", data));
							return out;
						}).filter(it => it);
					}

					// eslint-disable-next-line no-console
					if (anyBlobs) console.log("Waiting for blobs...");
					onBlobsReady = () => {
						// eslint-disable-next-line no-console
						if (anyBlobs) console.log("Blobs are ready!");

						// eslint-disable-next-line no-console
						console.log("Preparing payload");

						const payload = {
							schema_version: 1, // version number from r20es
						};
						if (maps) payload.maps = maps;
						if (rolltables) payload.rolltables = rolltables;
						if (decks) payload.decks = decks;
						if (journal) payload.journal = journal;
						if (handouts) payload.handouts = handouts;
						if (characters) payload.characters = characters;
						if (playlists) payload.playlists = playlists;
						if (tracks) payload.tracks = tracks;

						const filename = document.title.replace(/\|\s*Roll20$/i, "").trim().replace(/[^-\w]/g, "_");
						const data = JSON.stringify(payload, null, "\t");

						// eslint-disable-next-line no-console
						console.log("Saving");
						const blob = new Blob([data], {type: "application/json"});
						d20plus.ut.saveAs(blob, `${filename}.json`);
					};
					if (!anyBlobs || blobCount === 0) onBlobsReady();
				});

				// TODO
				/*
				macro
				 */
			});
		},
	})
}

SCRIPT_EXTENSIONS.push(baseToolModule);


function baseToolUnlock () {
	d20plus.tool.tools.push({
		toolId: "UNLOCKER",
		name: "Token Unlocker",
		desc: "Unlock previously-locked tokens",
		html: `
			<div id="d20plus-token-unlocker" title="Better20 - Token Unlocker">
				<p>
					<button class="btn" name="btn-refresh">Refresh</button>
				</p>
				<p class="split">
					<label><input type="checkbox" title="Select all" name="cb-all"> Select All</label> 
					<button class="btn" name="btn-unlock">Unlock Selected</button>
				</p>
				<div id="token-unlocker-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list unlock-list" style="max-height: 420px; overflow-y: scroll; display: block; margin: 0;"></ul>
				</div>
			</div>
		`,
		dialogFn: () => {
			const $win = $("#d20plus-token-unlocker").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			}).data("VE_HANDLE_UPDATE", () => {
				d20.engine.canvas._objects.forEach(ob => {
					if (ob.model) {
						const locked = ob.model.get("VeLocked");
						if (locked) {
							ob.lockMovementX = true;
							ob.lockMovementY = true;
							ob.lockScalingX = true;
							ob.lockScalingY = true;
							ob.lockRotation = true;
							ob.saveState();
						}
					}
				});
			});

			document.addEventListener("VePageChange", () => {
				$win.data("VE_HANDLE_UPDATE")();
			});

			document.addEventListener("VeLayerChange", () => {
				$win.data("VE_HANDLE_UPDATE")();
			});

			try {
				$win.data("VE_HANDLE_UPDATE")();
			} catch (e) {
				d20plus.ut.error("Failed to re-lock tokens!")
			}
		},
		openFn: () => {
			const $win = $("#d20plus-token-unlocker");
			$win.dialog("open");
			const $wrpCbs = $(`#token-unlocker-list-container`).find(`.unlock-list`);
			const $cbAll = $win.find(`[name="cb-all"]`);
			const $btnUnlock = $win.find(`[name="btn-unlock"]`);
			const $btnRefresh = $win.find(`[name="btn-refresh"]`).click(() => populateList());

			function populateList () {
				const objects = d20.engine.canvas._objects.filter(it => it.model && it.model.get("VeLocked"));
				$wrpCbs.empty();

				objects.forEach(it => {
					$wrpCbs.append(`
						<label class="import-cb-label" data-listid="${it.model.get("id")}">
							<input type="checkbox">
							<span class="name readable">${it.model.get("name") || `Unnamed${it.type ? ` ${it.type}` : ""}`}</span>
						</label>
					`);
				});

				// init list library
				const unlockList = new List("token-unlocker-list-container", {
					valueNames: ["name"],
					listClass: "unlock-list",
				});

				$cbAll.prop("checked", false);
				$cbAll.off("click").click(() => d20plus.importer._importToggleSelectAll(unlockList, $cbAll));

				$btnUnlock.off("click").on("click", () => {
					const sel = unlockList.items
						.filter(it => $(it.elm).find(`input`).prop("checked"))
						.map(it => $(it.elm).attr("data-listid"));

					if (!sel.length) {
						alert("No items selected!");
					} else {
						const currObjects = d20.engine.canvas._objects.filter(it => it.model);
						let counter = 0;
						sel.forEach(toUnlock => {
							const ob = currObjects.find(it => it.model && it.model.get("id") === toUnlock);
							if (ob) {
								counter++;
								ob.lockMovementX = false;
								ob.lockMovementY = false;
								ob.lockScalingX = false;
								ob.lockScalingY = false;
								ob.lockRotation = false;
								ob.saveState();

								ob.model.set("VeLocked", false);
								ob.model.save();
							}
						});
						alert(`${counter} item${counter === 1 ? "" : "s"} unlocked.`);
						populateList();
					}
				});
			}

			populateList();
		},
	})
}

SCRIPT_EXTENSIONS.push(baseToolUnlock);


function baseToolAnimator () {
	function cleanNulls (obj) {
		Object.entries(obj).filter(([k, v]) => v == null).forEach(([k]) => delete obj[k]);
		return obj;
	}

	d20plus.anim = {
		lineFromParsed (parsed) {
			const stack = [];
			const add = (...parts) => parts.forEach(p => stack.push(p == null ? "-" : p));

			stack.push(d20plus.anim.COMMAND_TO_SHORT[parsed._type]);
			stack.push(parsed.start || 0);

			switch (parsed._type) {
				case "Move":
				case "MoveExact": {
					stack.push(parsed.duration || 0);
					add(parsed.x, parsed.y, parsed.z);
					break;
				}
				case "Rotate":
				case "RotateExact": {
					stack.push(parsed.duration || 0);
					add(parsed.degrees);
					break;
				}
				case "Copy": {
					add(parsed.animation);
					break;
				}
				case "Flip":
				case "FlipExact": {
					add(parsed.flipH, parsed.flipV);
					break;
				}
				case "Scale":
				case "ScaleExact": {
					stack.push(parsed.duration || 0);
					add(parsed.scaleX, parsed.scaleY);
					break;
				}
				case "Layer": {
					add(parsed.layer);
					break;
				}
				case "Lighting":
				case "LightingExact": {
					stack.push(parsed.duration || 0);
					add(parsed.lightRadius, parsed.dimStart, parsed.degrees);
					break;
				}
				case "SetProperty":
				case "SumProperty": {
					add(parsed.prop, parsed.value);
					break;
				}
				case "TriggerMacro": {
					add(parsed.macro);
					break;
				}
				case "TriggerAnimation": {
					add(parsed.animation);
					break;
				}
				default: throw new Error(`Unhandled type "${parsed._type}"`);
			}

			return stack.join(" ");
		},

		deserialize: function (json) {
			let out;
			switch (json._type) {
				case "Nop": out = new d20plus.anim.Nop(); break;
				case "Move": out = new d20plus.anim.Move(json.startTime, json.duration, json.x, json.y, json.z); break;
				case "MoveExact": out = new d20plus.anim.MoveExact(json.startTime, json.duration, json.x, json.y, json.z); break;
				case "Copy": out = new d20plus.anim.Copy(json.startTime, json.childAnimation); break;
				case "Rotate": out = new d20plus.anim.Rotate(json.startTime, json.duration, json.degrees); break;
				case "RotateExact": out = new d20plus.anim.RotateExact(json.startTime, json.duration, json.degrees); break;
				case "Flip": out = new d20plus.anim.Flip(json.startTime, json.isHorizontal, json.isVertical); break;
				case "FlipExact": out = new d20plus.anim.FlipExact(json.startTime, json.isHorizontal, json.isVertical); break;
				case "Scale": out = new d20plus.anim.Scale(json.startTime, json.duration, json.scaleFactorX, json.scaleFactorY); break;
				case "ScaleExact": out = new d20plus.anim.ScaleExact(json.startTime, json.duration, json.scaleFactorX, json.scaleFactorY); break;
				case "Layer": out = new d20plus.anim.Layer(json.startTime, json.layer); break;
				case "SetProperty": out = new d20plus.anim.SetProperty(json.startTime, json.prop, json.value); break;
				case "SumProperty": out = new d20plus.anim.SumProperty(json.startTime, json.prop, json.value); break;
				case "Lighting": out = new d20plus.anim.Lighting(json.startTime, json.duration, json.lightRadius, json.dimStart, json.degrees); break;
				case "LightingExact": out = new d20plus.anim.LightingExact(json.startTime, json.duration, json.lightRadius, json.dimStart, json.degrees); break;
				case "TriggerMacro": out = new d20plus.anim.TriggerMacro(json.startTime, json.macroName); break;
				case "TriggerAnimation": out = new d20plus.anim.TriggerAnimation(json.startTime, json.animation); break;
				default: throw new Error(`Unhandled type "${json._type}"`);
			}
			out._hasRun = json._hasRun;
			out._offset = json._offset;
			out._progress = json._progress;
			out._snapshotDiff = json._snapshotDiff;
			return out;
		},

		// region animations
		// Each has `animate` which accepts up to four parameters:
		//   token: the token object being animated
		//   alpha: the absolute time since the start of the animation's life
		//   delta: the time delta from the last time the `animate` function was run
		//   queue: the queue this animation is part of
		// The `animate` function returns `true` if the token needs to be saved, `false` otherwise
		// Each should also have:
		//   `serialize` function
		//   `hasRun` function; returns `true` if the animation has been run, and can therefore be safely removed from any queues
		//   `setOffset` function; sets a start time offset for the animation. Used when triggering child animations
		_Base: function () {
			this._hasRun = false;
			this._offset = 0;
			this._progress = 0; // 0 - 1f
			this._snapshotDiff = null;

			this.hasRun = () => this._hasRun;
			this.setOffset = offset => this._offset = offset;
			this.isLastTick = () => !(this._progress < (1 - Number.EPSILON));
			this._serialize = () => {
				// remove any undefined properties
				const rawOut = {
					_type: this.constructor.name,
					_hasRun: this._hasRun,
					_offset: this._offset,
					_progress: this._progress,
					_snapshotDiff: this._snapshotDiff,
				};
				const out = {};
				Object.entries(rawOut).forEach(([k, v]) => {
					if (v != null) out[k] = v;
				});
				return out;
			};

			this._getTickProgress = (duration, delta) => {
				let mProgress = duration === 0 ? 1 : Math.min(1, delta / duration);
				// prevent progress from going past 100%
				if (this._progress + mProgress > 1) mProgress = 1 - this._progress;
				return mProgress;
			};
		},

		Nop: function () {
			d20plus.anim._Base.call(this);

			this.animate = function () {
				return false;
			};

			this.hasRun = () => true;
			this.serialize = () => {};
		},

		_BaseMove: function (startTime, duration, x, y, z) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					x,
					y,
					z,
				})
			};

			this._getCurrentZ = (token) => {
				const statuses = (token.attributes.statusmarkers || "").split(",");
				let total = 0;
				let pow = 1;
				let stack = "";

				// reverse loop through the fluffy wings, multiplying vals by 1/10/100...
				const len = statuses.length;
				for (let i = len - 1; i >= 0; --i) {
					const [name, val] = statuses[i].split("@");
					if (name === "fluffy-wing") {
						total += pow * Number(val);
						pow = pow * 10;
					} else {
						stack += `${statuses[i]},`;
					}
				}

				return {total, stack};
			};

			this._setCurrentZ = (token, stack, total) => {
				if (total) {
					const nums = String(Math.round(total)).split("");
					for (let i = 0; i < nums.length; ++i) {
						stack += `fluffy-wing@${nums[i]}${i < nums.length - 1 ? "," : ""}`;
					}
				} else stack = stack.replace(/,$/, "");

				token.attributes.statusmarkers = stack;
			};
		},

		Move: function (startTime, duration, x, y, z) {
			d20plus.anim._BaseMove.call(this, startTime, duration, x, y, z);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle movement
						if (x != null) token.attributes.left += mProgress * x;
						if (y != null) token.attributes.top -= mProgress * y;
						if (z != null) {
							let {total, stack} = this._getCurrentZ(token);
							total += mProgress * z;
							this._setCurrentZ(token, stack, total);
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		MoveExact: function (startTime, duration, x, y, z) {
			d20plus.anim._BaseMove.call(this, startTime, duration, x, y, z);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						const {total} = this._getCurrentZ(token);
						this._snapshotDiff = {
							x: (x || 0) - (token.attributes.left || 0),
							y: (y || 0) - (token.attributes.top || 0),
							z: (z || 0) - (total),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle movement
						if (x != null) token.attributes.left += mProgress * this._snapshotDiff.x;
						if (y != null) token.attributes.top -= mProgress * this._snapshotDiff.y;
						if (z != null) {
							let {total, stack} = this._getCurrentZ(token);
							total += mProgress * this._snapshotDiff.z;
							this._setCurrentZ(token, stack, total);
						}

						// update progress
						this._progress += mProgress;

						// on the last tick, update to precise values
						if (this.isLastTick()) {
							if (x != null) token.attributes.left = x;
							if (y != null) token.attributes.top = -y;
							if (z != null) {
								let {stack} = this._getCurrentZ(token);
								this._setCurrentZ(token, stack, z);
							}
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		Copy: function (startTime, childAnimation = false) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha, delta, queue) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					// based on "d20.clipboard.doCopy"
					const graphic = token.view.graphic;
					const attrs = {
						...MiscUtil.copy(graphic),
					};

					const modelattrs = {};
					const json = token.toJSON();
					d20.token_editor.tokenkeys.forEach(k => modelattrs[k] = json[k]);

					const cpy = {
						type: token.attributes.type,
						attrs,
						modelattrs,
						oldid: token.id,
						groupwith: "",
					};

					// based on "d20.clipboard.doPaste"
					let childToken;
					const page = d20.Campaign.pages.models.find(model => model.thegraphics.models.find(it => it.id === token.id));
					if (cpy.type === "image") {
						attrs.imgsrc = attrs.src;
						childToken = page.addImage(attrs, true, false, false, false, true);
						if (cpy.modelattrs && cpy.modelattrs.represents) {
							const char = d20.Campaign.characters.get(cpy.modelattrs.represents);

							if (char) {
								const updateBarN = (n) => {
									const prop = `bar${n}_link`;
									if (cpy.modelattrs[prop] !== "" && (cpy.modelattrs[prop].indexOf("sheetattr_") !== -1)) {
										const l = cpy.modelattrs[prop].split("sheetattr_")[1];
										setTimeout(() => char.updateTokensByName(l), 0.5);
									} else {
										const s = char.attribs.get(cpy.modelattrs[prop]);
										const l = s.get("name");
										setTimeout(() => char.updateTokensByName(l, cpy.modelattrs[prop]), 0.5);
									}
								};
								updateBarN(1);
								updateBarN(2);
								updateBarN(3);
							}
						}

						childToken && childToken.save(cpy.modelattrs);
					}

					if (childToken && childAnimation) {
						const nxt = new d20plus.anim.TriggerAnimation(startTime, childAnimation);
						nxt.animate(childToken, alpha, delta, queue);
					}
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					childAnimation,
				})
			};
		},

		_BaseRotate: function (startTime, duration, degrees) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					degrees,
				})
			};
		},

		Rotate: function (startTime, duration, degrees) {
			d20plus.anim._BaseRotate.call(this, startTime, duration, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle rotation
						if (degrees != null) {
							const rot = mProgress * degrees;
							token.attributes.rotation += rot;
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		RotateExact: function (startTime, duration, degrees) {
			d20plus.anim._BaseRotate.call(this, startTime, duration, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						this._snapshotDiff = {
							degrees: (degrees || 0) - Number(token.attributes.rotation || 0),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle rotation
						if (degrees != null) token.attributes.rotation += mProgress * this._snapshotDiff.degrees;

						// update progress
						this._progress += mProgress;

						// on the last tick, update to precise values
						if (this.isLastTick()) {
							if (degrees != null) token.attributes.rotation = degrees;
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		_BaseFlip: function (startTime, isHorizontal, isVertical) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					isHorizontal,
					isVertical,
				})
			};
		},

		Flip: function (startTime, isHorizontal, isVertical) {
			d20plus.anim._BaseFlip.call(this, startTime, isHorizontal, isVertical);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (isHorizontal != null && isHorizontal) token.set("fliph", !(typeof token.get("fliph") === "string" ? token.get("fliph") === "true" : token.get("fliph")));
					if (isVertical != null && isVertical) token.set("flipv", !(typeof token.get("flipv") === "string" ? token.get("flipv") === "true" : token.get("flipv")));

					return true;
				}
				return false;
			};
		},

		FlipExact: function (startTime, isHorizontal, isVertical) {
			d20plus.anim._BaseFlip.call(this, startTime, isHorizontal, isVertical);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (isHorizontal != null) token.set("fliph", isHorizontal);
					if (isVertical != null) token.set("fliph", isVertical);

					return true;
				}
				return false;
			};
		},

		_BaseScale: function (startTime, duration, scaleFactorX, scaleFactorY) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					scaleFactorX,
					scaleFactorY,
				})
			};
		},

		Scale: function (startTime, duration, scaleFactorX, scaleFactorY) {
			d20plus.anim._BaseScale.call(this, startTime, duration, scaleFactorX, scaleFactorY);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle scaling
						if (scaleFactorX != null) {
							const mScaleX = mProgress * scaleFactorX;
							token.view.graphic.scaleX = Number(token.view.graphic.scaleX || 0) + mScaleX;
							token.attributes.scaleX = token.view.graphic.scaleX;
						}

						if (scaleFactorY != null) {
							const mScaleY = mProgress * scaleFactorY;
							token.view.graphic.scaleY = Number(token.view.graphic.scaleY || 0) + mScaleY;
							token.attributes.scaleY = token.view.graphic.scaleY;
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		ScaleExact: function (startTime, duration, scaleFactorX, scaleFactorY) {
			d20plus.anim._BaseScale.call(this, startTime, duration, scaleFactorX, scaleFactorY);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						this._snapshotDiff = {
							scaleX: (scaleFactorX || 0) - (token.view.graphic.scaleX || 0),
							scaleY: (scaleFactorY || 0) - (token.view.graphic.scaleY || 0),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle scaling
						if (scaleFactorX != null) {
							token.view.graphic.scaleX += mProgress * this._snapshotDiff.scaleX;
							token.attributes.scaleX = token.view.graphic.scaleX;
						}

						if (scaleFactorY != null) {
							token.view.graphic.scaleY += mProgress * this._snapshotDiff.scaleY;
							token.attributes.scaleY = token.view.graphic.scaleY;
						}

						// update progress
						this._progress += mProgress;

						// on the last tick, update to precise values
						if (this.isLastTick()) {
							if (scaleFactorX != null) {
								token.view.graphic.scaleX = scaleFactorX;
								token.attributes.scaleX = token.view.graphic.scaleX;
							}

							if (scaleFactorY != null) {
								token.view.graphic.scaleY = scaleFactorY;
								token.attributes.scaleY = token.view.graphic.scaleY;
							}
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		Layer: function (startTime, layer) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (layer != null) {
						token.attributes.layer = layer;
					}

					return true;
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					layer,
				})
			};
		},

		_BaseProperty: function (startTime, prop, value) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					prop,
					value,
				})
			};
		},

		SumProperty: function (startTime, prop, value) {
			d20plus.anim._BaseProperty.call(this, startTime, prop, value);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (prop != null) {
						const curNum = Number(token.attributes[prop]);
						// eslint-disable-next-line no-eval
						token.attributes[prop] = (isNaN(curNum) ? 0 : curNum) + eval(value);
					}

					return true;
				}
				return false;
			};
		},

		// TODO consider making an alternate version which sets a property on the character
		// TODO consider the ability to set properties on _other_ tokens -- might not be performant enough?
		SetProperty: function (startTime, prop, value) {
			d20plus.anim._BaseProperty.call(this, startTime, prop, value);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (prop != null) {
						if (prop === "gmnotes") value = escape(value);
						else if (prop === "sides") value = value.split("|").map(it => escape(it)).join("|");
						token.attributes[prop] = value;
					}

					return true;
				}
				return false;
			};
		},

		_BaseLighting: function (startTime, duration, lightRadius, dimStart, degrees) {
			d20plus.anim._Base.call(this);

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					duration,
					lightRadius,
					dimStart,
					degrees,
				})
			};
		},

		Lighting: function (startTime, duration, lightRadius, dimStart, degrees) {
			d20plus.anim._BaseLighting.call(this, startTime, duration, lightRadius, dimStart, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle lighting changes
						if (lightRadius != null) token.attributes.light_radius = Number(token.attributes.light_radius || 0) + mProgress * lightRadius;
						if (dimStart != null) token.attributes.light_dimradius = Number(token.attributes.light_dimradius || 0) + mProgress * dimStart;
						if (degrees != null) {
							if (token.attributes.light_angle === "") token.attributes.light_angle = 360;
							token.attributes.light_angle = Number(token.attributes.light_angle || 0) + mProgress * degrees;
						}

						// update progress
						this._progress += mProgress;

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		LightingExact: function (startTime, duration, lightRadius, dimStart, degrees) {
			d20plus.anim._BaseLighting.call(this, startTime, duration, lightRadius, dimStart, degrees);

			this.animate = function (token, alpha, delta) {
				alpha = alpha - this._offset;

				if (alpha >= startTime) {
					if (this._snapshotDiff == null) {
						this._snapshotDiff = {
							lightRadius: (lightRadius || 0) - Number(token.attributes.light_radius || 0),
							dimStart: (dimStart || 0) - Number(token.attributes.light_dimradius || 0),
							degrees: (degrees || 0) - Number(token.attributes.light_angle || 0),
						};
					}

					if (this._progress < (1 - Number.EPSILON)) {
						const mProgress = this._getTickProgress(duration, delta);

						// handle lighting changes
						if (lightRadius != null) token.attributes.light_radius = Number(token.attributes.light_radius) + mProgress * this._snapshotDiff.lightRadius;
						if (dimStart != null) token.attributes.light_dimradius = Number(token.attributes.light_dimradius) + mProgress * this._snapshotDiff.dimStart;
						if (degrees != null) token.attributes.light_angle = Number(token.attributes.light_angle) + mProgress * this._snapshotDiff.degrees;

						// update progress
						this._progress += mProgress;

						if (this.isLastTick()) {
							if (lightRadius != null) token.attributes.light_radius = lightRadius;
							if (dimStart != null) token.attributes.light_dimradius = dimStart;
							if (degrees != null) token.attributes.light_angle = degrees;
						}

						return true;
					} else this._hasRun = true;
				}
				return false;
			};
		},

		TriggerMacro: function (startTime, macroName) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (macroName != null) {
						d20.textchat.doChatInput(`#${macroName}`)
					}
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					macroName,
				})
			};
		},

		TriggerAnimation: function (startTime, animation) {
			d20plus.anim._Base.call(this);

			this.animate = function (token, alpha, delta, queue) {
				alpha = alpha - this._offset;

				if (!this._hasRun && alpha >= startTime) {
					this._hasRun = true;

					if (animation != null) {
						const anim = d20plus.anim.animatorTool.getAnimationByName(animation);

						if (!anim) return false; // if it has been deleted/etc

						const nxtQueue = d20plus.anim.animatorTool.getAnimQueue(anim);
						nxtQueue.forEach(it => it.setOffset(alpha + this._offset));
						queue.push(...nxtQueue);
					}
				}
				return false;
			};

			this.serialize = () => {
				return cleanNulls({
					...this._serialize(),
					startTime,
					animation,
				})
			};
		},
		// endregion animations
	};

	function Command (line, error, Cons = null, parsed = null) {
		this.line = line;
		this.error = error;
		this.isRunnable = !!Cons;
		this.parsed = parsed;

		this.getInstance = function () {
			return new Cons();
		};
	}

	Command.errInvalidArgCount = function (line, ...counts) { return new Command(line, `Invalid argument count; expected ${counts.joinConjunct(", ", " or ")}`) };
	Command.errPropNum = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a number`) };
	Command.errPropBool = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a boolean`) };
	Command.errPropLayer = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a layer (valid layers are: ${d20plus.ut.LAYERS.joinConjunct(", ", " or ")})`) };
	Command.errPropToken = function (line, prop, val) { return new Command(line, `${prop} "${val}" was not a token property`) };
	Command.errValNeg = function (line, prop, val) { return new Command(line, `${prop} "${val}" was negative`) };

	Command.errStartNum = function (line, val) { return Command.errPropNum(line, "start time", val) };
	Command.errStartNeg = function (line, val) { return Command.errValNeg(line, "start time", val) };
	Command.errDurationNum = function (line, val) { return Command.errPropNum(line, "duration", val) };
	Command.errDurationNeg = function (line, val) { return Command.errValNeg(line, "duration", val) };

	Command.fromString = function (line) {
		const cleanLine = line
			.split(/\/\//g)[0] // handle comments
			.trim();
		const tokens = cleanLine.split(/ +/g).filter(Boolean);
		if (!tokens.length) return new Command(line);

		const op = tokens.shift();
		switch (op) {
			case "mv":
			case "mvx": {
				if (tokens.length !== 5) return Command.errInvalidArgCount(line, 5);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nX = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nX != null && isNaN(nX)) return Command.errPropNum(line, "x", tokens[2]);
				const nY = tokens[3] === "-" ? null : Number(tokens[3]);
				if (nY != null && isNaN(nY)) return Command.errPropNum(line, "y", tokens[3]);
				const nZ = tokens[4] === "-" ? null : Number(tokens[4]);
				if (nZ != null && isNaN(nY)) return Command.errPropNum(line, "z", tokens[4]);

				if (op === "mv") {
					return new Command(
						line,
						null,
						d20plus.anim.Move.bind(null, nStart, nDuration, nX, nY, nZ),
						{
							_type: "Move",
							start: nStart,
							duration: nDuration,
							x: nX,
							y: nY,
							z: nZ,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.MoveExact.bind(null, nStart, nDuration, nX, nY, nZ),
						{
							_type: "MoveExact",
							start: nStart,
							duration: nDuration,
							x: nX,
							y: nY,
							z: nZ,
						},
					);
				}
			}

			case "rot":
			case "rotx": {
				if (tokens.length !== 3) return Command.errInvalidArgCount(line, 3);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nRot = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nRot != null && isNaN(nRot)) return Command.errPropNum(line, "degrees", tokens[2]);

				if (op === "rot") {
					return new Command(
						line,
						null,
						d20plus.anim.Rotate.bind(null, nStart, nDuration, nRot),
						{
							_type: "Rotate",
							start: nStart,
							duration: nDuration,
							degrees: nRot,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.RotateExact.bind(null, nStart, nDuration, nRot),
						{
							_type: "RotateExact",
							start: nStart,
							duration: nDuration,
							degrees: nRot,
						},
					);
				}
			}

			case "cp": {
				if (tokens.length < 1 || tokens.length > 2) return Command.errInvalidArgCount(line, 1, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const childAnim = tokens[1] === "-" ? null : tokens[1];

				return new Command(
					line,
					null,
					d20plus.anim.Copy.bind(null, nStart, childAnim),
					{
						_type: "Copy",
						start: nStart,
						animation: childAnim,
					},
				);
			}

			case "flip":
			case "flipx": {
				if (tokens.length !== 3) return Command.errInvalidArgCount(line, 3);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const flipH = tokens[1] === "-" ? null : tokens[1] === "true" ? true : tokens[1] === "false" ? false : undefined;
				if (flipH === undefined) return Command.errPropBool(line, "flipH", tokens[1]);
				const flipV = tokens[2] === "-" ? null : tokens[2] === "true" ? true : tokens[2] === "false" ? false : undefined;
				if (flipV === undefined) return Command.errPropBool(line, "flipV", tokens[2]);

				if (op === "flip") {
					return new Command(
						line,
						null,
						d20plus.anim.Flip.bind(null, nStart, flipH, flipV),
						{
							_type: "Flip",
							start: nStart,
							flipH: flipH,
							flipV: flipV,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.FlipExact.bind(null, nStart, flipH, flipV),
						{
							_type: "FlipExact",
							start: nStart,
							flipH: flipH,
							flipV: flipV,
						},
					);
				}
			}

			case "scale":
			case "scalex": {
				if (tokens.length !== 4) return Command.errInvalidArgCount(line, 4);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nScaleX = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nScaleX != null && isNaN(nScaleX)) return Command.errPropNum(line, "scaleX", tokens[2]);
				if (nScaleX != null && nScaleX < 0) return Command.errValNeg(line, "scaleX", tokens[2]);
				const nScaleY = tokens[3] === "-" ? null : Number(tokens[3]);
				if (nScaleY != null && isNaN(nScaleY)) return Command.errPropNum(line, "scaleY", tokens[3]);
				if (nScaleY != null && nScaleY < 0) return Command.errValNeg(line, "scaleY", tokens[3]);

				if (op === "scale") {
					return new Command(
						line,
						null,
						d20plus.anim.Scale.bind(null, nStart, nDuration, nScaleX, nScaleY),
						{
							_type: "Scale",
							start: nStart,
							duration: nDuration,
							scaleX: nScaleX,
							scaleY: nScaleY,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.ScaleExact.bind(null, nStart, nDuration, nScaleX, nScaleY),
						{
							_type: "ScaleExact",
							start: nStart,
							duration: nDuration,
							scaleX: nScaleX,
							scaleY: nScaleY,
						},
					);
				}
			}

			case "layer": {
				if (tokens.length !== 2) return Command.errInvalidArgCount(line, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const layer = tokens[1] === "-" ? null : tokens[1];
				if (layer != null && !d20plus.anim.VALID_LAYER.has(layer)) return Command.errPropLayer(line, "layer", layer);

				return new Command(
					line,
					null,
					d20plus.anim.Layer.bind(null, nStart, layer),
					{
						_type: "Layer",
						start: nStart,
						layer: layer,
					},
				);
			}

			case "light":
			case "lightx": {
				if (tokens.length !== 5) return Command.errInvalidArgCount(line, 5);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);
				const nDuration = Number(tokens[1]);
				if (isNaN(nDuration)) return Command.errDurationNum(line, tokens[1]);
				if (nDuration < 0) return Command.errDurationNeg(line, tokens[1]);

				const nLightRadius = tokens[2] === "-" ? null : Number(tokens[2]);
				if (nLightRadius != null && isNaN(nLightRadius)) return Command.errPropNum(line, "lightRadius", tokens[2]);
				const nDimStart = tokens[3] === "-" ? null : Number(tokens[3]);
				if (nDimStart != null && isNaN(nDimStart)) return Command.errPropNum(line, "dimStart", tokens[3]);
				const nDegrees = tokens[4] === "-" ? null : Number(tokens[4]);
				if (nDegrees != null && isNaN(nDegrees)) return Command.errPropNum(line, "degrees", tokens[4]);

				if (op === "light") {
					return new Command(
						line,
						null,
						d20plus.anim.Lighting.bind(null, nStart, nDuration, nLightRadius, nDimStart, nDegrees),
						{
							_type: "Lighting",
							start: nStart,
							duration: nDuration,
							lightRadius: nLightRadius,
							dimStart: nDimStart,
							degrees: nDegrees,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.LightingExact.bind(null, nStart, nDuration, nLightRadius, nDimStart, nDegrees),
						{
							_type: "LightingExact",
							start: nStart,
							duration: nDuration,
							lightRadius: nLightRadius,
							dimStart: nDimStart,
							degrees: nDegrees,
						},
					);
				}
			}

			case "prop":
			case "propSum": {
				if (tokens.length < 2) return Command.errInvalidArgCount(line, 3);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				const prop = tokens[1] === "-" ? null : tokens[1];
				if (prop != null && !d20plus.anim.VALID_PROP_TOKEN.has(prop)) return Command.errPropToken(line, "prop", prop);
				let val = "";
				if (tokens.length > 2) val = tokens.slice(2, tokens.length).join(" "); // combine trailing tokens
				// eslint-disable-next-line no-console
				try { val = JSON.parse(val); } catch (ignored) { console.warn(`Failed to parse "${val}" as JSON, treating as raw string...`) }

				if (op === "propSum") {
					return new Command(
						line,
						null,
						d20plus.anim.SumProperty.bind(null, nStart, prop, val),
						{
							_type: "SumProperty",
							start: nStart,
							prop: prop,
							value: val,
						},
					);
				} else {
					return new Command(
						line,
						null,
						d20plus.anim.SetProperty.bind(null, nStart, prop, val),
						{
							_type: "SetProperty",
							start: nStart,
							prop: prop,
							value: val,
						},
					);
				}
			}

			case "macro": {
				if (tokens.length !== 2) return Command.errInvalidArgCount(line, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				// no validation for macro -- it might exist in the future if it doesn't now, or vice-versa
				const macro = tokens[1] === "-" ? null : tokens[1];

				return new Command(
					line,
					null,
					d20plus.anim.TriggerMacro.bind(null, nStart, macro),
					{
						_type: "TriggerMacro",
						start: nStart,
						macro: macro,
					},
				);
			}

			case "anim": {
				if (tokens.length !== 2) return Command.errInvalidArgCount(line, 2);
				const nStart = Number(tokens[0]);
				if (isNaN(nStart)) return Command.errStartNum(line, tokens[0]);
				if (nStart < 0) return Command.errStartNeg(line, tokens[0]);

				// no validation for animation -- it might exist in the future if it doesn't now, or vice-versa
				const animation = tokens[1] === "-" ? null : tokens[1];

				return new Command(
					line,
					null,
					d20plus.anim.TriggerAnimation.bind(null, nStart, animation),
					{
						_type: "TriggerAnimation",
						start: nStart,
						animation: animation,
					},
				);
			}
		}
	};

	d20plus.anim.animatorTool = {
		name: "Token Animator",
		desc: "Manage token animations",
		html: `
			<div id="d20plus-token-animator" title="Better20 - Token Animator" class="anm__win">
				<div class="split mb-2">
					<div>
						<button class="btn" name="btn-scenes">Edit Scenes</button>
						<button class="btn" name="btn-disable">Stop Animations</button>
						<button class="btn" name="btn-rescue">Rescue Tokens</button>
					</div>
					<div>
						<button class="btn" name="btn-saving" title="If enabled, can have a serious performance impact. If disabled, animations will not resume when reloading the game.">Save Active Animations</button>
					</div>
				</div>
				<div class="split mb-2">
					<button class="btn" name="btn-add">Add Animation</button>
					<button class="btn mr-2" name="btn-import">Import Animation</button>
				</div>

				<div class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<div>
						<button class="btn" name="btn-export">Export Selected</button>
						<button class="btn btn-danger" name="btn-delete">Delete Selected</button>
					</div>
				</div>

				<div id="token-animator-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>

			<div id="d20plus-token-animator-disable" title="Stop Animation" class="anm__win">
				<p>
					<button class="btn" name="btn-refresh">Refresh</button>
				</p>

				<p class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<button class="btn" name="btn-stop">Stop Selected</button>
				</p>

				<div id="token-animator-disable-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<div class="bold flex-v-center mt-2">
						<div class="col-1"></div>
						<div class="col-3 text-center">Page</div>
						<div class="col-2 text-center">Image</div>
						<div class="col-3 text-center">Name</div>
						<div class="col-3 text-center">Animation</div>
					</div>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>

			<div id="d20plus-token-animator-rescue" title="Token Rescue" class="anm__win">
				<p>
					<button class="btn mr-2" name="btn-refresh">Refresh</button>
				</p>

				<p class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<button class="btn" name="btn-rescue">Rescue Selected</button>
				</p>

				<div id="token-animator-rescue-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<div class="bold flex-v-center mt-2">
						<div class="col-1"></div>
						<div class="col-4 text-center">Page</div>
						<div class="col-2 text-center">Image</div>
						<div class="col-5 text-center">Name</div>
					</div>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>

			<div id="d20plus-token-animator-scene" title="Scene List" class="anm__win">
				<div class="split mb-2">
					<button class="btn" name="btn-add">Add Scene</button>
					<button class="btn mr-2" name="btn-import">Import Scene</button>
				</div>

				<div class="anm__wrp-sel-all">
					<label class="flex-label"><input type="checkbox" title="Select all" name="cb-all" class="mr-2"> <span>Select All</span></label>
					<div>
						<button class="btn" name="btn-export">Export Selected</button>
						<button class="btn btn-danger" name="btn-delete">Delete Selected</button>
					</div>
				</div>

				<div id="token-animator-scene-list-container">
					<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
					<br><br>
					<ul class="list" style="max-height: 420px; overflow-y: auto; display: block; margin: 0;"></ul>
				</div>
			</div>
		`,
		_html_template_editor: `
			<div title="Animation Editor" class="anm__win anm-edit__gui flex-col">
				<div class="mb-2 no-shrink split flex-vh-center">
					<input name="ipt-name" placeholder="Name">

					<div class="flex">
						<button class="btn mr-1" name="btn-save">Save</button>
						<button class="btn" name="btn-export-file">Export to File</button>

						<div class="anm-edit__gui-hidden flex">
							<button class="btn ml-2" name="btn-help">View Help</button>
							<button class="btn ml-1" name="btn-validate">Validate</button>
						</div>

						<div class="anm-edit__gui-visible flex">
							<button class="btn ml-2" name="btn-add-command">Add Command</button>
						</div>

						<button class="btn ml-2" name="btn-edit-text">Edit as Text</button>
					</div>
				</div>

				<div class="anm-edit__ipt-lines-wrp anm-edit__ipt-lines-wrp--gui anm-edit__gui-visible">

				</div>

				<div class="anm-edit__ipt-lines-wrp anm-edit__ipt-lines-wrp--text anm-edit__gui-hidden">
					<textarea name="ipt-lines" placeholder="mv 0 100 50 -50" class="anm-edit__ipt-lines"></textarea>
				</div>
			</div>
		`,
		_html_template_scene_editor: `
			<div title="Scene Editor" class="anm__win flex-col">
				<div class="mb-2 no-shrink split">
					<input name="ipt-name" placeholder="Name">

					<div>
						<button class="btn" name="btn-save">Save</button>
						<button class="btn" name="btn-export-file">Export to File</button>
					</div>
				</div>
				<div class="mb-2">
					<button class="btn" name="btn-add">Add Part</button>
				</div>
				<div class="bold flex-v-center mt-2">
					<div class="col-3 text-center">Token</div>
					<div class="col-2"></div>
					<div class="col-2 text-center">Animation</div>
					<div class="col-2"></div>
					<div class="col-2 text-center help" title="Delay period upon starting the scene before this animation is run (in milliseconds)">Start Time</div>
					<div class="col-1"></div>
				</div>
				<div class="anm-edit__ipt-rows-wrp">

				</div>
			</div>
		`,

		dialogFn () {
			$("#d20plus-token-animator").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			}).data("initialised", false);

			$("#d20plus-token-animator-disable").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			$("#d20plus-token-animator-rescue").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});

			$("#d20plus-token-animator-scene").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 600,
			});
		},

		openFn () {
			this.init();
			this.$win.dialog("open");
		},

		// region public
		init () {
			this.$win = this.$win || $("#d20plus-token-animator");
			if (!this.$win.data("initialised")) {
				this._meta_init();
				// init the runner after, as we need to first load the animations
				d20plus.anim.animator.init();
			}
		},

		getAnimation (uid) {
			return this._anims[uid];
		},

		getAnimationByName (name) {
			const fauxAnim = d20plus.anim.animatorTool.getAnimations().find(it => it.name === name);
			if (!fauxAnim) return null;
			return d20plus.anim.animatorTool.getAnimation(fauxAnim.uid);
		},

		getAnimQueue (anim, additionalOffset) {
			additionalOffset = additionalOffset || 0;
			this._edit_convertLines(anim);
			const queue = anim.lines.filter(it => it.isRunnable).map(it => it.getInstance());
			queue.forEach(it => it._offset += additionalOffset);
			return queue;
		},

		_getUidItems (fromObj) {
			return Object.entries(fromObj).map(([k, v]) => ({
				uid: k,
				name: v.name,
			}))
		},

		getAnimations () {
			return this._getUidItems(this._anims);
		},

		getScenes () {
			return this._getUidItems(this._scenes);
		},

		isSavingActive () {
			return !!this._isSaveActive;
		},

		_pSelectUid (fnGetAll, msgNoneFound, title, defaultSelUid) {
			// convert, as the UIDs are object keys
			if (defaultSelUid != null) defaultSelUid = String(defaultSelUid);

			const selFrom = fnGetAll();
			if (!selFrom.length) return d20plus.ut.chatLog(msgNoneFound);

			return new Promise(resolve => {
				const $selUid = $(`<select>
				<option disabled value="-1">${title}</option>
				${selFrom.map(it => `<option value="${it.uid}">${it.name}</option>`).join("")}
				</select>`);
				if (defaultSelUid != null && selFrom.find(it => it.uid === defaultSelUid)) $selUid.val(defaultSelUid);
				else $selUid[0].selectedIndex = 0;

				const $dialog = $$`
					<div title="${title}">
						${$selUid}
					</div>
				`.appendTo($("body"));

				$dialog.dialog({
					dialogClass: "no-close",
					buttons: [
						{
							text: "Cancel",
							click: function () {
								$(this).dialog("close");
								$dialog.remove();
							},
						},
						{
							text: "OK",
							click: function () {
								const selected = Number(d20plus.ut.get$SelValue($selUid));
								$(this).dialog("close");
								$dialog.remove();

								if (~selected) resolve(selected);
								else resolve(null);
							},
						},
					],
				});
			});
		},

		pSelectAnimation (defaultSelUid) {
			return this._pSelectUid(
				this.getAnimations.bind(this),
				`No animations available! Use the Token Animator tool to define some first. See <a href="https://wiki.5e.tools/index.php/Feature:_Animator" target="_blank">the Wiki for help.</a>`,
				"Select Animation",
				defaultSelUid,
			);
		},

		pSelectScene (defaultSelUid) {
			return this._pSelectUid(
				this.getScenes.bind(this),
				`No scenes available! Use Edit Scenes in the Token Animator tool to define some first. See <a href="https://wiki.5e.tools/index.php/Feature:_Animator" target="_blank">the Wiki for help.</a>`,
				"Select Scene",
				defaultSelUid,
			);
		},

		doStartScene (sceneUid) {
			const scene = this._scenes[sceneUid];
			if (!scene) return d20plus.ut.chatLog(`Could not find scene!`);

			(scene.anims || []).forEach(animMeta => {
				if (animMeta.tokenId && animMeta.animUid) {
					const token = d20plus.ut.getTokenById(animMeta.tokenId);
					if (!token) return;
					const anim = this.getAnimation(animMeta.animUid);
					if (!anim) return;
					d20plus.anim.animator.startAnimation(token, animMeta.animUid, {offset: animMeta.offset || 0});
				}
			});
		},
		// endregion public

		// region meta
		_meta_doSaveState () {
			// copy, and return any parsed commands to strings
			const saveableAnims = {};
			Object.entries(this._anims).forEach(([k, v]) => {
				saveableAnims[k] = {
					...v,
					lines: [...(v.lines || [])].map(it => typeof it === "string" ? it : it.line),
				}
			});

			Campaign.save({
				bR20tool__anim_id: this._anim_id,
				bR20tool__anim_animations: saveableAnims,
				bR20tool__anim_save: this._isSaveActive,
				bR20tool__anim_scene_id: this._scene_id,
				bR20tool__anim_scenes: this._scenes,
			});
		},

		_meta_doLoadState () {
			this._anim_id = Campaign.attributes.bR20tool__anim_id || 1;
			this._scene_id = Campaign.attributes.bR20tool__anim_scene_id || 1;

			// convert legacy "array" versions to objects
			this._anims = {};
			if (Campaign.attributes.bR20tool__anim_animations) {
				const loadedAnims = MiscUtil.copy(Campaign.attributes.bR20tool__anim_animations);
				Object.entries(loadedAnims).filter(([k, v]) => !!v).forEach(([k, v]) => this._anims[k] = v);
			}

			this._scenes = {};
			if (Campaign.attributes.bR20tool__anim_scenes) {
				const loadedScenes = MiscUtil.copy(Campaign.attributes.bR20tool__anim_scenes);
				Object.entries(loadedScenes).filter(([k, v]) => !!v).forEach(([k, v]) => this._scenes[k] = v);
			}

			this._isSaveActive = Campaign.attributes.bR20tool__anim_save || false;
		},

		_meta_init () {
			this._meta_doLoadState();
			this._doSaveStateDebounced = MiscUtil.debounce(this._meta_doSaveState, 100);

			this._$winScene = $(`#d20plus-token-animator-scene`);
			this._$winDisable = $(`#d20plus-token-animator-disable`);
			this._$winRescue = $(`#d20plus-token-animator-rescue`);

			this._main_init();
			this._scene_init();
			this._rescue_init();
			this._dis_init();
			this.$win.data("initialised", true);
		},
		// endregion meta

		// region shared
		async _shared_doImport (prop, name, fnNextId, fnNextName, fnGetValidMsg, fnAdd, ...requiredProps) {
			let data;
			try {
				data = await DataUtil.pUserUpload();
			} catch (e) {
				d20plus.ut.chatLog("File was not valid JSON!");
				// eslint-disable-next-line no-console
				console.error(e);
				return;
			}

			// Done as a quick fix to account for the pUserUpload lib function changing
			data = data[0];

			if (data[prop] && data[prop].length) {
				let messages = [];
				data[prop].forEach((it, i) => {
					const missingProp = requiredProps.find(rp => it[rp] == null);
					if (missingProp != null) messages.push(`${name.uppercaseFirst()} at index ${i} is missing required fields!`);
					else {
						const originalName = it.name;
						it.uid = fnNextId();
						it.name = fnNextName(it.name);
						const msg = fnGetValidMsg(it);
						if (msg) {
							messages.push(`${originalName} was invalid: ${msg}`);
						} else {
							fnAdd(it);
							messages.push(`Added ${originalName}${it.name !== originalName ? ` (renamed as ${it.name})` : ""}!`);
						}
					}
				});

				if (messages.length) {
					// eslint-disable-next-line no-console
					console.log(messages.join("\n"));
					return d20plus.ut.chatLog(messages.join("\n"))
				}
			} else {
				return d20plus.ut.chatLog(`File contained no ${name}s!`);
			}
		},

		_shared_getValidNameMsg (obj, peers) {
			if (!obj.name.length) return "Did not have a name!";
			const illegalNameChars = obj.name.split(/[_0-9a-zA-Z]/g).filter(Boolean);
			if (illegalNameChars.length) return `Illegal characters in name: ${illegalNameChars.map(it => `"${it}"`).join(", ")}`;
			const sameName = Object.values(peers).filter(it => it.uid !== obj.uid).find(it => it.name === obj.name);
			if (sameName) return "Name must be unique!";
		},

		_shared_getNextName (obj, baseName) {
			let nxtName = baseName;
			let suffix = 1;
			while (Object.values(obj).find(it => it.name === nxtName)) nxtName = `${baseName}_${suffix++}`;
			return nxtName;
		},
		// endregion

		// region main
		_main_init () {
			const $btnAdd = this.$win.find(`[name="btn-add"]`);
			const $btnImport = this.$win.find(`[name="btn-import"]`);
			const $btnDisable = this.$win.find(`[name="btn-disable"]`);
			const $btnScenes = this.$win.find(`[name="btn-scenes"]`);
			const $btnRescue = this.$win.find(`[name="btn-rescue"]`);
			const $btnToggleSave = this.$win.find(`[name="btn-saving"]`);

			const $btnSelExport = this.$win.find(`[name="btn-export"]`);
			const $btnSelDelete = this.$win.find(`[name="btn-delete"]`);

			const $cbAll = this.$win.find(`[name="cb-all"]`);
			this._$list = this.$win.find(`.list`);

			$btnAdd.click(() => this._main_addAnim(this._main_getNewAnim()));

			$btnImport.click(async () => {
				await this._shared_doImport(
					"animations",
					"animation",
					this._main_getNextId.bind(this),
					this._shared_getNextName.bind(this, this._anims),
					this._edit_getValidationMessage.bind(this),
					this._main_addAnim.bind(this),
					"uid", "name", "lines", // required properties
				);
			});

			$btnScenes.click(() => {
				this._scene_doPopulateList();
				this._$winScene.dialog("open");
			});

			$btnDisable.click(() => {
				this._dis_doPopulateList();
				this._$winDisable.dialog("open");
			});

			$btnRescue.click(() => {
				this._rescue_doPopulateList();
				this._$winRescue.dialog("open")
			});

			$btnToggleSave.toggleClass("active", this._isSaveActive);
			$btnToggleSave.click(() => {
				this._isSaveActive = !this._isSaveActive;
				$btnToggleSave.toggleClass("active", this._isSaveActive);
				this._doSaveStateDebounced();

				// on disable, clear existing running animations
				// prevents next load from re-loading old running state
				if (!this._isSaveActive) {
					setTimeout(() => Campaign.save({bR20tool__anim_running: {}}), 100);
				}
			});

			const getSelButtons = ofClass => {
				return this._anim_list.items
					.map(it => $(it.elm))
					.filter($it => $it.find(`input`).prop("checked"))
					.map($it => $it.find(`.${ofClass}`));
			};

			$btnSelExport.click(() => {
				const out = {
					animations: this._anim_list.items
						.filter(it => $(it.elm).find(`input`).prop("checked"))
						.map(it => this._main_getExportableAnim(this._anims[it.values().uid])),
				};
				d20plus.ut.saveAsJson("animations", out);
			});

			$cbAll.click(() => {
				const val = $cbAll.prop("checked");
				this._anim_list.items.forEach(it => {
					$(it.elm.children[0].children[0]).prop("checked", val);
				})
			});

			$btnSelDelete.click(() => {
				const $btns = getSelButtons(`.anm__btn-delete`);
				if (!$btns.length) return;
				if (!confirm("Are you sure?")) return;
				$btns.forEach($btn => $btn.click());
			});

			this._main_doPopulateList();
		},

		_main_getExportableAnim (anim) {
			const out = {...anim};
			out.lines = out.lines.map(it => typeof it === "string" ? it : it.line);
			return out;
		},

		_main_doPopulateList () {
			this._$list.empty();
			Object.values(this._anims).forEach(anim => this._$list.append(this._main_getListItem(anim)));

			this._anim_list = new List("token-animator-list-container", {
				valueNames: ["name", "uid"],
			});
		},

		_main_addAnim (anim) {
			const lastSearch = d20plus.ut.getSearchTermAndReset(this._anim_list);
			this._anims[anim.uid] = anim;
			this._$list.append(this._main_getListItem(anim));

			this._anim_list.reIndex();
			if (lastSearch) this._anim_list.search(lastSearch);
			this._anim_list.sort("name");

			this._doSaveStateDebounced();
		},

		_main_getNewAnim () {
			return {
				uid: this._main_getNextId(),
				name: this._shared_getNextName(this._anims, "new_animation"),
				lines: [],
			}
		},

		_main_getNextId () {
			return this._anim_id++;
		},

		_main_getListItem (anim) {
			const $name = $(`<div class="name readable col-9 clickable" title="Edit Animation">${anim.name}</div>`)
				.click(() => this._edit_openEditor(anim));

			const $btnDuplicate = $(`<div class="btn anm__row-btn pictos mr-2" title="Duplicate">F</div>`)
				.click(() => {
					const copy = MiscUtil.copy(anim);
					copy.name = `${copy.name}_copy`;
					copy.uid = this._anim_id++;
					this._main_addAnim(copy);
				});

			const $btnExport = $(`<div class="btn anm__row-btn pictos mr-2" title="Export to File">I</div>`)
				.click(() => {
					const out = {animations: [this._main_getExportableAnim(anim)]};
					d20plus.ut.saveAsJson(`${anim.name}`, out);
				});

			const $btnDelete = $(`<div class="btn anm__row-btn btn-danger pictos anm__btn-delete mr-2" title="Delete">#</div>`)
				.click(() => {
					delete this._anims[anim.uid];
					this._anim_list.remove("uid", anim.uid);
					this._doSaveStateDebounced();
				});

			return $$`<div class="anm__row">
				<label class="col-1 flex-vh-center full-height"><input type="checkbox"></label>
				${$name}
				<div class="anm__row-controls col-2 text-center">
					${$btnDuplicate}
					${$btnExport}
					${$btnDelete}
				</div>
				<div class="hidden uid">${anim.uid}</div>
			</div>`;
		},
		// endregion main

		// region scene
		_scene_getSelected () {
			return this._scene_list.items.filter(it => $(it.elm).find("input[type=checkbox]").prop("checked"));
		},

		_scene_addScene (scene) {
			// eslint-disable-next-line no-console
			if (scene == null) return console.error(`Scene was null!`);

			const lastSearch = d20plus.ut.getSearchTermAndReset(this._scene_list);
			this._scenes[scene.uid] = scene;
			this._scene_$wrpList.append(this._scene_$getListItem(scene));

			this._scene_list.reIndex();
			if (lastSearch) this._scene_list.search(lastSearch);
			this._scene_list.sort("name");

			this._doSaveStateDebounced();
		},

		_scene_$getListItem (scene) {
			const $name = $(`<div class="name readable col-9 clickable" title="Edit Animation">${scene.name}</div>`)
				.click(() => this._scene_openEditor(scene));

			const $btnDuplicate = $(`<div class="btn anm__row-btn pictos mr-2" title="Duplicate">F</div>`)
				.click(() => {
					const copy = MiscUtil.copy(scene);
					copy.name = `${copy.name}_copy`;
					copy.uid = this._scene_id++;
					this._scene_addScene(copy);
				});

			const $btnExport = $(`<div class="btn anm__row-btn pictos mr-2" title="Export to File">I</div>`)
				.click(() => {
					const out = {scenes: [scene]};
					d20plus.ut.saveAsJson(`${scene.name}`, out);
				});

			const $btnDelete = $(`<div class="btn anm__row-btn btn-danger pictos anm__btn-delete mr-2" title="Delete">#</div>`)
				.click(() => {
					delete this._scenes[scene.uid];
					this._scene_list.remove("uid", scene.uid);
					this._doSaveStateDebounced();
				});

			return $$`<div class="flex-v-center mb-2">
				<label class="col-1 flex-vh-center full-height"><input type="checkbox"></label>
				${$name}
				<div class="anm__row-controls col-2 text-center">
					${$btnDuplicate}
					${$btnExport}
					${$btnDelete}
				</div>
				<div class="uid hidden">${scene.uid}</div>
			</div>`
		},

		_scene_doPopulateList () {
			this._scene_$wrpList.empty();
			Object.values(this._scenes).forEach(scene => this._scene_$wrpList.append(this._scene_$getListItem(scene)));

			this._scene_list = new List("token-animator-scene-list-container", {
				valueNames: [
					"name",
					"uid",
				],
			});
		},

		_scene_init () {
			this._scene_$btnAdd = this._$winScene.find(`[name="btn-add"]`);
			this._scene_$btnImport = this._$winScene.find(`[name="btn-import"]`);
			this._scene_$btnExport = this._$winScene.find(`[name="btn-export"]`);
			this._scene_$btnDelete = this._$winScene.find(`[name="btn-delete"]`);
			this._scene_$cbAll = this._$winScene.find(`[name="cb-all"]`);
			this._scene_$wrpList = this._$winScene.find(`.list`);

			this._scene_list = null;

			this._scene_$cbAll.click(() => {
				const toVal = this._scene_$cbAll.prop("checked");
				this._scene_list.items.forEach(it => $(it.elm).find("input[type=checkbox]").prop("checked", toVal));
			});

			this._scene_$btnAdd.off("click").click(() => this._scene_addScene(this._scene_getNewScene()));

			this._scene_$btnImport.click(async () => {
				await this._shared_doImport(
					"scenes",
					"scene",
					this._scene_getNextId.bind(this),
					this._shared_getNextName.bind(this, this._scenes),
					this._scene_getValidationMessage.bind(this),
					this._scene_addScene.bind(this),
					"uid", "name", "anims", // required properties
				);
			});

			this._scene_$btnExport.click(() => {
				const out = {
					scenes: this._scene_getSelected()
						.map(it => this._scenes[it.values().uid]),
				};
				d20plus.ut.saveAsJson("scenes", out);
			});

			this._scene_$btnDelete.click(() => {
				const sel = this._scene_getSelected();
				if (!sel.length) return;
				if (!confirm("Are you sure?")) return;
				sel.forEach(it => {
					const uid = it.values()._scene_id;
					delete this._scenes[uid];
					this._scene_list.remove("uid", uid);
				});
				this._doSaveStateDebounced();
			});
		},

		_scene_getNextId () {
			return this._scene_id++;
		},

		_scene_getNewScene () {
			return {
				uid: this._scene_getNextId(),
				name: this._shared_getNextName(this._scenes, "new_scene"),
				anims: [],
				/*
				Anims array structure:
				[
					...,
					{
						tokenId: "",
						animUid: "",
						offset: 0
					},
					...
				]
				 */
			}
		},

		_scene_openEditor (scene) {
			scene = MiscUtil.copy(scene);
			scene.anims = scene.anims || []; // handle legacy data
			const editorOptions = {};

			const $winEditor = $(this._html_template_scene_editor)
				.attr("title", `Scene Editor - ${scene.name}`)
				.appendTo($("body"));

			const $iptName = $winEditor.find(`[name="ipt-name"]`).disableSpellcheck()
				.val(scene.name)
				.change(() => {
					scene.name = $iptName.val().trim();
					$winEditor.dialog("option", "title", `Scene Editor - ${$iptName.val()}`);
				});
			const $btnSave = $winEditor.find(`[name="btn-save"]`);
			const $btnExportFile = $winEditor.find(`[name="btn-export-file"]`);
			const $btnAdd = $winEditor.find(`[name="btn-add"]`);
			const $wrpRows = $winEditor.find(`.anm-edit__ipt-rows-wrp`);

			$btnSave.off("click").click(() => {
				const msg = this._scene_getValidationMessage(scene);
				if (msg) return d20plus.ut.chatLog(msg);

				// we passed validation
				this._scenes[scene.uid] = scene;

				this._doSaveStateDebounced();

				const matches = this._scene_list.get("uid", scene.uid);
				if (matches.length) {
					matches[0].values({name: scene.name})
				}

				d20plus.ut.chatLog("Saved!");
			});

			$btnExportFile.off("click").click(() => {
				const out = {scenes: [scene]};
				d20plus.ut.saveAsJson(`${scene.name}`, out);
			});

			$btnAdd.off("click").click(() => $wrpRows.append(this._scene_$getEditorRow(editorOptions, scene)));

			$wrpRows.empty();
			scene.anims.forEach(animMeta => $wrpRows.append(this._scene_$getEditorRow(editorOptions, scene, animMeta)));

			$winEditor.dialog({
				resizable: true,
				width: 800,
				height: 600,
				close: () => {
					setTimeout(() => $winEditor.remove())
				},
			});
		},

		_scene_$getEditorRow (editorOptions, scene, animMeta) {
			if (!animMeta) {
				animMeta = {
					offset: 0,
				};
				scene.anims.push(animMeta);
			}

			const $btnSelToken = $(`<button class="btn anm__row-btn">Select Token</button>`)
				.click(() => {
					let lastSelectedTokenId = null;
					const $wrpTokens = $$`<div class="anm-scene__wrp-tokens"></div>`;

					const $selPage = $(`<select><option disabled value="">Select Page</option></select>`)
						.change(() => {
							lastSelectedTokenId = null;
							$wrpTokens.empty();

							const page = d20.Campaign.pages.get(d20plus.ut.get$SelValue($selPage));
							editorOptions.lastPageId = d20plus.ut.get$SelValue($selPage);

							if (page.thegraphics && page.thegraphics.length) {
								const tokens = page.thegraphics.models
									.filter(it => it.attributes.type === "image")
									.map(it => ({
										id: it.id,
										name: it.attributes.name || "(Unnamed)",
										imgsrc: it.attributes.imgsrc,
									}))
									.sort((a, b) => SortUtil.ascSortLower(a.name, b.name));
								tokens.forEach(it => {
									const $wrpToken = $$`<div class="anm-scene__wrp-token">
											<div class="no-shrink flex-vh-center" style="width: 80px; height: 80px;">
												<img
													class="no-shrink"
													style="max-width: 80px; max-height: 80px;"
													src="${it.imgsrc}"
												>
											</div>
											<div class="no-shrink full-width flex-vh-center anm-scene__wrp-token-name">
												<span title="${it.name}" class="anm-scene__wrp-token-name-inner">${it.name}</span>
											</div>
										</div>`.click(() => {
		$wrpTokens.find(`.anm-scene__wrp-token`).removeClass(`anm-scene__wrp-token--active`);
		$wrpToken.addClass(`anm-scene__wrp-token--active`);
		lastSelectedTokenId = it.id;
	}).appendTo($wrpTokens);
								});
							} else $wrpTokens.append("There are no tokens on this page!");
						});
					// TODO alphabetise pages
					d20.Campaign.pages
						.forEach(it => $(`<option value="${it.id}"></option>`).text(it.attributes.name || "(Unnamed)").appendTo($selPage));
					// default re-display last page
					if (editorOptions.lastPageId && d20.Campaign.pages.get(editorOptions.lastPageId)) $selPage.val(editorOptions.lastPageId).change();
					else $selPage[0].selectedIndex = 0;

					const $dialog = $$`
							<div title="Select Token">
								<div class="flex-col full-width full-height">
									<div class="mb-2 no-shrink">${$selPage}</div>
									${$wrpTokens}
								</div>
							</div>
						`.appendTo($("body"));

					$dialog.dialog({
						dialogClass: "no-close",
						buttons: [
							{
								text: "Cancel",
								click: function () {
									$(this).dialog("close");
									$dialog.remove();
								},
							},
							{
								text: "OK",
								click: function () {
									$(this).dialog("close");
									$dialog.remove();

									if (lastSelectedTokenId != null) {
										animMeta.tokenId = lastSelectedTokenId;
										$wrpToken.html(getTokenPart());
										$wrpTokenName.html(getTokenNamePart());
									}
								},
							},
						],
						width: 640,
						height: 480,
					});
				});
			const getTokenPart = () => {
				const token = animMeta.tokenId ? d20plus.ut.getTokenById(animMeta.tokenId) : null;
				return token ? `<img src="${token.attributes.imgsrc}" style="max-width: 40px; max-height: 40px;">` : "";
			};
			const getTokenNamePart = () => {
				const token = animMeta.tokenId ? d20plus.ut.getTokenById(animMeta.tokenId) : null;
				return token ? token.attributes.name : "";
			};
			const $wrpToken = $(`<div>${getTokenPart()}</div>`);
			const $wrpTokenName = $(`<div>${getTokenNamePart()}</div>`);

			const $btnSelAnim = $(`<button class="btn anm__row-btn">Select Animation</button>`)
				.click(async () => {
					const anim = await this.pSelectAnimation(editorOptions.lastAnimUid);
					if (anim != null) {
						editorOptions.lastAnimUid = anim;
						animMeta.animUid = anim;
						$wrpAnim.html(getAnimPart())
					}
				});
			const getAnimPart = () => {
				const anim = animMeta.animUid ? this.getAnimation(animMeta.animUid) : null;
				return anim ? anim.name : "";
			};
			const $wrpAnim = $(`<div>${getAnimPart()}</div>`);

			const $iptOffset = $(`<input type="number" min="0" style="max-width: 100%;" class="text-right">`)
				.val(animMeta.offset || 0)
				.change(() => {
					const rawNum = Number($iptOffset.val());
					const num = isNaN(rawNum) ? 0 : rawNum;
					animMeta.offset = Math.max(0, num);
					$iptOffset.val(animMeta.offset);
				});

			const $btnDelete = $(`<button class="btn btn-danger anm__row-btn pictos">#</button>`)
				.click(() => {
					scene.anims.splice(scene.anims.indexOf(animMeta), 1);
					$out.remove();
				});

			const $out = $$`<div class="flex-vh-center mb-1">
					<div class="col-1 text-center">${$wrpToken}</div>
					<div class="col-2 text-center">${$wrpTokenName}</div>
					<div class="col-2 text-center">${$btnSelToken}</div>

					<div class="col-2 text-center">${$wrpAnim}</div>
					<div class="col-2 text-center">${$btnSelAnim}</div>

					<div class="col-2">${$iptOffset}</div>

					<div class="col-1 text-center">${$btnDelete}</div>
				</div>`;
			return $out;
		},

		_scene_getValidationMessage (scene) {
			// validate name
			return this._shared_getValidNameMsg(scene, this._scenes);
		},
		// endregion

		// region rescue
		_rescue_getSelected () {
			return this._rescue_list.items.filter(it => $(it.elm).find("input[type=checkbox]").prop("checked"));
		},

		_rescue_getListItem (page, imgUrl, tokenName, _tokenId) {
			return `<label class="flex-v-center">
				<div class="col-1 flex-vh-center full-height"><input type="checkbox"></div>
				<div class="page col-4">${page}</div>
				<div class="col-2">
					<a href="${imgUrl}" target="_blank"><img src="${imgUrl}" style="max-width: 40px; max-height: 40px;"></a>
				</div>
				<div class="col-5 tokenName">${tokenName || "(unnamed)"}</div>
				<div class="_tokenId hidden">${_tokenId}</div>
			</label>`
		},

		_rescue_doPopulateList () {
			let temp = "";

			const pageW = d20.Campaign.activePage().attributes.width * 70;
			const pageH = d20.Campaign.activePage().attributes.height * 70;

			const outOfBounds = d20.Campaign.activePage().thegraphics.models.filter(tokenModel => {
				return tokenModel.view.graphic.scaleX < 0.01
					|| tokenModel.view.graphic.scaleX > 50.0
					|| tokenModel.view.graphic.scaleY < 0.01
					|| tokenModel.view.graphic.scaleY > 50.0
					|| tokenModel.attributes.left < 0
					|| tokenModel.attributes.left > pageW
					|| tokenModel.attributes.top < 0
					|| tokenModel.attributes.top > pageH;
			});

			outOfBounds.forEach(token => {
				const pageId = token.attributes.page_id;
				const pageName = (d20.Campaign.pages.get(pageId) || {attributes: {name: "(unknown)"}}).attributes.name;

				temp += this._rescue_getListItem(
					pageName,
					token.attributes.imgsrc,
					token.attributes.name,
					token.attributes.id,
				)
			});

			this._rescue_$wrpList.empty().append(temp);

			this._rescue_list = new List("token-animator-rescue-list-container", {
				valueNames: [
					"page",
					"tokenName",
					"_tokenId",
				],
			});
		},

		_rescue_init () {
			this._rescue_$btnRefresh = this._$winRescue.find(`[name="btn-refresh"]`);
			this._rescue_$btnRescue = this._$winRescue.find(`[name="btn-rescue"]`);
			this._rescue_$cbAll = this._$winRescue.find(`[name="cb-all"]`);
			this._rescue_$wrpList = this._$winRescue.find(`.list`);

			this._rescue_list = null;

			this._rescue_$cbAll.click(() => {
				const toVal = this._rescue_$cbAll.prop("checked");
				this._rescue_list.items.forEach(it => $(it.elm).find("input[type=checkbox]").prop("checked", toVal));
			});

			this._rescue_$btnRefresh.click(() => this._rescue_doPopulateList());

			this._rescue_$btnRescue.off("click").click(() => {
				const sel = this._rescue_getSelected();
				if (!sel.length) return d20plus.ut.chatLog("Please select some items from the list!");

				sel.map(it => it.values()).forEach(it => {
					// disable animations for token
					delete d20plus.anim.animator._tracker[it._tokenId];

					// reset token properties; place in the top-left corner of the canvas on the GM layer
					const token = d20plus.ut.getTokenById(it._tokenId);
					token.attributes.scaleX = 1.0;
					token.view.graphic.scaleX = token.attributes.scaleX;
					token.attributes.scaleY = 1.0;
					token.view.graphic.scaleY = token.attributes.scaleY;
					token.attributes.flipv = false;
					token.attributes.fliph = false;
					token.attributes.left = 35;
					token.attributes.top = 35;
					token.attributes.width = 70;
					token.attributes.height = 70;
					token.attributes.rotation = 0;
					token.attributes.layer = "gmlayer";
					token.save();
				});

				d20plus.ut.chatLog("Rescued tokens will be placed on the GM layer, in the top-left corner of the map");
				this._rescue_doPopulateList();
			});
		},
		// endregion rescue

		// region disabler
		_dis_getSelected () {
			return this._dis_list.items.filter(it => $(it.elm).find("input[type=checkbox]").prop("checked"));
		},

		_dis_getListItem (page, imgUrl, tokenName, animName, _tokenId, _animUid) {
			return `<label class="flex-v-center">
				<div class="col-1 flex-vh-center full-height"><input type="checkbox"></div>
				<div class="page col-3">${page}</div>
				<div class="col-2">
					<a href="${imgUrl}" target="_blank"><img src="${imgUrl}" style="max-width: 40px; max-height: 40px;"></a>
				</div>
				<div class="col-3 tokenName">${tokenName || "(unnamed)"}</div>
				<div class="col-3 animName">${animName}</div>
				<div class="_tokenId hidden">${_tokenId}</div>
				<div class="_animUid hidden">${_animUid}</div>
			</label>`
		},

		_dis_doPopulateList () {
			let temp = "";

			Object.entries(d20plus.anim.animator._tracker).forEach(([tokenId, tokenMeta]) => {
				const imgUrl = tokenMeta.token.attributes.imgsrc;
				const pageId = tokenMeta.token.attributes.page_id;
				const pageName = (d20.Campaign.pages.get(pageId) || {attributes: {name: "(unknown)"}}).attributes.name;

				Object.entries(tokenMeta.active).forEach(([animUid, animMeta]) => {
					temp += this._dis_getListItem(
						pageName,
						imgUrl,
						tokenMeta.token.attributes.name,
						d20plus.anim.animatorTool.getAnimation(animUid).name,
						tokenId,
						animUid,
					)
				});
			});

			this._dis_$wrpList.empty().append(temp);

			this._dis_list = new List("token-animator-disable-list-container", {
				valueNames: [
					"page",
					"tokenName",
					"animName",
					"_tokenId",
					"_animUid",
				],
			});
		},

		_dis_init () {
			this._dis_$btnRefresh = this._$winDisable.find(`[name="btn-refresh"]`);
			this._dis_$btnStop = this._$winDisable.find(`[name="btn-stop"]`);
			this._dis_$cbAll = this._$winDisable.find(`[name="cb-all"]`);
			this._dis_$wrpList = this._$winDisable.find(`.list`);

			this._dis_list = null;

			this._dis_$cbAll.click(() => {
				const toVal = this._dis_$cbAll.prop("checked");
				this._dis_list.items.forEach(it => $(it.elm).find("input[type=checkbox]").prop("checked", toVal));
			});

			this._dis_$btnRefresh.click(() => this._dis_doPopulateList());

			this._dis_$btnStop.off("click").click(() => {
				const sel = this._dis_getSelected();
				if (!sel.length) return d20plus.ut.chatLog("Please select some items from the list!");
				if (!confirm("Are you sure?")) return;

				sel.map(it => it.values()).forEach(it => {
					delete d20plus.anim.animator._tracker[it._tokenId].active[it._animUid];

					if (!hasAnyKey(d20plus.anim.animator._tracker[it._tokenId].active)) {
						delete d20plus.anim.animator._tracker[it._tokenId];
					}
				});

				d20plus.anim.animator.saveState();
				this._dis_doPopulateList();
			});
		},
		// endregion disabler

		// region editor
		_edit_openEditor (anim) {
			const $winEditor = $(this._html_template_editor)
				.attr("title", `Animation Editor - ${anim.name}`)
				.appendTo($("body"));

			$winEditor.dialog({
				resizable: true,
				width: 800,
				height: 600,
				close: () => {
					setTimeout(() => $winEditor.remove())
				},
			});

			const $iptName = $winEditor.find(`[name="ipt-name"]`).disableSpellcheck();
			const $btnSave = $winEditor.find(`[name="btn-save"]`);
			const $btnHelp = $winEditor.find(`[name="btn-help"]`);
			const $btnAddCommand = $winEditor.find(`[name="btn-add-command"]`);
			const $btnExportFile = $winEditor.find(`[name="btn-export-file"]`);
			const $btnValidate = $winEditor.find(`[name="btn-validate"]`);
			const $btnEditText = $winEditor.find(`[name="btn-edit-text"]`);
			const $iptLines = $winEditor.find(`[name="ipt-lines"]`);
			const $wrpRows = $winEditor.find(`.anm-edit__ipt-lines-wrp--gui`);

			anim.lines = anim.lines || [];
			$iptName
				.val(anim.name)
				.change(() => {
					$winEditor.dialog("option", "title", `Animation Editor - ${$iptName.val()}`);
				});

			// map to strings to ensure fresh array
			let myLines = anim.lines.map(it => typeof it === "string" ? it : it.line);

			const doDisplayLines = () => {
				$iptLines.val(myLines.map(it => typeof it === "string" ? it : it.line).join("\n"));
			};

			const gui_getTitleFromType = (type, doRemoveExact) => {
				const clean = doRemoveExact ? type.replace(/exact/gi, "") : type;

				const splCaps = clean.split(/([A-Z])/g).filter(it => it.trim());
				const stack = [];
				for (let i = 0; i < splCaps.length; ++i) {
					const tok = splCaps[i];
					if (i % 2 === 0) stack.push(tok);
					else stack[stack.length - 1] = `${stack.last()}${tok}`;
				}
				return stack.join(" ");
			};

			const gui_getBasicRowMeta = (myLines, line, isDuration) => {
				const parsed = line.parsed;

				const _getTitleMeta = () => {
					const clean = parsed._type.replace(/exact/gi, "");

					const text = gui_getTitleFromType(parsed._type, true);

					return {
						text,
						className: `anm-edit__gui-row-name--${clean}`,
					}
				};

				const doUpdate = () => {
					parsed.start = Math.round(Number($iptStart.val()));
					if (isDuration) parsed.duration = Math.round(Number($iptDuration.val()));
					line.line = d20plus.anim.lineFromParsed(parsed);
				};

				const $btnRemove = $(`<button class="btn btn-danger mr-2">Delete</button>`).click(() => {
					myLines.splice(myLines.indexOf(line), 1);
					$row.remove();
				});

				const $iptStart = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.start);
				const $iptDuration = isDuration ? $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.duration) : null;

				const $wrpHeaders = $$`<div class="flex-v-center mb-2">
						<div class="col-2 bold flex-vh-center">Start Time (ms)</div>
						${isDuration ? `<div class="col-2 bold flex-vh-center">Duration (ms)</div>` : ""}
					</div>`;

				const $wrpInputs = $$`<div class="flex-v-center">
						<div class="col-2 flex-vh-center">${$iptStart}</div>
						${isDuration ? $$`<div class="col-2 flex-vh-center">${$iptDuration}</div>` : ""}
					</div>`;

				const titleMeta = _getTitleMeta();
				const $dispName = $(`<div class="bold anm-edit__gui-row-name ${titleMeta.className}">${titleMeta.text}</div>`);
				const $row = $$`<div class="flex-col full-width anm-edit__gui-row">
						<div class="split flex-v-center mb-2">
							<div class="full-width flex-v-center full-height">${$dispName}</div>
							${$btnRemove}
						</div>
						${$wrpHeaders}
						${$wrpInputs}
					</div>`;

				return {$row, doUpdate, $wrpHeaders, $wrpInputs, $dispName};
			};

			const gui_$getBtnAnim = (fnUpdate, $iptAnim) => {
				return $(`<button class="btn btn-xs mr-2 pictos">s</button>`)
					.click(async () => {
						const name = await new Promise(resolve => {
							const $selAnim = $(`<select>
							<option value="-1">(None)</option>
							${d20plus.anim.animatorTool.getAnimations().map(it => `<option value="${it.uid}">${it.name}</option>`).join("")}
							</select>`);
							$selAnim[0].selectedIndex = 0;

							const $dialog = $$`<div title="Select Animation">${$selAnim}</div>`.appendTo($("body"));

							$dialog.dialog({
								dialogClass: "no-close",
								buttons: [
									{
										text: "Cancel",
										click: function () {
											$(this).dialog("close");
											$dialog.remove();
										},
									},
									{
										text: "OK",
										click: function () {
											const selected = Number(d20plus.ut.get$SelValue($selAnim));
											$(this).dialog("close");
											$dialog.remove();

											if (~selected) resolve((d20plus.anim.animatorTool.getAnimation(selected) || {}).name);
											else resolve(null);
										},
									},
								],
							});
						});

						if (name != null) {
							$iptAnim.val(name);
							fnUpdate();
						} else if (!allowNone) {
							$iptAnim.val("-");
							fnUpdate();
						}
					});
			};

			const gui_$getWrapped = (it, width, bold) => $$`<div class="col-${width} flex-vh-center ${bold ? "bold" : ""}">${it}</div>`;

			const gui_doAddRow = (myLines, line) => {
				const parsed = line.parsed;
				switch (parsed._type) {
					case "Move":
					case "MoveExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.x = $iptX.val().trim() ? Math.round(Number($iptX.val())) : null;
							parsed.y = $iptY.val().trim() ? Math.round(Number($iptY.val())) : null;
							parsed.z = $iptZ.val().trim() ? Math.round(Number($iptZ.val())) : null;
							parsed._type = $cbExact.prop("checked") ? "MoveExact" : "Move";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptX = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.x);
						const $iptY = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.y);
						const $iptZ = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.z);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "MoveExact").change(() => doUpdate());

						gui_$getWrapped("X", 1, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Y", 1, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Z", 1, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 4).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptX, 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptY, 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptZ, 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 4).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Rotate":
					case "RotateExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.degrees = $iptDegrees.val().trim() ? Math.round(Number($iptDegrees.val().trim())) : null;
							parsed._type = $cbExact.prop("checked") ? "RotateExact" : "Rotate";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptDegrees = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.degrees);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "RotateExact").change(() => doUpdate());

						gui_$getWrapped("Degrees", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 6).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptDegrees, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 6).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Copy": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.animation = $iptAnim.val().trim() || null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $iptAnim = $(`<input class="full-width mr-1">`).change(() => doUpdate()).val(parsed.animation);
						const $btnSelAnim = gui_$getBtnAnim(doUpdate, $iptAnim);

						gui_$getWrapped("Animation", 3, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptAnim, 3).append($btnSelAnim).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Flip":
					case "FlipExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.flipH = $selFlipH.val() === "0" ? null : $selFlipH.val() !== "1";
							parsed.flipV = $selFlipV.val() === "0" ? null : $selFlipV.val() !== "1";
							parsed._type = $cbExact.prop("checked") ? "FlipExact" : "Flip";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $getSelFlip = () => {
							const VALS = ["(None)", "No", "Yes"];
							return $(`<select class="sel-xs mr-2">${VALS.map((it, i) => `<option value="${i}">${it}</option>`).join("")}</select>`);
						};

						const $selFlipH = $getSelFlip().val(parsed.flipH == null ? "0" : parsed.flipH ? "2" : "1").change(() => doUpdate());
						const $selFlipV = $getSelFlip().val(parsed.flipV == null ? "0" : parsed.flipV ? "2" : "1").change(() => doUpdate());
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "FlipExact").change(() => doUpdate());

						gui_$getWrapped("Flip Horizontally", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Flip Vertically", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 3).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($selFlipH, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($selFlipV, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Scale":
					case "ScaleExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.scaleX = $iptScaleX.val().trim() ? Number($iptScaleX.val()) : null;
							parsed.scaleY = $iptScaleY.val().trim() ? Number($iptScaleY.val()) : null;
							parsed._type = $cbExact.prop("checked") ? "ScaleExact" : "Scale";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptScaleX = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.scaleX);
						const $iptScaleY = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.scaleY);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "ScaleExact").change(() => doUpdate());

						gui_$getWrapped("Horizontal Scale", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Vertical Scale", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptScaleX, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptScaleY, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Layer": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.layer = $selLayer.val().trim() ? $selLayer.val() : null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $selLayer = $(`<select class="mr-2 sel-xs">
							<option value="">Select a layer...</option>
							${d20plus.ut.LAYERS.map(l => `<option value="${l}">${d20plus.ut.layerToName(l)}</option>`).join("")}
							</select>`)
							.change(() => doUpdate()).val(parsed.layer);

						gui_$getWrapped("Layer", 3, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($selLayer, 3).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "Lighting":
					case "LightingExact": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, true);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.lightRadius = $iptLightRadius.val().trim() ? Math.round(Number($iptLightRadius.val())) : null;
							parsed.dimStart = $iptDimStart.val().trim() ? Math.round(Number($iptDimStart.val())) : null;
							parsed.degrees = $iptDegrees.val().trim() ? Math.round(Number($iptDegrees.val())) : null;
							parsed._type = $cbExact.prop("checked") ? "LightingExact" : "Lighting";
							line.line = d20plus.anim.lineFromParsed(parsed);
							baseMeta.$dispName.text(parsed._type);
						};

						const $iptLightRadius = $(`<input type="number" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.lightRadius);
						const $iptDimStart = $(`<input type="number" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.dimStart);
						const $iptDegrees = $(`<input type="number" min="0" class="full-width mr-2">`).change(() => doUpdate()).val(parsed.degrees);
						const $cbExact = $(`<input type="checkbox">`).prop("checked", parsed._type === "MoveExact").change(() => doUpdate());

						gui_$getWrapped("Light Radius", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Dim Start", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Angle", 2, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Is Exact", 1, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptLightRadius, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptDimStart, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptDegrees, 2).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($cbExact, 1).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "SetProperty":
					case "SumProperty": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.prop = $selProp.val();
							try { parsed.value = JSON.parse($iptVal().trim()); } catch (ignored) { parsed.value = $iptVal.val(); }
							line.line = d20plus.anim.lineFromParsed(parsed);
							parsed._type = $selMode.val();
							baseMeta.$dispName.text(parsed._type);
						};

						const $selProp = $(`<select class="mr-2 sel-xs">${d20plus.anim._PROP_TOKEN.sort(SortUtil.ascSortLower).map(it => `<option>${it}</option>`).join("")}</select>`)
							.change(() => doUpdate()).val(parsed.prop);
						const $iptVal = $(`<textarea class="full-width my-0" style="resize: vertical;"></textarea>`).change(() => doUpdate()).val(parsed.value);
						const $selMode = $(`<select class="mr-2 sel-xs">
							<option value="SetProperty">Set</option>
							<option value="SumProperty">Sum</option>
						</select>`)
							.val(parsed._type)
							.change(() => doUpdate());

						gui_$getWrapped("Property", 4, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Value", 3, true).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpHeaders);
						gui_$getWrapped("Mode", 2, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($selProp, 4).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($iptVal, 3).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped("", 1).appendTo(baseMeta.$wrpInputs);
						gui_$getWrapped($selMode, 2).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "TriggerMacro": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.macro = $iptMacro.val().trim() ? $iptMacro.val().trim() : null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $iptMacro = $(`<input class="full-width mr-2">`).change(() => doUpdate()).val(parsed.macro);
						// TODO add macro search button?

						gui_$getWrapped("Macro Name", 4, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptMacro, 4).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					case "TriggerAnimation": {
						const baseMeta = gui_getBasicRowMeta(myLines, line, false);

						const doUpdate = () => {
							baseMeta.doUpdate();
							parsed.animation = $iptAnim.val().trim() ? $iptAnim.val().trim() : null;
							line.line = d20plus.anim.lineFromParsed(parsed);
						};

						const $iptAnim = $(`<input class="full-width mr-1">`).change(() => doUpdate()).val(parsed.animation);
						const $btnSelAnim = gui_$getBtnAnim(doUpdate, $iptAnim);

						gui_$getWrapped("Animation", 3, true).appendTo(baseMeta.$wrpHeaders);

						gui_$getWrapped($iptAnim, 3).append($btnSelAnim).appendTo(baseMeta.$wrpInputs);

						$wrpRows.append(baseMeta.$row);

						break;
					}
					default: throw new Error(`Unhandled type "${parsed._type}"`);
				}
			};

			const doDisplayRows = () => {
				$wrpRows.empty();
				const wrpMyLines = {lines: myLines};
				this._edit_convertLines(wrpMyLines);

				myLines.forEach(line => {
					if (line.error) {
						// eslint-disable-next-line no-console
						console.error(`Failed to create GUI row from line "${line.line}"!`, line.error);
					} else gui_doAddRow(myLines, line);
				});
			};

			const getValidationMessage = () => {
				if ($btnEditText.hasClass("active")) {
					// create a fake animation object, and check it for errors
					const toValidate = {
						uid: anim.uid, // pass out UID, so the validator can ignore our old data when checking duplicate names
						name: $iptName.val(),
						lines: $iptLines.val().split("\n"),
					};
					return this._edit_getValidationMessage(toValidate);
				}
				// (assume the GUI version passes validation)
				return null;
			};

			$btnSave.off("click").click(() => {
				if ($btnEditText.hasClass("active")) {
					const msg = getValidationMessage();
					if (msg) return d20plus.ut.chatLog(msg);

					// we passed validation
					anim.name = $iptName.val();
					anim.lines = $iptLines.val().split("\n");
				} else {
					const nameMsg = this._shared_getValidNameMsg({name: $iptName.val(), uid: anim.uid}, this._anims);
					if (nameMsg) return d20plus.ut.chatLog(nameMsg);

					anim.name = $iptName.val();
					anim.lines = myLines.map(it => typeof it === "string" ? it : it.line);
				}
				this._doSaveStateDebounced();

				const matches = this._anim_list.get("uid", anim.uid);
				if (matches.length) matches[0].values({name: anim.name});

				d20plus.ut.chatLog("Saved!");
			});

			$btnExportFile.off("click").click(() => {
				const out = {animations: [this._main_getExportableAnim(anim)]};
				d20plus.ut.saveAsJson(`${anim.name}`, out);
			});

			$btnValidate.off("click").click(() => {
				const msg = getValidationMessage();
				d20plus.ut.chatLog(msg || "Valid!");
			});

			$btnHelp.click(() => {
				d20plus.ut.chatLog(`<a href="https://wiki.5e.tools/index.php/Feature:_Animator" target="_blank">View the Wiki page for help!</a>`);
				window.open("https://wiki.5e.tools/index.php/Feature:_Animator");
			});

			let lastSelCommand = null;
			$btnAddCommand.click(async () => {
				const _KEYS = [...new Set(Object.keys(d20plus.anim.COMMAND_TO_SHORT).map(it => it.replace(/exact/gi, "")))];

				const type = await new Promise(resolve => {
					const $selCommand = $(`<select>
					<option disabled value="-1">Select Command...</option>
					${_KEYS.map((it, i) => `<option value="${i}">${gui_getTitleFromType(it, false)}</option>`).join("")}
					</select>`);

					if (lastSelCommand != null) $selCommand.val(lastSelCommand);
					else $selCommand[0].selectedIndex = 0;

					const $dialog = $$`<div title="Select Command">${$selCommand}</div>`.appendTo($("body"));

					$dialog.dialog({
						dialogClass: "no-close",
						buttons: [
							{
								text: "Cancel",
								click: function () {
									$(this).dialog("close");
									$dialog.remove();
								},
							},
							{
								text: "OK",
								click: function () {
									const ix = Number(d20plus.ut.get$SelValue($selCommand));
									$(this).dialog("close");
									$dialog.remove();

									if (~ix) {
										resolve(_KEYS[ix]);
										lastSelCommand = String(ix);
									} else resolve(null);
								},
							},
						],
					});
				});

				if (type == null) return;

				const nuLine = (() => {
					const short = d20plus.anim.COMMAND_TO_SHORT[type];
					if (!short) throw new Error(`No short form found for "${short}"`);
					const args = d20plus.anim.SHORT_TO_DEFAULT_ARGS[short];
					if (!args) throw new Error(`No default args found for "${short}"`);
					return `${short} ${args}`;
				})();

				myLines.push(nuLine);
				const wrpMyLines = {lines: myLines};
				this._edit_convertLines(wrpMyLines);
				gui_doAddRow(myLines, myLines.last());
			});

			$btnEditText.click(() => {
				const isTextModeNxt = !$btnEditText.hasClass("active");
				if (isTextModeNxt) {
					// myLines will already be up-to-date due to UI state changes; simply switch to text display
					doDisplayLines();
				} else {
					// validate + update state
					const msg = getValidationMessage();
					if (msg) return d20plus.ut.chatLog(msg);

					myLines = $iptLines.val().split("\n").map(it => it.trim()).filter(Boolean);
					doDisplayRows();
				}

				$btnEditText.toggleClass("active");
				$winEditor.toggleClass("anm-edit__text", isTextModeNxt);
				$winEditor.toggleClass("anm-edit__gui", !isTextModeNxt);
			});

			doDisplayRows();
		},

		/**
		 * Returns `null` if valid, or an error message if invalid.
		 * @private
		 */
		_edit_getValidationMessage (anim) {
			// validate name
			const nameMsg = this._shared_getValidNameMsg(anim, this._anims);
			if (nameMsg) return nameMsg;

			// validate lines
			this._edit_convertLines(anim);

			const badLines = anim.lines.filter(c => c.error);
			if (badLines.length) {
				return `Invalid, the following lines could not be parsed:\n${badLines.map(c => `${c.error} at line "${c.line}"`).join("\n")}`;
			}

			return null;
		},

		_edit_convertLines (anim) {
			for (let i = 0; i < anim.lines.length; ++i) {
				const line = anim.lines[i];
				if (typeof line === "string") anim.lines[i] = Command.fromString(line);
			}
		},
		// endregion editor
	};

	d20plus.tool.tools.push(d20plus.anim.animatorTool);

	function hasAnyKey (object) {
		for (const k in object) {
			if (!object.hasOwnProperty(k)) continue;
			return true;
		}
		return false;
	}

	d20plus.anim.animator = {
		/*
		_tracker: {
			tokenId: {
				token: {...}, // Roll20 token
				active: {
					// only one instance of an animation can be active on a token at a time
					animUid: {
						queue: [...], // returned by getAnimQueue
						start, // start time
						lastTick, // last tick time
						lastAlpha // last alpha value passed -- used for deserialization
					},
					... // other animations
				}
			}
		}
		*/
		_tracker: {},
		_restTicks: 1,

		__tickCount: 0,

		startAnimation (token, animUid, options) {
			options = options || {};

			const anim = d20plus.anim.animatorTool.getAnimation(animUid);
			const queue = d20plus.anim.animatorTool.getAnimQueue(anim, options.offset || 0);

			this._tracker[token.id] = this._tracker[token.id] || {token, active: {}};
			const time = (new Date()).getTime();
			this._tracker[token.id].active[animUid] = {
				queue,
				start: time,
				lastTick: time,
			};
		},

		endAnimation (token, animUid) {
			if (this._tracker[token.id] && this._tracker[token.id].active[animUid]) {
				delete this._tracker[token.id].active[animUid];

				if (hasAnyKey(this._tracker[token.id].active)) delete this._tracker[token.id];
			}
		},

		setRestTicks (tickRate) {
			this._restTicks = tickRate;
		},

		_lastTickActive: false,
		_tickTimeout: null,
		doTick () {
			if (this._tickTimeout) clearTimeout(this._tickTimeout);

			if (this._hasAnyActive()) {
				// if we've been sleeping, reset start times
				// prevents an initial "jolt" as anims suddenly have catch up on 1.5s of lag
				if (!this._lastTickActive) {
					this._lastTickActive = true;
					const time = (new Date()).getTime();

					for (const tokenId in this._tracker) {
						if (!this._tracker.hasOwnProperty(tokenId)) continue;
						const tokenMeta = this._tracker[tokenId];

						for (const animUid in tokenMeta.active) {
							if (!tokenMeta.active.hasOwnProperty(animUid)) continue;
							const instance = tokenMeta.active[animUid];
							instance.start = time;
							instance.lastTick = time;
						}
					}
				}

				this._doTick();
			} else {
				this._lastTickActive = false;
				// if none are active, sleep for 1.5 seconds
				this._tickTimeout = setTimeout(() => this.doTick(), 1500);
			}
		},

		_saveState () {
			const toSave = {};
			Object.entries(this._tracker).forEach(([tokenId, tokenMeta]) => {
				const saveableTokenMeta = {active: {}};

				Object.entries(tokenMeta.active).forEach(([animUid, state]) => {
					saveableTokenMeta.active[animUid] = {
						queue: state.queue.map(it => it.serialize()),
						lastAlpha: state.lastAlpha,
					};
				});

				toSave[tokenId] = saveableTokenMeta;
			});

			Campaign.save({
				bR20tool__anim_running: toSave,
			});
		},

		saveState () {
			if (d20plus.anim.animatorTool.isSavingActive()) this._doSaveStateThrottled();
		},

		loadState () {
			const time = (new Date()).getTime();
			const saved = Campaign.attributes.bR20tool__anim_running ? MiscUtil.copy(Campaign.attributes.bR20tool__anim_running) : {};
			const toLoad = {};
			Object.entries(saved).forEach(([tokenId, savedTokenMeta]) => {
				// load real token
				const token = d20plus.ut.getTokenById(tokenId);
				// eslint-disable-next-line no-console
				if (!token) return console.log(`Token ${tokenId} not found!`);
				const tokenMeta = {};
				tokenMeta.token = token;

				const active = {};
				Object.entries(savedTokenMeta.active).forEach(([animUid, savedState]) => {
					const anim = d20plus.anim.animatorTool.getAnimation(animUid);
					// eslint-disable-next-line no-console
					if (!anim) return console.log(`Animation ${animUid} not found!`);

					active[animUid] = {
						queue: savedState.queue.map(it => d20plus.anim.deserialize(it)),
						start: time - savedState.lastAlpha,
						lastTick: time,
					}
				});

				tokenMeta.active = active;

				toLoad[tokenId] = tokenMeta;
			});

			this._tracker = toLoad;
		},

		_hasAnyActive () {
			return hasAnyKey(this._tracker);
		},

		_doTick () {
			// higher tick rate = slower
			if (++this.__tickCount >= this._restTicks) {
				this.__tickCount = 0;
				let anyGlobalModifications = false;

				const time = (new Date()).getTime();

				for (const tokenId in this._tracker) {
					if (!this._tracker.hasOwnProperty(tokenId)) continue;
					const tokenMeta = this._tracker[tokenId];

					let anyModification = false;
					for (const animUid in tokenMeta.active) {
						if (!tokenMeta.active.hasOwnProperty(animUid)) continue;
						const instance = tokenMeta.active[animUid];

						const alpha = time - instance.start;
						const delta = time - instance.lastTick;

						// avoid using fast-loop length optimization, as we'll splice out completed animations
						for (let i = 0; i < instance.queue.length; ++i) {
							anyModification = instance.queue[i].animate(
								tokenMeta.token,
								alpha,
								delta,
								instance.queue,
							) || anyModification;

							if (instance.queue[i].hasRun()) {
								instance.queue.splice(i, 1);
								--i;
							}
						}

						// queue empty -> this animation is no longer active
						if (!instance.queue.length) delete tokenMeta.active[animUid];
						else {
							instance.lastTick = time;
							instance.lastAlpha = alpha;
						}
					}

					// no active animations -> stop tracking this token
					if (!hasAnyKey(tokenMeta.active)) delete this._tracker[tokenId];

					// save after applying animations
					if (anyModification) tokenMeta.token.save();
					anyGlobalModifications = anyGlobalModifications || anyModification;
				}

				this.saveState();
				if (anyGlobalModifications) d20.engine.canvas.renderAll();
			}

			requestAnimationFrame(this.doTick.bind(this))
		},

		init () {
			this._doSaveStateThrottled = _.throttle(this._saveState, 100);
			setTimeout(() => {
				this.loadState();
				this._lastTickActive = true;
				this.doTick();
			}, 5000);
		},
	};

	// all properties that can be set via the 'prop' command
	d20plus.anim._PROP_TOKEN = [
		"left",
		"top",
		"width",
		"height",
		"z_index",
		"imgsrc",
		"rotation",
		"type",
		"layer",
		"locked",
		"flipv",
		"fliph",
		"anim_loop",
		"anim_paused_at",
		"anim_autoplay",
		"name",
		"gmnotes", // `escape`d HTML
		"controlledby",
		"represents",
		"bar1_value",
		"bar1_max",
		"bar1_link",
		"bar2_value",
		"bar2_max",
		"bar2_link",
		"bar3_value",
		"bar3_max",
		"bar3_link",
		"aura1_radius",
		"aura1_color",
		"aura1_square",
		"aura2_radius",
		"aura2_color",
		"aura2_square",
		"tint_color",
		"status_dead",
		"statusmarkers",
		"showname",
		"showplayers_name",
		"showplayers_bar1",
		"showplayers_bar2",
		"showplayers_bar3",
		"showplayers_aura1",
		"showplayers_aura2",
		"playersedit_name",
		"playersedit_bar1",
		"playersedit_bar2",
		"playersedit_bar3",
		"playersedit_aura1",
		"playersedit_aura2",
		"light_radius",
		"light_dimradius",
		"light_otherplayers",
		"light_hassight",
		"light_angle",
		"light_losangle",
		"light_multiplier",
		"adv_fow_view_distance",
		"groupwith",
		"sides", // pipe-separated list of `escape`d image URLs
		"currentSide",
	];
	d20plus.anim.VALID_PROP_TOKEN = new Set(d20plus.anim._PROP_TOKEN);

	d20plus.anim.VALID_LAYER = new Set(d20plus.ut.LAYERS);

	d20plus.anim.COMMAND_TO_SHORT = {
		"Move": "mv",
		"MoveExact": "mvx",
		"Rotate": "rot",
		"RotateExact": "rotx",
		"Copy": "cp",
		"Flip": "flip",
		"FlipExact": "flipx",
		"Scale": "scale",
		"ScaleExact": "scalex",
		"Layer": "layer",
		"Lighting": "light",
		"LightingExact": "lightx",
		"SetProperty": "prop",
		"SumProperty": "propSum",
		"TriggerMacro": "macro",
		"TriggerAnimation": "anim",
	};

	d20plus.anim.SHORT_TO_DEFAULT_ARGS = {
		"mv": "0 0 - - -",
		"mvx": "0 0 - - -",
		"rot": "0 0 -",
		"rotx": "0 0 -",
		"cp": "0",
		"flip": "0 - -",
		"flipx": "0 - -",
		"scale": "0 0 - -",
		"scalex": "0 0 - -",
		"layer": "0 -",
		"light": "0 0 - - -",
		"lightx": "0 0 - - -",
		"prop": "0 -",
		"propSum": "0 -",
		"macro": "0 -",
		"anim": "0 -",
	};
}

SCRIPT_EXTENSIONS.push(baseToolAnimator);


function d20plusArt () {
	d20plus.art = {
		button: () => {
			// add external art button was clicked
			const $art = $("#d20plus-artfolder");
			$art.dialog("open");
			const $artList = $art.find(`.list`);
			$artList.empty();

			if (d20plus.art.custom) {
				d20plus.art.custom.forEach(a => {
					const $liArt = getArtLi(a.name, a.url);
					$artList.append($liArt);
				});
			}

			// init list library
			const artList = new List("art-list-container", {
				valueNames: ["name"],
				listClass: "artlist",
			});

			const $btnAdd = $(`#art-list-add-btn`);
			const $iptAddName = $(`#art-list-add-name`);
			const $iptAddUrl = $(`#art-list-add-url`);
			$btnAdd.off("click");
			$btnAdd.on("click", () => {
				const name = $iptAddName.val().trim();
				const url = $iptAddUrl.val().trim();
				if (!name || !url) {
					alert("Missing required fields!")
				} else {
					artList.search();
					artList.filter();
					const $liArt = getArtLi(name, url);
					$artList.append($liArt);
					refreshCustomArtList();
				}
			});

			const $btnMassAdd = $(`#art-list-multi-add-btn`);
			$btnMassAdd.off("click");
			$btnMassAdd.on("click", () => {
				$("#d20plus-artmassadd").dialog("open");
				const $btnMassAddSubmit = $(`#art-list-multi-add-btn-submit`);
				$btnMassAddSubmit.off("click");
				$btnMassAddSubmit.on("click", () => {
					artList.search();
					artList.filter();
					const $iptUrls = $(`#art-list-multi-add-area`);
					const massUrls = $iptUrls.val();
					const spl = massUrls.split("\n").map(s => s.trim()).filter(s => s);
					if (!spl.length) return;
					const delim = "---";
					const toAdd = [];
					for (const s of spl) {
						if (!s.includes(delim)) {
							alert(`Badly formatted line: ${s}`);
							return;
						} else {
							const parts = s.split(delim);
							if (parts.length !== 2) {
								alert(`Badly formatted line: ${s}`);
								return;
							} else {
								toAdd.push({
									name: parts[0],
									url: parts[1],
								});
							}
						}
					}
					toAdd.forEach(a => {
						$artList.append(getArtLi(a.name, a.url));
					});
					refreshCustomArtList();
					$("#d20plus-artmassadd").dialog("close");
				});
			});

			const $btnDelAll = $(`#art-list-delete-all-btn`);
			$btnDelAll.off("click").on("click", () => {
				$artList.empty();
				refreshCustomArtList();
			});

			makeDraggables();
			d20plus.art.refreshList = refreshCustomArtList;

			function getArtLi (name, url) {
				const showImage = d20plus.cfg.get("interface", "showCustomArtPreview");
				const $liArt = $(`
						<li class="dd-item library-item draggableresult Vetools-draggable-art ui-draggable" data-fullsizeurl="${url}">
							${showImage ? `<img src="${url}" style="width: 30px; max-height: 30px; display: inline-block" draggable="false">` : ""}
							<div class="dd-content name" style="display: inline-block; width: 35%;" data-url="${url}">${name}</div>
							<a href="${url}"><span class="url" style="display: inline-block; width: ${showImage ? "40%" : "55%"};">${url}</span></a>
						</li>
					`);
				if (!showImage) {
					$liArt.on("mousedown", () => {
						const $loader = $(`<div class="temp-warning">Loading image - don't drop yet!</div>`);
						const $img = $(`<img src="${url}" style="width: 30px; max-height: 30px; display: none">`);
						if (!$img.prop("complete")) {
							$(`body`).append($loader);
							$img.on("load", () => {
								$loader.remove();
							});
							$loader.append($img);
						}
					});
				}

				const $btnDel = $(`<span class="delete btn btn-danger"><span class="pictos">#</span></span>`).on("click", () => {
					$liArt.remove();
					deleteCustomArt(name);
				});
				$liArt.append($btnDel);
				return $liArt;
			}

			function deleteCustomArt (name) {
				artList.remove("name", name)
				d20plus.art.custom.splice(d20plus.art.custom.findIndex(i => i.name === name), 1);
				makeDraggables();
				d20plus.art.saveToHandout();
			}

			function refreshCustomArtList () {
				artList.reIndex();
				const custom = [];
				artList.items.forEach(i => {
					const $ele = $(i.elm);
					custom.push({
						name: $ele.find(`.name`).text(),
						url: $ele.find(`.url`).text(),
					});
				});
				d20plus.art.custom = custom;
				makeDraggables();
				d20plus.art.saveToHandout();
			}

			function makeDraggables () {
				$(`.Vetools-draggable-art`).draggable({
					handle: ".dd-content",
					revert: true,
					revertDuration: 0,
					helper: "clone",
					appendTo: "body",
				})
			}
		},

		saveToHandout () {
			const handout = d20plus.art.getArtHandout();
			if (!handout) {
				d20.Campaign.handouts.create({
					name: ART_HANDOUT,
					archived: true,
				}, {
					success: function (handout) {
						notecontents = "This handout is used to store custom art URLs.";

						const gmnotes = JSON.stringify(d20plus.art.custom);
						handout.updateBlobs({notes: notecontents, gmnotes: gmnotes});
						handout.save({notes: (new Date()).getTime(), inplayerjournals: ""});
					},
				});
			} else {
				const gmnotes = JSON.stringify(d20plus.art.custom);
				handout.updateBlobs({gmnotes: gmnotes});
				handout.save({notes: (new Date()).getTime()});
			}
		},

		/**
		 * @param items Array of Objects with "name" and "url" properties.
		 * @private
		 */
		addToHandout (items) {
			const invalid = items.find(it => !it.name || !it.url);
			if (invalid) throw new Error(`Invalid item ${JSON.stringify(invalid)} did not contain required name and URL properties!`);
			d20plus.art.custom = (d20plus.art.custom || []).concat(items);
			d20plus.art.saveToHandout();
		},

		// TODO load a decent default art library from somewhere
		default: [
			// {
			// 	name: "Phoenix",
			// 	url: "http://www.discgolfbirmingham.com/wordpress/wp-content/uploads/2014/04/phoenix-rising.jpg"
			// }
		],
	};

	d20plus.art.getArtHandout = () => {
		return d20.Campaign.handouts.models.find((handout) => {
			return handout.attributes.name === ART_HANDOUT;
		});
	};

	d20plus.art.pLoadArt = async () => {
		d20plus.ut.log("Loading custom art");
		const handout = d20plus.art.getArtHandout();
		if (handout) {
			handout.view.render();
			return new Promise(resolve => {
				handout._getLatestBlob("gmnotes", function (gmnotes) {
					const decoded = decodeURIComponent(gmnotes);
					try {
						d20plus.art.custom = JSON.parse(decoded);
						resolve();
					} catch (e) {
						// eslint-disable-next-line no-console
						console.error(e);
						resolve();
					}
				});
			});
		}
	};

	d20plus.art.addCustomArtSearch = () => {
		d20plus.ut.log("Add custom art search");
		const $afterTo = $(`#libraryresults`);
		$afterTo.after(d20plus.artListHTML);

		const $olNone = $(`#image-search-none`);
		const $olHasResults = $(`#image-search-has-results`);

		const $olArt = $(`#custom-art-results`);
		const $srchImages = $(`#imagedialog .searchbox input.keywords`);
		$srchImages.on("keyup", () => {
			$olArt.empty();
			const searched = $srchImages.val().trim().toLowerCase();
			if (searched.length < 2) {
				$olNone.show();
				$olHasResults.hide();
				return;
			}

			let toShow = d20plus.art.default.filter(a => a.name.toLowerCase().includes(searched));
			if (d20plus.art.custom) toShow = toShow.concat(d20plus.art.custom.filter(a => a.name.toLowerCase().includes(searched)));

			if (!toShow.length) {
				$olNone.show();
				$olHasResults.hide();
			} else {
				$olNone.hide();
				$olHasResults.show();

				toShow.forEach(a => {
					$olArt.append(`
						<li class="dd-item library-item draggableresult Vetoolsresult ui-draggable" data-fullsizeurl="${a.url}">
							<div class="dd-content">
								<div class="token"><img src="${a.url}" draggable="false"></div>
								<div class="name">
									<div class="namecontainer"><a href="${a.url}" rel="external">${a.name}</a></div>
								</div>
							</div>
						</li>
					`);
				});
			}

			$("#imagedialog #Vetoolsresults .draggableresult").draggable({
				handle: ".dd-content",
				revert: true,
				revertDuration: 0,
				helper: "clone",
				appendTo: "body",
			}).addTouch();
		});
	};

	d20plus.art.initArtFromUrlButtons = () => {
		d20plus.ut.log("Add direct URL art buttons");
		// requires templates to be swapped, which happens ASAP during Init

		$(`.character-image-by-url`).live("click", function () {
			const cId = $(this).closest(`[data-characterid]`).attr(`data-characterid`);
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				d20.Campaign.characters.get(cId).set("avatar", url);
			}
		});

		$(`.handout-image-by-url`).live("click", function () {
			const hId = $(this).closest(`[data-handoutid]`).attr(`data-handoutid`);
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				d20.Campaign.handouts.get(hId).set("avatar", url);
			}
		});

		$(`.token-image-by-url`).live("click", function () {
			const cId = $(this).closest(`[data-characterid]`).attr(`data-characterid`);
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				const char = d20.Campaign.characters.get(cId);
				char._getLatestBlob("defaulttoken", (blob) => {
					blob = blob && blob.trim() ? JSON.parse(blob) : {};
					blob.imgsrc = url;
					char.updateBlobs({defaulttoken: JSON.stringify(blob)});
				});
			}
		});

		$(`.deck-image-by-url`).live("click", function () {
			const dId = $(this).attr("data-deck-id");
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				d20.Campaign.decks.get(dId).set("avatar", url)
			}
		});

		$(`.card-image-by-url`).live("click", function () {
			const cId = $(this).attr("data-card-id");
			const url = window.prompt("Enter a URL", d20plus.art.getLastImageUrl());
			if (url) {
				d20plus.art.setLastImageUrl(url);
				const card = d20.Campaign.decks.find(it => it.cards.find(c => c.id === cId)).cards.find(c => c.id === cId);
				card.set("avatar", url);
			}
		});

		$(`.deck-mass-cards-by-url`).live("click", function () {
			const dId = $(this).attr("data-deck-id");

			const deck = d20.Campaign.decks.get(dId);

			const cleanTemplate = d20plus.addArtMassAdderHTML.replace(/id="[^"]+"/gi, "");
			const $dialog = $(cleanTemplate).appendTo($("body"));
			const $iptTxt = $dialog.find(`textarea`);
			const $btnAdd = $dialog.find(`button`).click(() => {
				const lines = ($iptTxt.val() || "").split("\n");
				const toSaveAll = [];
				lines.filter(it => it && it.trim()).forEach(l => {
					const split = l.split("---").map(it => it.trim()).filter(Boolean);
					if (split.length >= 2) {
						const [name, url] = split;
						const toSave = deck.cards.push({
							avatar: url,
							id: d20plus.ut.generateRowId(),
							name,
							placement: 99,
						});
						toSaveAll.push(toSave);
					}
				});
				$dialog.dialog("close");

				toSaveAll.forEach(s => s.save());
				deck.save();
			});

			$dialog.dialog({
				width: 800,
				height: 650,
			});
		});
	};

	d20plus.art._lastImageUrl = "https://example.com/pic.png";
	d20plus.art.getLastImageUrl = () => {
		return d20plus.art._lastImageUrl;
	};
	d20plus.art.setLastImageUrl = (url) => {
		d20plus.art._lastImageUrl = url || d20plus.art._lastImageUrl;
	};
}

SCRIPT_EXTENSIONS.push(d20plusArt);


function d20plusArtBrowser () {
	d20plus.artBrowse = {};

	// ART IMPORTER 2.0
	d20plus.artBrowse.initRepoBrowser = () => {
		const TIME = (new Date()).getTime();
		const STATES = ["0", "1", "2"]; // off, blue, red

		function pGetJson (url) { // avoid using the main site method's caching
			return new Promise(resolve => $.getJSON(url, data => resolve(data)));
		}

		const $win = $(`<div title="BetteR20 - Art Repository" class="artr__win"/>`)
			.appendTo($(`body`))
			.dialog({
				autoOpen: false,
				resizable: true,
				width: 1,
				height: 1,
			})
			// bind droppable, so that elements dropped back onto the browser don't get caught by the canvas behind
			.droppable({
				accept: ".draggableresult",
				tolerance: "pointer",
				drop: (event, ui) => {
					event.preventDefault();
					event.stopPropagation();
					event.originalEvent.dropHandled = true;
					d20plus.ut.log(`Dropped back onto art browser!`);
				},
			});

		async function doInit () {
			const $sidebar = $(`<div class="artr__side"/>`).appendTo($win);
			const $mainPane = $(`<div class="artr__main"/>`).appendTo($win);
			const $loadings = [
				$(`<div class="artr__side__loading" title="Caching repository data, this may take some time">Loading...</div>`).appendTo($sidebar),
				$(`<div class="artr__main__loading" title="Caching repository data, this may take some time">Loading...</div>`).appendTo($mainPane),
			];

			const start = (new Date()).getTime();
			const GH_PATH = `https://raw.githubusercontent.com/DMsGuild201/Roll20_resources/master/ExternalArt/dist/`;
			const [enums, index] = await Promise.all([pGetJson(`${GH_PATH}_meta_enums.json`), pGetJson(`${GH_PATH}_meta_index.json`)]);
			d20plus.ut.log(`Loaded metadata in ${((new Date()).getTime() - start) / 1000} secs.`);

			Object.keys(index).forEach(k => index[k]._key = k);

			let filters = {};
			let search = "";
			let currentItem = null;
			let currentIndexKey = null;

			function _searchFeatures (item, doLowercase) {
				// features are lowercase in index
				return !!(item.features || []).find(x => (doLowercase ? x.toLowerCase() : x).includes(search));
			}

			function _filterProps (item) {
				if (Object.keys(filters).length) {
					const missingOrUnwanted = Object.keys(filters).find(prop => {
						if (!item[prop]) return true;
						const requiredVals = Object.keys(filters[prop]).filter(k => filters[prop][k]);
						const missingEnum = !!requiredVals.find(x => !item[prop].includes(x));
						const excludedVals = Object.keys(filters[prop]).filter(k => !filters[prop][k]);
						const unwantedEnum = !!excludedVals.find(x => item[prop].includes(x));
						return missingEnum || unwantedEnum;
					});
					if (missingOrUnwanted) return false;
				}
				return true;
			}

			function applyFilterAndSearchToIndex () {
				search = search.toLowerCase();

				// require the user to search or apply a filter before displaying any results
				if (Object.keys(filters).length === 0 && search.length < 2) return [];

				return Object.values(index).filter(it => {
					if (search) {
						const searchVisible = it._set.toLowerCase().includes(search)
							|| it._artist.toLowerCase().includes(search)
							|| _searchFeatures(it);
						if (!searchVisible) return false;
					}
					return _filterProps(it, 1);
				});
			}

			function applyFilterAndSearchToItem () {
				const cpy = MiscUtil.copy(currentItem);
				const filterItem = $cbMirrorFilters.prop("checked");
				cpy.data = cpy.data.filter(it => {
					if (search) if (!_searchFeatures(it, true)) return false;
					if (filterItem) return _filterProps(it);
					return true;
				});
				return cpy;
			}

			$loadings.forEach($l => $l.remove());

			// SIDEBAR /////////////////////////////////////////////////////////////////////////////////////////
			const $sideHead = $(`<div class="p-2 artr__side__head"><div class="artr__side__head__title">Filters</div></div>`).appendTo($sidebar);
			// This functionality is contained in the filter buttons, but might need to be done here to improve performance in the future
			// $(`<button class="btn">Apply</button>`).click(() => {
			// 	if (currentItem) doRenderItem(applyFilterAndSearchToItem());
			// 	else doRenderIndex(applyFilterAndSearchToIndex())
			// }).appendTo($sideHead);
			const $lbMirrorFilters = $(`<label class="split" title="Apply filters to results inside folders (as well as the index)"><span>Filter within folders</span></label>`).appendTo($sideHead);
			const $cbMirrorFilters = $(`<input type="checkbox" checked>`).appendTo($lbMirrorFilters).change(() => {
				if (currentItem) {
					doRenderItem(applyFilterAndSearchToItem());
				}
			});

			const $sideBody = $(`<div class="artr__side__body"/>`).appendTo($sidebar);
			const addSidebarSection = (prop, ix) => {
				const fullName = (() => {
					switch (prop) {
						case "imageType": return "Image Type";
						case "grid": return "Grid Type";
						case "monster": return "Monster Type";
						case "audience": return "Intended Audience";
						default:
							return prop.uppercaseFirst();
					}
				})();

				const $tagHead = $(`<div class="artr__side__tag_header"><div>${fullName}</div><div>[\u2013]</div></div>`).appendTo($sideBody).click(() => {
					$tagGrid.toggle();
					$tagHead.html($tagHead.html().replace(/\[.]/, (...m) => m[0] === "[+]" ? "[\u2013]" : "[+]"));
				});

				const $tagGrid = $(`<div class="artr__side__tag_grid"/>`).appendTo($sideBody);
				const getNextState = (state, dir) => {
					const ix = STATES.indexOf(state) + dir;
					if (ix > STATES.length - 1) return STATES[0];
					if (ix < 0) return STATES.last();
					return STATES[ix];
				};

				if (ix) $tagHead.click(); // hide by default

				enums[prop].sort((a, b) => SortUtil.ascSort(b.c, a.c)).forEach(enm => {
					const cycleState = dir => {
						const nxtState = getNextState($btn.attr("data-state"), dir);
						$btn.attr("data-state", nxtState);

						if (nxtState === "0") {
							delete filters[prop][enm.v];
							if (!Object.keys(filters[prop]).length) delete filters[prop];
						} else (filters[prop] = filters[prop] || {})[enm.v] = nxtState === "1";

						if (currentItem) doRenderItem(applyFilterAndSearchToItem());
						else doRenderIndex(applyFilterAndSearchToIndex());
					};

					const $btn = $(`<button class="btn artr__side__tag" data-state="0">${enm.v} (${enm.c})</button>`)
						.click(() => cycleState(1))
						.contextmenu((evt) => {
							if (!evt.ctrlKey) {
								evt.preventDefault();
								cycleState(-1);
							}
						})
						.appendTo($tagGrid);
				});
			};
			Object.keys(enums).forEach((k, i) => addSidebarSection(k, i));

			// MAIN PAGE ///////////////////////////////////////////////////////////////////////////////////////
			const $mainHead = $(`<div class="p-2 artr__search"/>`).appendTo($mainPane);

			const $wrpBread = $(`<div class="artr__bread"/>`).appendTo($mainHead);
			const updateCrumbs = () => {
				$wrpBread.empty();
				const $txtIndex = $(`<span class="artr__crumb btn">Index</span>`)
					.appendTo($wrpBread)
					.click(() => doRenderIndex(applyFilterAndSearchToIndex()));

				if (currentItem) {
					const $txtSlash = $(`<span class="artr__crumb artr__crumb--sep">/</span>`).appendTo($wrpBread);
					const $txtItem = $(`<span class="artr__crumb btn">${currentItem.set} \u2013 ${currentItem.artist}</span>`)
						.appendTo($wrpBread)
						.click(() => {
							$iptSearch.val("");
							search = "";
							doRenderItem(applyFilterAndSearchToItem(), true);
						});
				}
			};
			updateCrumbs();

			let searchTimeout;
			const doSearch = () => {
				search = ($iptSearch.val() || "").trim();
				if (currentItem) doRenderItem(applyFilterAndSearchToItem());
				else doRenderIndex(applyFilterAndSearchToIndex())
			};
			const $iptSearch = $(`<input placeholder="Search..." class="artr__search__field">`).on("keydown", (e) => {
				clearTimeout(searchTimeout);
				if (e.which === 13) {
					doSearch();
				} else {
					searchTimeout = setTimeout(() => {
						doSearch();
					}, 100);
				}
			}).appendTo($mainHead);

			const $mainBody = $(`<div class="artr__view"/>`).appendTo($mainPane);
			const $mainBodyInner = $(`<div class="artr__view_inner"/>`).appendTo($mainBody);

			const $itemBody = $(`<div class="artr__view"/>`).hide().appendTo($mainPane);
			const $itemBodyInner = $(`<div class="artr__view_inner"/>`).appendTo($itemBody);

			function doRenderIndex (indexSlice) {
				currentItem = false;
				currentIndexKey = false;
				$mainBody.show();
				$itemBody.hide();
				$mainBodyInner.empty();
				updateCrumbs();

				if (!indexSlice.length) {
					$(`<div class="artr__no_results_wrp"><div class="artr__no_results"><div class="text-center"><span class="artr__no_results_headline">No results found</span><br>Please adjust the filters (on the left) or refine your search (above).</div></div></div>`).appendTo($mainBodyInner)
				} else {
					indexSlice.forEach(it => {
						const $item = $(`<div class="artr__item artr__item--index"/>`).appendTo($mainBodyInner).click(() => doLoadAndRenderItem(it));

						const $itemTop = $(`
							<div class="artr__item__top artr__item__top--quart">
								${[...new Array(4)].map((_, i) => `<div class="atr__item__quart">${it._sample[i] ? `<img class="artr__item__thumbnail" src="${GH_PATH}${it._key}--thumb-${it._sample[i]}.jpg">` : ""}</div>`).join("")}
							</div>
						`).appendTo($item);

						const $itemStats = $(`<div class="artr__item__stats"/>`).appendTo($itemTop);
						const $statsImages = $(`<div class="artr__item__stats_item help--subtle" title="Number of images">×${it._size.toLocaleString()}</div>`).appendTo($itemStats);

						const $itemMenu = $(`<div class="artr__item__menu"/>`).appendTo($itemTop);
						const $btnExternalArt = $(`<div class="artr__item__menu_item pictos btn" title="Add to External Art list (${it._size} image${it._size === 1 ? "" : "s"})">P</div>`)
							.appendTo($itemMenu)
							.click(async (evt) => {
								evt.stopPropagation();
								const file = await pGetJson(`${GH_PATH}${it._key}.json`);
								const toAdd = file.data.map((it, i) => ({
									name: `${file.set} \u2014 ${file.artist} (${i})`,
									url: it.uri,
								}));
								d20plus.art.addToHandout(toAdd);
								alert(`Added ${file.data.length} image${file.data.length === 1 ? "" : "s"} to the External Art list.`);
							});
						const $btnDownload = $(`<div class="artr__item__menu_item pictos btn" title="Download ZIP (SHIFT to download a text file of URLs)">}</div>`)
							.appendTo($itemMenu)
							.click(async (evt) => {
								evt.stopPropagation();
								const file = await pGetJson(`${GH_PATH}${it._key}.json`);
								if (evt.shiftKey) {
									d20plus.artBrowse._downloadUrls(file);
								} else {
									d20plus.artBrowse._downloadZip(file);
								}
							});

						const $itemBottom = $(`
							<div class="artr__item__bottom">
								<div class="artr__item__bottom__row" style="padding-bottom: 2px;" title="${it._set}">${it._set}</div>
								<div class="artr__item__bottom__row" style="padding-top: 2px;" title="${it._artist}"><i>By</i> ${it._artist}</div>
							</div>
						`).appendTo($item);
					});
				}
			}

			function doLoadAndRenderItem (indexItem) {
				pGetJson(`${GH_PATH}${indexItem._key}.json`).then(file => {
					currentItem = file;
					currentIndexKey = indexItem._key;
					doRenderItem(applyFilterAndSearchToItem(), true);
				});
			}

			function doRenderItem (file, resetScroll) {
				$mainBody.hide();
				$itemBody.show();
				$itemBodyInner.empty();
				updateCrumbs();
				if (resetScroll) $itemBodyInner.scrollTop(0);
				const $itmUp = $(`<div class="artr__item artr__item--item artr__item--back"><div class="pictos">[</div></div>`)
					.click(() => doRenderIndex(applyFilterAndSearchToIndex()))
					.appendTo($itemBodyInner);

				file.data.sort((a, b) => SortUtil.ascSort(a.hash, b.hash)).forEach((it, i) => {
					// "library-item" and "draggableresult" classes required for drag/drop
					const $item = $(`<div class="artr__item artr__item--item library-item draggableresult" data-fullsizeurl="${it.uri}"/>`)
						.appendTo($itemBodyInner)
						.click(() => {
							const $wrpBigImg = $(`<div class="artr__wrp_big_img"><img class="artr__big_img" src="${it.uri}"></div>`)
								.click(() => $wrpBigImg.remove()).appendTo($(`body`));
						});
					const $wrpImg = $(`<div class="artr__item__full"/>`).appendTo($item);
					const $img = $(`<img class="artr__item__thumbnail" src="${GH_PATH}${currentIndexKey}--thumb-${it.hash}.jpg">`).appendTo($wrpImg);

					const $itemMenu = $(`<div class="artr__item__menu"/>`).appendTo($item);
					const $btnExternalArt = $(`<div class="artr__item__menu_item pictos" title="Add to External Art list">P</div>`)
						.appendTo($itemMenu)
						.click((evt) => {
							evt.stopPropagation();
							d20plus.art.addToHandout([{name: `${file.set} \u2014 ${file.artist} (${i})`, url: it.uri}]);
							alert(`Added image to the External Art list.`);
						});
					const $btnDownload = $(`<div class="artr__item__menu_item pictos" title="Download">}</div>`)
						.appendTo($itemMenu)
						.click((evt) => {
							evt.stopPropagation();
							window.open(it.uri, "_blank");
						});
					const $btnCopyUrl = $(`<div class="artr__item__menu_item pictos" title="Copy URL">A</div>`)
						.appendTo($itemMenu)
						.click(async (evt) => {
							evt.stopPropagation();
							await MiscUtil.pCopyTextToClipboard(it.uri);
							JqueryUtil.showCopiedEffect($btnDownload, "Copied URL!");
						});
					if (it.support) {
						const $btnSupport = $(`<div class="artr__item__menu_item pictos" title="Support Artist">$</div>`)
							.appendTo($itemMenu)
							.click((evt) => {
								evt.stopPropagation();
								window.open(it.support, "_blank");
							});
					}

					$item.draggable({
						handle: ".artr__item",
						revert: true,
						revertDuration: 0,
						helper: "clone",
						appendTo: "body",
					});
				});
			}

			doRenderIndex(applyFilterAndSearchToIndex());
		}

		let firstClick = true;
		const calcWidth = () => {
			const base = d20.engine.canvasWidth * 0.66;
			return (Math.ceil((base - 300) / 190) * 190) + 320;
		};
		const $btnBrowse = $(`#button-browse-external-art`).click(() => {
			$win.dialog(
				"option",
				{
					width: calcWidth(),
					height: d20.engine.canvasHeight - 100,
					position: {
						my: "left top",
						at: "left+75 top+15",
						collision: "none",
					},
				},
			).dialog("open");

			if (firstClick) {
				doInit();
				firstClick = false;
			}
		});
	};

	d20plus.artBrowse._downloadZip = async item => {
		function doCreateIdChat (str, isError) {
			const uid = d20plus.ut.generateRowId();
			d20.textchat.incoming(false, ({
				who: "system",
				type: "system",
				content: `<span id="${uid}" class="hacker-chat inline-block ${isError ? "is-error" : ""}">${str}</span>`,
			}));
			return uid;
		}

		function doUpdateIdChat (id, str, isError = false) {
			$(`#userscript-${id}`).toggleClass("is-error", isError).html(str);
		}

		let isHandled = false;
		function handleCancel (id) {
			if (isHandled) return;
			isHandled = true;
			doUpdateIdChat(id, "Download cancelled.");
		}

		function pAjaxLoad (url) {
			const oReq = new XMLHttpRequest();
			const p = new Promise((resolve, reject) => {
				// FIXME cors-anywhere has a usage limit, which is pretty easy to hit when downloading many files
				oReq.open("GET", `https://cors-anywhere.herokuapp.com/${url}`, true);
				oReq.responseType = "arraybuffer";
				let lastContentType = null;
				oReq.onreadystatechange = () => {
					const h = oReq.getResponseHeader("content-type");
					if (h) {
						lastContentType = h;
					}
				};
				oReq.onload = function () {
					const arrayBuffer = oReq.response;
					resolve({buff: arrayBuffer, contentType: lastContentType});
				};
				oReq.onerror = (e) => reject(new Error(`Error during request: ${e}`));
				oReq.send();
			});
			p.abort = () => oReq.abort();
			return p;
		}

		$(`#rightsidebar a[href="#textchat"]`).click();
		const chatId = doCreateIdChat(`Download starting...`);
		let isCancelled = false;
		let downloadTasks = [];
		const $btnStop = $(`<button class="btn btn-danger Ve-btn-chat" id="button-${chatId}">Stop</button>`)
			.insertAfter($(`#userscript-${chatId}`))
			.click(() => {
				isCancelled = true;
				downloadTasks.forEach(p => p.abort());
				handleCancel(chatId);
				$btnStop.remove();
			});
		// eslint-disable-next-line no-console
		try { $btnStop[0].scrollIntoView() } catch (e) { console.error(e) }

		if (isCancelled) return handleCancel(chatId);

		try {
			const toSave = [];
			let downloaded = 0;
			let errorCount = 0;

			const getWrappedPromise = dataItem => {
				const pAjax = pAjaxLoad(dataItem.uri);
				// eslint-disable-next-line no-async-promise-executor
				const p = new Promise(async resolve => {
					try {
						const data = await pAjax;
						toSave.push(data);
					} catch (e) {
						d20plus.ut.error(`Error downloading "${dataItem.uri}":`, e);
						++errorCount;
					}
					++downloaded;
					doUpdateIdChat(chatId, `Downloading ${downloaded}/${item.data.length}... (${Math.floor(100 * downloaded / item.data.length)}%)${errorCount ? ` (${errorCount} error${errorCount === 1 ? "" : "s"})` : ""}`);
					resolve();
				});
				p.abort = () => pAjax.abort();
				return p;
			};

			downloadTasks = item.data.map(dataItem => getWrappedPromise(dataItem));
			await Promise.all(downloadTasks);

			if (isCancelled) return handleCancel(chatId);

			doUpdateIdChat(chatId, `Building ZIP...`);

			const zip = new JSZip();
			toSave.forEach((data, i) => {
				const extension = (data.contentType || "unknown").split("/").last();
				zip.file(`${`${i}`.padStart(3, "0")}.${extension}`, data.buff, {binary: true});
			});

			if (isCancelled) return handleCancel(chatId);

			zip.generateAsync({type: "blob"})
				.then((content) => {
					if (isCancelled) return handleCancel(chatId);

					doUpdateIdChat(chatId, `Downloading ZIP...`);
					d20plus.ut.saveAs(content, d20plus.ut.sanitizeFilename(`${item.set}__${item.artist}`));
					doUpdateIdChat(chatId, `Download complete.`);
					$btnStop.remove();
				});
		} catch (e) {
			doUpdateIdChat(chatId, `Download failed! Error was: ${e.message}<br>Check the log for more information.`, true);
			// eslint-disable-next-line no-console
			console.error(e);
		}
	};

	d20plus.artBrowse._downloadUrls = async item => {
		const contents = item.data.map(it => it.uri).join("\n");
		const blob = new Blob([contents], {type: "text/plain"});
		d20plus.ut.saveAs(blob, d20plus.ut.sanitizeFilename(`${item.set}__${item.artist}`));
	};
}

SCRIPT_EXTENSIONS.push(d20plusArtBrowser);


function initOverwrites () {
	d20plus.overwrites = {};
}

SCRIPT_EXTENSIONS.push(initOverwrites);


function initCanvasHandlerOverwrite () {
	/**
	 * Dumb variable names copy-pasted from uglified code
	 * @param c x co-ord
	 * @param u y c-ord
	 * @returns {*[]} 2-len array; [0] = x and [1] = y
	 */
	function getClosestHexPoint (c, u) {
		function getEuclidDist (x1, y1, x2, y2) {
			return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
		}

		const hx = d20.canvas_overlay.activeHexGrid.GetHexAt({
			X: c,
			Y: u,
		});

		let minDist = 1000000;
		let minPoint = [c, u];

		function checkDist (x1, y1) {
			const dist = getEuclidDist(x1, y1, c, u);
			if (dist < minDist) {
				minDist = dist;
				minPoint = [x1, y1];
			}
		}
		hx.Points.forEach(pt => {
			checkDist(pt.X, pt.Y);
		});
		checkDist(hx.MidPoint.X, hx.MidPoint.Y);

		return minPoint;
	}

	const canvasHandlerDown = function (e) {
		/* eslint-disable */

		// BEGIN MOD
		var cnv = d20.engine.canvas;
		var wrp = $("#editor-wrapper");
		const $finalCanvas = $(d20.engine.final_canvas);
		// END MOD
		var i, n;
		if (d20.tddice && d20.tddice.handleInteraction && d20.tddice.handleInteraction(),
			e.touches) {
			if ("pan" == d20.engine.mode)
				return;
			e.touches.length > 1 && (A = d20.engine.mode,
				d20.engine.mode = "pan",
				d20.engine.leftMouseIsDown = !0),
				d20.engine.lastTouchStarted = (new Date).getTime(),
				i = e.touches[0].pageX,
				n = e.touches[0].pageY,
				e.preventDefault()
		} else
			i = e.pageX,
				n = e.pageY;
		for (var o = d20.engine.showLastPaths.length; o--;)
			"selected" == d20.engine.showLastPaths[o].type && d20.engine.showLastPaths.splice(o, 1);
		d20.engine.handleMetaKeys(e),
		"select" != d20.engine.mode && "path" != d20.engine.mode || cnv.__onMouseDown(e),
		(0 === e.button || e.touches && 1 == e.touches.length) && (d20.engine.leftMouseIsDown = !0),
		2 === e.button && (d20.engine.rightMouseIsDown = !0);
		var r = Math.floor(i / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] / d20.engine.canvasZoom)
			,
			a = Math.floor(n / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] / d20.engine.canvasZoom);
		if (d20.engine.lastMousePos = [r, a],
			d20.engine.mousePos = [r, a],
		!d20.engine.leftMouseIsDown || "fog-reveal" != d20.engine.mode && "fog-hide" != d20.engine.mode && "gridalign" != d20.engine.mode) {
			if (d20.engine.leftMouseIsDown && "fog-polygonreveal" == d20.engine.mode) {
				// BEGIN MOD
				var s = r
					, c = a;

				if (0 != d20.engine.snapTo && (e.shiftKey && !d20.Campaign.activePage().get("adv_fow_enabled") || !e.shiftKey && d20.Campaign.activePage().get("adv_fow_enabled"))) {
					if ("square" == d20.Campaign.activePage().get("grid_type")) {
						s = d20.engine.snapToIncrement(s, d20.engine.snapTo)
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo)
					} else {
						const minPoint = getClosestHexPoint(s, c);
						s = minPoint[0];
						c = minPoint[1];
					}
				}

				d20.engine.fog.points.length > 0 && Math.abs(d20.engine.fog.points[0][0] - s) + Math.abs(d20.engine.fog.points[0][1] - c) < 15 ? (d20.engine.fog.points.push([d20.engine.fog.points[0][0], d20.engine.fog.points[0][1]]),
					d20.engine.finishPolygonReveal()) : d20.engine.fog.points.push([s, c]),
					d20.engine.redrawScreenNextTick(!0)
				// END MOD
			} else if (d20.engine.leftMouseIsDown && "measure" == d20.engine.mode)
				if (2 === e.button)
					d20.engine.addWaypoint(e);
				else {
					d20.engine.measure.sticky && d20.engine.endMeasure(),
						d20.engine.measure.down[0] = r,
						d20.engine.measure.down[1] = a,
						d20.engine.measure.sticky = e.shiftKey;
					const t = d20.Campaign.activePage().get("grid_type");
					let i = "snap_center" === d20.engine.ruler_snapping && !e.altKey;
					if (i |= "no_snap" === d20.engine.ruler_snapping && e.altKey,
						i &= 0 !== d20.engine.snapTo)
						if ("square" === t)
							d20.engine.measure.down[1] = d20.engine.snapToIncrement(d20.engine.measure.down[1] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2),
								d20.engine.measure.down[0] = d20.engine.snapToIncrement(d20.engine.measure.down[0] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2);
						else {
							const e = d20.canvas_overlay.activeHexGrid.GetHexAt({
								X: d20.engine.measure.down[0],
								Y: d20.engine.measure.down[1]
							});
							e && (d20.engine.measure.down[1] = e.MidPoint.Y,
								d20.engine.measure.down[0] = e.MidPoint.X)
						}
					else if (0 === d20.engine.snapTo || "snap_corner" !== d20.engine.ruler_snapping || e.altKey)
						d20.engine.measure.flags |= 1;
					else {
						if ("square" === t)
							d20.engine.measure.down[0] = d20.engine.snapToIncrement(d20.engine.measure.down[0], d20.engine.snapTo),
								d20.engine.measure.down[1] = d20.engine.snapToIncrement(d20.engine.measure.down[1], d20.engine.snapTo);
						else {
							const e = d20.engine.snapToHexCorner([d20.engine.measure.down[0], d20.engine.measure.down[1]]);
							e && (d20.engine.measure.down[0] = e[0],
								d20.engine.measure.down[1] = e[1])
						}
						d20.engine.measure.flags |= 1
					}
				}
			else if (d20.engine.leftMouseIsDown && "fxtools" == d20.engine.mode)
				d20.engine.fx.current || (d20.engine.fx.current = d20.fx.handleClick(r, a));
			else if (d20.engine.leftMouseIsDown && "text" == d20.engine.mode) {
				const e = {
					fontFamily: $("#font-family").val(),
					fontSize: $("#font-size").val(),
					fill: $("#font-color").val(),
					text: "",
					left: r,
					top: a
				}
					, t = d20.Campaign.activePage().addText(e);
				$("body").on("mouseup.create_text_editor", () => {
						$("body").off("mouseup.create_text_editor"),
							d20.engine.editText(t.view.graphic, e.top, e.left),
							$(".texteditor").focus()
					}
				)
			} else if (d20.engine.leftMouseIsDown && "rect" == d20.engine.mode) {
				var u = parseInt($("#path_width").val(), 10)
					, h = d20.engine.drawshape.shape = {
					strokewidth: u,
					x: 0,
					y: 0,
					width: 10,
					height: 10,
					type: e.altKey ? "circle" : "rect"
				};
				s = r,
					c = a;
				0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
					c = d20.engine.snapToIncrement(c, d20.engine.snapTo)),
					h.x = s,
					h.y = c,
					h.fill = $("#path_fillcolor").val(),
					h.stroke = $("#path_strokecolor").val(),
					d20.engine.drawshape.start = [i + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0], n + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1]],
					d20.engine.redrawScreenNextTick()
			} else if (d20.engine.leftMouseIsDown && "ellipse" == d20.engine.mode) {
				var u = parseInt($("#path_width").val(), 10)
					, h = d20.engine.drawshape.shape = {
					strokewidth: u,
					x: 0,
					y: 0,
					width: 10,
					height: 10,
					type: "circle"
				};
				s = r,
					c = a;
				0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
					c = d20.engine.snapToIncrement(c, d20.engine.snapTo)),
					h.x = s,
					h.y = c,
					h.fill = $("#path_fillcolor").val(),
					h.stroke = $("#path_strokecolor").val(),
					d20.engine.drawshape.start = [i + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0], n + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1]],
					d20.engine.redrawScreenNextTick()
			} else if (d20.engine.leftMouseIsDown && "polygon" == d20.engine.mode) {
				if (d20.engine.drawshape.shape) h = d20.engine.drawshape.shape;
				else {
					u = parseInt($("#path_width").val(), 10);
					(h = d20.engine.drawshape.shape = {
						strokewidth: u,
						points: [],
						type: "polygon"
					}).fill = $("#path_fillcolor").val(),
						h.stroke = $("#path_strokecolor").val()
				}

				// BEGIN MOD
				s = r, c = a;

				if (0 != d20.engine.snapTo && e.shiftKey) {
					if ("square" == d20.Campaign.activePage().get("grid_type")) {
						s = d20.engine.snapToIncrement(s, d20.engine.snapTo);
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo);
					} else {
						const minPoint = getClosestHexPoint(s, c);
						s = minPoint[0];
						c = minPoint[1];
					}
				}

				h.points.length > 0 && Math.abs(h.points[0][0] - s) + Math.abs(h.points[0][1] - c) < 15 ? (h.points.push([h.points[0][0], h.points[0][1]]),
						d20.engine.finishCurrentPolygon()) : h.points.push([s, c]),
					d20.engine.redrawScreenNextTick()
				// END MOD
			} else if (d20.engine.leftMouseIsDown && "targeting" === d20.engine.mode) {
				var p = d20.engine.canvas.findTarget(e, !0, !0);
				return void (p !== undefined && "image" === p.type && p.model && d20.engine.nextTargetCallback(p))
			}
			// BEGIN MOD
			else if (d20.engine.leftMouseIsDown && "line_splitter" === d20.engine.mode) {
				const lastPoint = {
					x: d20.engine.lastMousePos[0],
					y: d20.engine.lastMousePos[1]
				};
				(d20.engine.canvas._objects || []).forEach(o => {
					if (o.type === "path" && o.containsPoint(lastPoint)) {
						const asObj = o.toObject();
						const anyCurves = asObj.path.filter(it => it instanceof Array && it.length > 0 && it[0] === "C");
						if (!anyCurves.length) {
							// PathMath expects these
							o.model.set("_pageid", d20.Campaign.activePage().get("id"));
							o.model.set("_path", JSON.stringify(o.path));

							console.log("SPLITTING PATH: ", o.model.toJSON());
							const mainPath = o.model;

							// BEGIN PathSplitter CODE
							let mainSegments = PathMath.toSegments(mainPath);
							// BEGIN MOD
							const SLICE_LEN = 10;
							const slicePoint1 = [lastPoint.x + (SLICE_LEN / 2), lastPoint.y + (SLICE_LEN / 2), 1];
							const slicePoint2 = [lastPoint.x - (SLICE_LEN / 2), lastPoint.y - (SLICE_LEN / 2), 1];
							setTimeout(() => {
								d20.engine.redrawScreenNextTick();
							}, 1);

							let splitSegments = [
								[slicePoint1, slicePoint2]
							];
							// END MOD
							let segmentPaths = _getSplitSegmentPaths(mainSegments, splitSegments);

							// (function moved into this scope)
							function _getSplitSegmentPaths(mainSegments, splitSegments) {
								let resultSegPaths = [];
								let curPathSegs = [];

								_.each(mainSegments, seg1 => {

									// Find the points of intersection and their parametric coefficients.
									let intersections = [];
									_.each(splitSegments, seg2 => {
										let i = PathMath.segmentIntersection(seg1, seg2);
										if (i) intersections.push(i);
									});

									if (intersections.length > 0) {
										// Sort the intersections in the order that they appear along seg1.
										intersections.sort((a, b) => {
											return a[1] - b[1];
										});

										let lastPt = seg1[0];
										_.each(intersections, i => {
											// Complete the current segment path.
											curPathSegs.push([lastPt, i[0]]);
											resultSegPaths.push(curPathSegs);

											// Start a new segment path.
											curPathSegs = [];
											lastPt = i[0];
										});
										curPathSegs.push([lastPt, seg1[1]]);
									} else {
										curPathSegs.push(seg1);
									}
								});
								resultSegPaths.push(curPathSegs);

								return resultSegPaths;
							};
							// (end function moved into this scope)

							// Convert the list of segment paths into paths.
							let _pageid = mainPath.get('_pageid');
							let controlledby = mainPath.get('controlledby');
							let fill = mainPath.get('fill');
							let layer = mainPath.get('layer');
							let stroke = mainPath.get('stroke');
							let stroke_width = mainPath.get('stroke_width');

							let results = [];
							_.each(segmentPaths, segments => {
								// BEGIN MOD
								if (!segments) {
									d20plus.chatLog(`A path had no segments! This is probably a bug. Please report it.`);
									return;
								}
								// END MOD

								let pathData = PathMath.segmentsToPath(segments);
								_.extend(pathData, {
									_pageid,
									controlledby,
									fill,
									layer,
									stroke,
									stroke_width
								});
								let path = createObj('path', pathData);
								results.push(path);
							});

							// Remove the original path and the splitPath.
							// BEGIN MOD
							mainPath.destroy();
							// END MOD
							// END PathSplitter CODE
						}
					}
				});
			}
			// END MOD
		} else
			d20.engine.fog.down[0] = r,
				d20.engine.fog.down[1] = a,
			0 != d20.engine.snapTo && "square" == d20.Campaign.activePage().get("grid_type") && ("gridalign" == d20.engine.mode ? e.shiftKey && (d20.engine.fog.down[0] = d20.engine.snapToIncrement(d20.engine.fog.down[0], d20.engine.snapTo),
				d20.engine.fog.down[1] = d20.engine.snapToIncrement(d20.engine.fog.down[1], d20.engine.snapTo)) : (e.shiftKey && !d20.Campaign.activePage().get("adv_fow_enabled") || !e.shiftKey && d20.Campaign.activePage().get("adv_fow_enabled")) && (d20.engine.fog.down[0] = d20.engine.snapToIncrement(d20.engine.fog.down[0], d20.engine.snapTo),
				d20.engine.fog.down[1] = d20.engine.snapToIncrement(d20.engine.fog.down[1], d20.engine.snapTo)));
		if (window.currentPlayer && d20.engine.leftMouseIsDown && "select" == d20.engine.mode) {
			if (2 === e.button && d20.engine.addWaypoint(e),
			d20.engine.pings[window.currentPlayer.id] && d20.engine.pings[window.currentPlayer.id].radius > 20)
				return;
			var f = {
				left: r,
				top: a,
				radius: -5,
				player: window.currentPlayer.id,
				pageid: d20.Campaign.activePage().id,
				currentLayer: window.currentEditingLayer
			};
			window.is_gm && e.shiftKey && (f.scrollto = !0),
				d20.engine.pings[window.currentPlayer.id] = f,
				d20.engine.pinging = {
					downx: i,
					downy: n
				},
				d20.engine.redrawScreenNextTick(!0)
		}

		const g = ["select", "path", "text", "fxtools", "measure", "rect", "ellipse"];
		d20.engine.rightMouseIsDown && g.includes(d20.engine.mode) || d20.engine.leftMouseIsDown && "pan" === d20.engine.mode ? (d20.engine.pan.beginPos = [wrp.scrollLeft(), wrp.scrollTop()],
			d20.engine.pan.panXY = [i, n],
			d20.engine.pan.panning = !0,
			// BEGIN MOD
			$finalCanvas.css("cursor", "grabbing")) : d20.engine.pan.panning = !1,
			// END MOD
		2 === e.button && !d20.engine.leftMouseIsDown && d20.engine.measurements[window.currentPlayer.id] && d20.engine.measurements[window.currentPlayer.id].sticky && (d20.engine.endMeasure(),
			d20.engine.announceEndMeasure({
				player: window.currentPlayer.id
			}));

		// BEGIN MOD
		$finalCanvas.hasClass("hasfocus") || $finalCanvas.focus();
		// END MOD

		/* eslint-enable */
	}

	const canvasHandlerMove = function (e) {
		/* eslint-disable */

		// BEGIN MOD
		var cnv = d20.engine.canvas;
		var wrp = $("#editor-wrapper");
		const $selMeasureMode = $(`#measure_mode`);
		const $selRadMode = $(`#measure_mode_sel_2`);
		const $iptConeWidth = $(`#measure_mode_ipt_3`);
		const $selConeMode = $(`#measure_mode_sel_3`);
		const $selBoxMode = $(`#measure_mode_sel_4`);
		const $selLineMode = $(`#measure_mode_sel_5`);
		const $iptLineWidth = $(`#measure_mode_ipt_5`);
		// END MOD

		var t, i;
		if (e.changedTouches ? ((e.changedTouches.length > 1 || "pan" == d20.engine.mode) && (delete d20.engine.pings[window.currentPlayer.id],
			d20.engine.pinging = !1),
			e.preventDefault(),
			t = e.changedTouches[0].pageX,
			i = e.changedTouches[0].pageY) : (t = e.pageX,
			i = e.pageY),
		"select" != d20.engine.mode && "path" != d20.engine.mode && "targeting" != d20.engine.mode || cnv.__onMouseMove(e),
		d20.engine.leftMouseIsDown || d20.engine.rightMouseIsDown) {
			var n = Math.floor(t / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] / d20.engine.canvasZoom)
				, o = Math.floor(i / d20.engine.canvasZoom + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] / d20.engine.canvasZoom);
			if (d20.engine.mousePos = [n, o],
			!d20.engine.leftMouseIsDown || "fog-reveal" !== d20.engine.mode && "fog-hide" !== d20.engine.mode && "gridalign" !== d20.engine.mode) {
				if (d20.engine.leftMouseIsDown && "measure" == d20.engine.mode && d20.engine.measure.down[0] !== undefined && d20.engine.measure.down[1] !== undefined) {
					d20.engine.measure.down[2] = n,
						d20.engine.measure.down[3] = o,
						d20.engine.measure.sticky |= e.shiftKey;
					const t = d20.Campaign.activePage().get("grid_type")
						, i = "snap_corner" === d20.engine.ruler_snapping && !e.altKey && 0 !== d20.engine.snapTo;
					let a = "snap_center" === d20.engine.ruler_snapping && !e.altKey;
					if (a |= "no_snap" === d20.engine.ruler_snapping && e.altKey,
						a &= 0 !== d20.engine.snapTo) {
						if ("square" === t)
							d20.engine.measure.down[2] = d20.engine.snapToIncrement(d20.engine.measure.down[2] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2),
								d20.engine.measure.down[3] = d20.engine.snapToIncrement(d20.engine.measure.down[3] + Math.floor(d20.engine.snapTo / 2), d20.engine.snapTo) - Math.floor(d20.engine.snapTo / 2);
						else {
							const e = d20.canvas_overlay.activeHexGrid.GetHexAt({
								X: d20.engine.measure.down[2],
								Y: d20.engine.measure.down[3]
							});
							e && (d20.engine.measure.down[3] = e.MidPoint.Y,
								d20.engine.measure.down[2] = e.MidPoint.X)
						}
						d20.engine.measure.flags &= -3
					} else if (i) {
						if ("square" === t)
							d20.engine.measure.down[2] = d20.engine.snapToIncrement(d20.engine.measure.down[2], d20.engine.snapTo),
								d20.engine.measure.down[3] = d20.engine.snapToIncrement(d20.engine.measure.down[3], d20.engine.snapTo);
						else {
							const e = d20.engine.snapToHexCorner([d20.engine.measure.down[2], d20.engine.measure.down[3]]);
							e && (d20.engine.measure.down[2] = e[0],
								d20.engine.measure.down[3] = e[1])
						}
						d20.engine.measure.flags |= 2
					} else
						d20.engine.measure.flags |= 2;
					var r = {
						x: d20.engine.measure.down[0],
						y: d20.engine.measure.down[1],
						to_x: d20.engine.measure.down[2],
						to_y: d20.engine.measure.down[3],
						player: window.currentPlayer.id,
						pageid: d20.Campaign.activePage().id,
						currentLayer: window.currentEditingLayer,
						waypoints: d20.engine.measure.waypoints,
						sticky: d20.engine.measure.sticky,
						flags: d20.engine.measure.flags,
						hide: d20.engine.measure.hide

						// BEGIN MOD
						,
						Ve: {
							mode: $selMeasureMode.val(),
							radius: {
								mode: $selRadMode.val()
							},
							cone: {
								arc: $iptConeWidth.val(),
								mode: $selConeMode.val()
							},
							box: {
								mode: $selBoxMode.val(),
							},
							line: {
								mode: $selLineMode.val(),
								width: $iptLineWidth.val()
							}
						}
						// END MOD
					};
					d20.engine.announceMeasure(r)
				} else if (d20.engine.leftMouseIsDown && "fxtools" == d20.engine.mode) {
					if (d20.engine.fx.current) {
						var a = (new Date).getTime();
						a - d20.engine.fx.lastMoveBroadcast > d20.engine.fx.MOVE_BROADCAST_FREQ ? (d20.fx.moveFx(d20.engine.fx.current, n, o),
							d20.engine.fx.lastMoveBroadcast = a) : d20.fx.moveFx(d20.engine.fx.current, n, o, !0)
					}
				} else if (d20.engine.leftMouseIsDown && "rect" == d20.engine.mode) {
					var s = (t + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] - d20.engine.drawshape.start[0]) / d20.engine.canvasZoom
						, c = (i + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] - d20.engine.drawshape.start[1]) / d20.engine.canvasZoom;
					0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo));
					var u = d20.engine.drawshape.shape;
					u.width = s,
						u.height = c,
						d20.engine.redrawScreenNextTick()
				} else if (d20.engine.leftMouseIsDown && "ellipse" == d20.engine.mode) {
					var s = (t + d20.engine.currentCanvasOffset[0] - d20.engine.paddingOffset[0] - d20.engine.drawshape.start[0]) / d20.engine.canvasZoom
						, c = (i + d20.engine.currentCanvasOffset[1] - d20.engine.paddingOffset[1] - d20.engine.drawshape.start[1]) / d20.engine.canvasZoom;
					0 != d20.engine.snapTo && e.shiftKey && (s = d20.engine.snapToIncrement(s, d20.engine.snapTo),
						c = d20.engine.snapToIncrement(c, d20.engine.snapTo));
					var u = d20.engine.drawshape.shape;
					u.width = s,
						u.height = c,
						d20.engine.redrawScreenNextTick()
				}
			} else
				d20.engine.fog.down[2] = n,
					d20.engine.fog.down[3] = o,
				0 !== d20.engine.snapTo && "square" === d20.Campaign.activePage().get("grid_type") && ("gridalign" === d20.engine.mode ? e.shiftKey && (d20.engine.fog.down[2] = d20.engine.snapToIncrement(d20.engine.fog.down[2], d20.engine.snapTo),
					d20.engine.fog.down[3] = d20.engine.snapToIncrement(d20.engine.fog.down[3], d20.engine.snapTo)) : (e.shiftKey && !d20.Campaign.activePage().get("adv_fow_enabled") || !e.shiftKey && d20.Campaign.activePage().get("adv_fow_enabled")) && (d20.engine.fog.down[2] = d20.engine.snapToIncrement(d20.engine.fog.down[2], d20.engine.snapTo),
					d20.engine.fog.down[3] = d20.engine.snapToIncrement(d20.engine.fog.down[3], d20.engine.snapTo))),
					d20.engine.redrawScreenNextTick(!0);
			if (d20.engine.pinging)
				(s = Math.abs(d20.engine.pinging.downx - t)) + (c = Math.abs(d20.engine.pinging.downy - i)) > 10 && (delete d20.engine.pings[window.currentPlayer.id],
					d20.engine.pinging = !1);
			if (d20.engine.pan.panning) {
				s = 2 * (t - d20.engine.pan.panXY[0]),
					c = 2 * (i - d20.engine.pan.panXY[1]);
				if (d20.engine.pan.lastPanDist += Math.abs(s) + Math.abs(c),
				d20.engine.pan.lastPanDist < 10)
					return;
				var h = d20.engine.pan.beginPos[0] - s
					, p = d20.engine.pan.beginPos[1] - c;
				wrp.stop().animate({
					scrollLeft: h,
					scrollTop: p
				}, {
					duration: 1,
					easing: "linear",
					queue: !1
				})
			}
		}

		/* eslint-enable */
	}

	d20plus.overwrites.canvasHandlerDown = canvasHandlerDown
	d20plus.overwrites.canvasHandlerMove = canvasHandlerMove
}
SCRIPT_EXTENSIONS.push(initCanvasHandlerOverwrite);


function d20plusEngine () {
	d20plus.engine = {};

	d20plus.engine.addProFeatures = () => {
		d20plus.ut.log("Add Pro features");

		d20plus.setMode = d20plus.mod.setMode;
		window.setMode = d20plus.mod.setMode;

		// rebind buttons with new setMode
		const $drawTools = $("#drawingtools");
		const $rect = $drawTools.find(".chooserect");
		const $ellipse = $drawTools.find(".choosecircle");
		const $path = $drawTools.find(".choosepath");
		const $poly = $drawTools.find(".choosepolygon");
		$drawTools.unbind(clicktype).bind(clicktype, function () {
			$(this).hasClass("rect") ? setMode("rect") : $(this).hasClass("ellipse") ? setMode("ellipse") : $(this).hasClass("text") ? setMode("text") : $(this).hasClass("path") ? setMode("path") : $(this).hasClass("drawselect") ? setMode("drawselect") : $(this).hasClass("polygon") && setMode("polygon")
		});
		$rect.unbind(clicktype).bind(clicktype, () => {
			setMode("rect");
			return false;
		});
		$ellipse.unbind(clicktype).bind(clicktype, () => {
			setMode("ellipse");
			return false;
		});
		$path.unbind(clicktype).bind(clicktype, () => {
			setMode("path");
			return false;
		});
		$poly.unbind(clicktype).bind(clicktype, () => {
			setMode("polygon");
			return false;
		});
		$("#rect").unbind(clicktype).bind(clicktype, () => setMode("rect"));
		$("#ellipse").unbind(clicktype).bind(clicktype, () => setMode("ellipse"));
		$("#path").unbind(clicktype).bind(clicktype, () => setMode("path"));

		if (!$(`#fxtools`).length) {
			const $fxMode = $(`<li id="fxtools"/>`).append(`<span class="pictos">e</span>`);
			$fxMode.on("click", () => {
				d20plus.setMode("fxtools");
			});
			$(`#drawingtools`).after($fxMode);
		}

		if (window.is_gm) {
			// add lighting layer tool
			if (!$(`#editinglayer .choosewalls`).length) {
				$(`#editinglayer .choosegmlayer`).after(`<li class="choosewalls"><span class="pictostwo">r</span> Dynamic Lighting</li>`);
			}

			// ensure tokens have editable sight
			$("#tmpl_tokeneditor").replaceWith(d20plus.templates.templateTokenEditor);
			// show dynamic lighting/etc page settings
			$("#tmpl_pagesettings").replaceWith(d20plus.templates.templatePageSettings);
			$("#page-toolbar").on("mousedown", ".js__settings-page", function () {
				let e = d20.Campaign.pages.get($(this).parents(".availablepage").attr("data-pageid"));
				e.view._template = $.jqotec("#tmpl_pagesettings");
			});
		}
	};

	d20plus.engine._removeStatusEffectEntries = () => {
		$(`#5etools-status-css`).html("");
		Object.keys(d20.token_editor.statusmarkers).filter(k => k.startsWith("5etools_")).forEach(k => delete d20.token_editor.statusmarkers[k]);
	};

	d20plus.engine.enhanceStatusEffects = () => {
		d20plus.ut.log("Enhance status effects");
		$(`head`).append(`<style id="5etools-status-css"/>`);

		d20plus.mod.overwriteStatusEffects();

		d20.engine.canvas.off("object:added");
		d20.engine.canvas.on("object:added", d20plus.mod.overwriteStatusEffects);

		// the holy trinity
		// d20.engine.canvas.on("object:removed", () => console.log("added"));
		// d20.engine.canvas.on("object:removed", () => console.log("removed"));
		// d20.engine.canvas.on("object:modified", () => console.log("modified"));

		$(document).off("mouseenter", ".markermenu");
		$(document).on("mouseenter", ".markermenu", d20plus.mod.mouseEnterMarkerMenu)
	};

	d20plus.engine.enhancePageSelector = () => {
		d20plus.ut.log("Enhancing page selector");

		let updatePageOrder = function () {
			d20plus.ut.log("Saving page order...");
			let pos = 0;
			$("#page-toolbar .pages .chooseablepage").each(function () {
				let page = d20.Campaign.pages.get($(this).attr("data-pageid"));
				page && page.save({
					placement: pos,
				});
				pos++;
			});
			d20.pagetoolbar.noReload = false;
			d20.pagetoolbar.refreshPageListing();
		};

		function overwriteDraggables () {
			// make them draggable on both axes
			$("#page-toolbar .pages").sortable("destroy");
			$("#page-toolbar .pages").sortable({
				items: "> .chooseablepage",
				start: function () {
					d20.pagetoolbar.noReload = true;
				},
				stop: function () {
					updatePageOrder()
				},
				distance: 15,
			}).addTouch();
			$("#page-toolbar .playerbookmark").draggable("destroy");
			$("#page-toolbar .playerbookmark").draggable({
				revert: "invalid",
				appendTo: "#page-toolbar",
				helper: "original",
			}).addTouch();
			$("#page-toolbar .playerspecificbookmark").draggable("destroy");
			$("#page-toolbar .playerspecificbookmark").draggable({
				revert: "invalid",
				appendTo: "#page-toolbar",
				helper: "original",
			}).addTouch();
		}

		overwriteDraggables();
		$(`#page-toolbar`).css("top", "calc(-90vh + 40px)");

		const originalFn = d20.pagetoolbar.refreshPageListing;
		// original function is debounced at 100ms, so debounce this at 110ms and hope for the best
		const debouncedOverwrite = _.debounce(() => {
			overwriteDraggables();
			// fire an event for other parts of the script to listen for
			const pageChangeEvt = new Event(`VePageChange`);
			d20plus.ut.log("Firing page-change event");
			document.dispatchEvent(pageChangeEvt);
		}, 110);
		d20.pagetoolbar.refreshPageListing = () => {
			originalFn();
			debouncedOverwrite();
		}
	};

	d20plus.engine.initQuickSearch = ($iptSearch, $outSearch) => {
		$iptSearch.on("keyup", () => {
			const searchVal = ($iptSearch.val() || "").trim();
			$outSearch.empty();
			if (searchVal.length <= 2) return; // ignore 2 characters or less, for performance reasons
			const found = $(`#journal .content`).find(`li[data-itemid]`).filter((i, ele) => {
				const $ele = $(ele);
				return $ele.find(`.name`).text().trim().toLowerCase().includes(searchVal.toLowerCase());
			});
			if (found.length) {
				$outSearch.append(`<p><b>Search results:</b></p>`);
				const $outList = $(`<ol class="dd-list Vetools-search-results"/>`);
				$outSearch.append($outList);
				found.clone().addClass("Vetools-draggable").appendTo($outList);
				$outSearch.append(`<hr>`);
				$(`.Vetools-search-results .Vetools-draggable`).draggable({
					revert: true,
					distance: 10,
					revertDuration: 0,
					helper: "clone",
					handle: ".namecontainer",
					appendTo: "body",
					scroll: true,
					start: function () {
						$("#journalfolderroot").addClass("externaldrag")
					},
					stop: function () {
						$("#journalfolderroot").removeClass("externaldrag")
					},
				});
			}
		});
	};

	d20plus.engine.addSelectedTokenCommands = () => {
		d20plus.ut.log("Add token rightclick commands");
		$("#tmpl_actions_menu").replaceWith(d20plus.template_actionsMenu);

		const getTokenWhisperPart = () => d20plus.cfg.getOrDefault("token", "massRollWhisperName") ? "/w gm Rolling for @{selected|token_name}...\n" : "";

		Mousetrap.bind("b b", function () { // back on layer
			const n = d20plus.engine._getSelectedToMove();
			d20plus.engine.backwardOneLayer(n);
			return false;
		});

		Mousetrap.bind("b f", function () { // forward one layer
			const n = d20plus.engine._getSelectedToMove();
			d20plus.engine.forwardOneLayer(n);
			return false;
		});

		/**
		 * @param token A token.
		 * @return {number} 0 for unknown, 1 for NPC, 2 for PC.
		 */
		function getTokenType (token) {
			if (token && token.model && token.model.toJSON && token.model.toJSON().represents) {
				const charIdMaybe = token.model.toJSON().represents;
				if (!charIdMaybe) return 0; //
				const charMaybe = d20.Campaign.characters.get(charIdMaybe);
				if (charMaybe) {
					const atbs = charMaybe.attribs.toJSON();
					const npcAtbMaybe = atbs.find(it => it.name === "npc");

					if (npcAtbMaybe && Number(npcAtbMaybe.current) === 1) {
						return 1;
					} else {
						return 2;
					}
				} else return 0;
			} else return 0;
		}

		const lastContextSelection = {
			lastAnimUid: null,
			lastSceneUid: null,
		};

		/* eslint-disable */

		// BEGIN ROLL20 CODE
		var e, t = !1, n = [];
		var i = function() {
			t && (t.remove(),
				t = !1),
			e && clearTimeout(e)
		};
		var r = function (r) {
			var o, a;
			r.changedTouches && r.changedTouches.length > 0 ? (o = r.changedTouches[0].pageX,
				a = r.changedTouches[0].pageY) : (o = r.pageX,
				a = r.pageY),
				i(),
				n = [];
			for (var s = [], l = d20.engine.selected(), c = 0; c < l.length; c++)
				n.push(l[c]),
					s.push(l[c].type);
			if (s = _.uniq(s),
			n.length > 0)
				if (1 == s.length) {
					var u = n[0];
					t = $("image" == u.type && 0 == u.model.get("isdrawing") ? $("#tmpl_actions_menu").jqote(u.model) : $("#tmpl_actions_menu").jqote(u.model))
				} else {
					var u = n[0];
					t = $($("#tmpl_actions_menu").jqote(u.model))
				}
			else
				t = $($("#tmpl_actions_menu").jqote({}));
			if (!window.is_gm && t[0].lastElementChild.childElementCount < 1)
				return !1;
			t.appendTo("body");
			var d = t.height()
				, h = t.width()
				, p = {};
			return p.top = a > $("#editor-wrapper").height() - $("#playerzone").height() - d - 100 ? a - d + "px" : a + "px",
				p.left = o > $("#editor-wrapper").width() - h ? o + 10 - h + "px" : o + 10 + "px",
				t.css(p),
				$(".actions_menu").bind("mousedown mouseup touchstart", function(e) {
					e.stopPropagation()
				}),
				$(".actions_menu ul > li").bind("mouseover touchend", function() {
					if (e && (clearTimeout(e),
						e = !1),
					$(this).parents(".hasSub").length > 0)
						;
					else if ($(this).hasClass("hasSub")) {
						$(".actions_menu").css({
							width: "215px",
							height: "250px"
						});
						var t = this;
						_.defer(function() {
							$(".actions_menu ul.submenu").hide(),
								$(t).find("ul.submenu:hidden").show()
						})
					} else
						$(".actions_menu ul.submenu").hide()
				}),
				$(".actions_menu ul.submenu").live("mouseover", function() {
					e && (clearTimeout(e),
						e = !1)
				}),
				$(".actions_menu, .actions_menu ul.submenu").live("mouseleave", function() {
					e || (e = setTimeout(function() {
						$(".actions_menu ul.submenu").hide(),
							$(".actions_menu").css("width", "100px").css("height", "auto"),
							e = !1
					}, 500))
				}),
				$(".actions_menu li").on(clicktype, function() {
					var e = $(this).attr("data-action-type");
					if (null != e) {
						if ("copy" == e)
							d20.clipboard.doCopy(),
								i();
						else if ("paste" == e)
							d20.clipboard.doPaste(),
								i();
						else if ("delete" == e) {
							var t = d20.engine.selected();
							d20.engine.canvas.deactivateAllWithDispatch();
							for (var r = 0; r < t.length; r++)
								t[r].model.destroy();
							i()
						} else if ("undo" == e)
							d20.undo && d20.undo.doUndo(),
								i();
						else if ("tofront" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									d20.engine.canvas.bringToFront(e)
								}),
								d20.Campaign.activePage().debounced_recordZIndexes(),
								i();
						else if ("toback" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									d20.engine.canvas.sendToBack(e)
								}),
								d20.Campaign.activePage().debounced_recordZIndexes(),
								i();
						else if (-1 !== e.indexOf("tolayer_")) {
							d20.engine.unselect();
							var o = e.replace("tolayer_", "");
							_.each(n, function(e) {
								e.model.save({
									layer: o
								})
							}),
								i(),
								d20.token_editor.removeRadialMenu()
						} else if ("addturn" == e)
							_.each(n, function(e) {
								d20.Campaign.initiativewindow.addTokenToList(e.model.id)
							}),
								i(),
							d20.tutorial && d20.tutorial.active && $(document.body).trigger("addedTurn");
						else if ("group" == e) {
							var a = [];
							d20.engine.unselect(),
								_.each(n, function(e) {
									a.push(e.model.id)
								}),
								_.each(n, function(e) {
									e.model.addToGroup(a)
								}),
								i();
							var s = n[0];
							d20.engine.select(s)
						} else if ("ungroup" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.clearGroup()
								}),
								d20.token_editor.removeRadialMenu(),
								i();
						else if ("toggledrawing" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.set({
										isdrawing: !e.model.get("isdrawing")
									}).save()
								}),
								i(),
								d20.token_editor.removeRadialMenu();
						else if ("toggleflipv" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.set({
										flipv: !e.model.get("flipv")
									}).save()
								}),
								i(),
								d20.token_editor.removeRadialMenu();
						else if ("togglefliph" == e)
							d20.engine.unselect(),
								_.each(n, function(e) {
									e.model.set({
										fliph: !e.model.get("fliph")
									}).save()
								}),
								i(),
								d20.token_editor.removeRadialMenu();
						else if ("takecard" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									var t = d20.decks.cardByID(e.model.get("cardid"));
									if (e.model.get("isdrawing") === !1)
										var n = {
											bar1_value: e.model.get("bar1_value"),
											bar1_max: e.model.get("bar1_max"),
											bar2_value: e.model.get("bar2_value"),
											bar2_max: e.model.get("bar2_max"),
											bar3_value: e.model.get("bar3_value"),
											bar3_max: e.model.get("bar3_max")
										};
									d20.Campaign.hands.addCardToHandForPlayer(t, window.currentPlayer, n ? n : void 0),
										_.defer(function() {
											e.model.destroy()
										})
								}),
								d20.engine.unselect(),
								i();
						else if ("flipcard" == e)
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
								_.each(n, function(e) {
									var t = e.model.get("sides").split("|")
										, n = e.model.get("currentSide")
										, i = n + 1;
									i > t.length - 1 && (i = 0),
										e.model.set({
											currentSide: i,
											imgsrc: unescape(t[i])
										}).save()
								}),
								i();
						else if ("setdimensions" == e) {
							var l = n[0]
								, c = $($("#tmpl_setdimensions").jqote()).dialog({
								title: "Set Dimensions",
								width: 325,
								height: 225,
								buttons: {
									Set: function() {
										var e, t;
										"pixels" == c.find(".dimtype").val() ? (e = parseInt(c.find("input.width").val(), 10),
											t = parseInt(c.find("input.height").val(), 10)) : (e = parseFloat(c.find("input.width").val()) * window.dpi,
											t = parseFloat(c.find("input.height").val()) * window.dpi),
											l.model.save({
												width: e,
												height: t
											}),
											c.off("change"),
											c.dialog("destroy").remove()
									},
									Cancel: function() {
										c.off("change"),
											c.dialog("destroy").remove()
									}
								},
								beforeClose: function() {
									c.off("change"),
										c.dialog("destroy").remove()
								}
							});
							c.on("change", ".dimtype", function() {
								"pixels" == $(this).val() ? (c.find("input.width").val(Math.round(l.get("width"))),
									c.find("input.height").val(Math.round(l.get("height")))) : (c.find("input.width").val(l.get("width") / window.dpi),
									c.find("input.height").val(l.get("height") / window.dpi))
							}),
								c.find(".dimtype").trigger("change"),
								i()
						} else if ("aligntogrid" == e)
							if (0 === d20.Campaign.activePage().get("snapping_increment")) {
								i();
								var u = $($("#tmpl_grid-disabled").jqote(h)).dialog({
									title: "Grid Off",
									buttons: {
										Ok: function() {
											u.off("change"),
												u.dialog("destroy").remove()
										}
									},
									beforeClose: function() {
										u.off("change"),
											u.dialog("destroy").remove()
									}
								})
							} else
								d20.engine.gridaligner.target = n[0],
									d20plus.setMode("gridalign"),
									i();
						else if ("side_random" == e) {
							d20.engine.canvas.getActiveGroup() && d20.engine.unselect();
							var d = [];
							_.each(n, function(e) {
								if (e.model && "" != e.model.get("sides")) {
									var t = e.model.get("sides").split("|")
										, n = t.length
										, i = d20.textchat.diceengine.random(n);
									// BEGIN MOD
									const imgUrl = unescape(t[i]);
									e.model.save(getRollableTokenUpdate(imgUrl, i)),
									// END MOD
										d.push(t[i])
								}
							}),
								d20.textchat.rawChatInput({
									type: "tokenroll",
									content: d.join("|")
								}),
								i()
						} else if ("side_choose" == e) {
							const e = n[0]
								, t = e.model.toJSON()
								, o = t.sides.split("|");
							let r = t.currentSide;
							const a = $($("#tmpl_chooseside").jqote()).dialog({
								title: "Choose Side",
								width: 325,
								height: 225,
								buttons: {
									Choose: function() {
										const imgUrl = unescape(o[r]);
										d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
											// BEGIN MOD
											e.model.save(getRollableTokenUpdate(imgUrl, r)),
											// END MOD
											a.off("slide"),
											a.dialog("destroy").remove()
									},
									Cancel: function() {
										a.off("slide"),
											a.dialog("destroy").remove()
									}
								},
								beforeClose: function() {
									a.off("slide"),
										a.dialog("destroy").remove()
								}
							})
								, s = a.find(".sidechoices");
							for (const e of o) {
								const t = unescape(e);
								let n = d20.utils.isVideo(t) ? `<video src="${t.replace("/med.webm", "/thumb.webm")}" muted autoplay loop />` : `<img src="${t}" />`;
								n = `<div class="sidechoice">${n}</div>`,
									s.append(n)
							}
							s.children().attr("data-selected", !1).eq(r).attr("data-selected", !0),
								a.find(".sideslider").slider({
									min: 0,
									max: o.length - 1,
									step: 1,
									value: r
								}),
								a.on("slide", function(e, t) {
									t.value != r && (r = t.value,
										a.find(".sidechoices .sidechoice").attr("data-selected", !1).eq(t.value).attr("data-selected", !0))
								}),
								i(),
								d20.token_editor.removeRadialMenu()
						}
						// BEGIN MOD
						const showRollOptions = (formula, options) => {
							const sel = d20.engine.selected();

							options = options.map(it => `<option>${it}</option>`);

							const dialog= $("<div><p style='font-size: 1.15em;'><strong>" + d20.utils.strip_tags("Select Save") + ":</strong> <select style='width: 150px; margin-left: 5px;'>" + options.join("") + "</select></p></div>");

							dialog.dialog({
								title: "Input Value",
								beforeClose: function() {
									return false;
								},
								buttons: {
									Submit: function() {
										const val = dialog.find("select").val();
										console.log(val);
										d20.engine.unselect();
										sel.forEach(it => {
											d20.engine.select(it);
											const toRoll = formula(it, val);
											d20.textchat.doChatInput(toRoll);
											d20.engine.unselect();
										});

										dialog.off();
										dialog.dialog("destroy").remove();
										d20.textchat.$textarea.focus();
									},
									Cancel: function() {
										dialog.off();
										dialog.dialog("destroy").remove();
									}
								}
							});

							i();
						};

						if ("rollsaves" === e) {
							// Mass roll: Saves
							const options = ["str", "dex", "con", "int", "wis", "cha"].map(it => Parser.attAbvToFull(it));
							if (d20plus.sheet === "ogl") {
								showRollOptions(
									(token, val) => {
										if (getTokenType(token) === 1) {
											const short = val.substring(0, 3);
											return `${getTokenWhisperPart()}@{selected|wtype}&{template:npc} @{selected|npc_name_flag} {{type=Save}} @{selected|rtype} + [[@{selected|npc_${short.toLowerCase()}_save}]][${short.toUpperCase()}]]]}} {{rname=${val} Save}} {{r1=[[1d20 + [[@{selected|npc_${short.toLowerCase()}_save}]][${short.toUpperCase()}]]]}}`;
										} else {
											return `@{selected|wtype} &{template:simple} {{charname=@{selected|token_name}}} {{always=1}} {{rname=${val} Save}} {{mod=@{selected|${val.toLowerCase()}_save_bonus}}} {{r1=[[1d20+@{selected|${val.toLowerCase()}_save_bonus}]]}} {{r2=[[1d20+@{selected|${val.toLowerCase()}_save_bonus}]]}}`;
										}
									},
									options
								);
							}
							else if (d20plus.sheet === "shaped") {
								showRollOptions(
									(token, val) => `@{selected|output_option}} &{template:5e-shaped} {{ability=1}} {{character_name=@{selected|token_name}}} {{title=${val} Save}} {{mod=@{selected|${val.toLowerCase()}_mod}}} {{roll1=[[1d20+@{selected|${val.toLowerCase()}_mod}]]}} {{roll2=[[1d20+@{selected|${val.toLowerCase()}_mod}]]}}`,
									options
								);
							}
						} else if ("rollinit" === e) {
							// Mass roll: Initiative
							const sel = d20.engine.selected();
							d20.engine.unselect();
							sel.forEach(it => {
								d20.engine.select(it);
								let toRoll = ``;
								if (d20plus.sheet === "ogl") {
									toRoll = `%{selected|Initiative}`;
								} else if (d20plus.sheet === "shaped") {
									toRoll = `@{selected|output_option} &{template:5e-shaped} {{ability=1}} {{title=INITIATIVE}} {{roll1=[[@{selected|initiative_formula}]]}}`;
								}
								d20.textchat.doChatInput(toRoll);
								d20.engine.unselect();
							});
							i();
						} else if ("rollskills" === e) {
							// TODO a "roll abilitiy check" option? NPC macro: @{selected|wtype}&{template:npc} @{selected|npc_name_flag} {{type=Check}} @{selected|rtype} + [[@{selected|strength_mod}]][STR]]]}} {{rname=Strength Check}} {{r1=[[1d20 + [[@{selected|strength_mod}]][STR]]]}}

							// Mass roll: Skills
							const options = [
								"Athletics",
								"Acrobatics",
								"Sleight of Hand",
								"Stealth",
								"Arcana",
								"History",
								"Investigation",
								"Nature",
								"Religion",
								"Animal Handling",
								"Insight",
								"Medicine",
								"Perception",
								"Survival",
								"Deception",
								"Intimidation",
								"Performance",
								"Persuasion"
							].sort();

							showRollOptions(
								(token, val) => {
									const clean = val.toLowerCase().replace(/ /g, "_");
									const abil = `${Parser.attAbvToFull(Parser.skillToAbilityAbv(val.toLowerCase())).toLowerCase()}_mod`;

									let doRoll = '';
									if (d20plus.sheet === "ogl") {
										doRoll = (atb = abil) => {
											if (getTokenType(token) === 1) {
												const slugged = val.replace(/\s/g, "_").toLowerCase();
												return `${getTokenWhisperPart()}@{selected|wtype}&{template:npc} @{selected|npc_name_flag} {{type=Skill}} @{selected|rtype} + [[@{selected|npc_${slugged}}]]]]}}; {{rname=${val}}}; {{r1=[[1d20 + [[@{selected|npc_${slugged}}]]]]}}
`
											} else {
												return `@{selected|wtype} &{template:simple} {{charname=@{selected|token_name}}} {{always=1}} {{rname=${val}}} {{mod=@{selected|${atb}}}} {{r1=[[1d20+@{selected|${atb}}]]}} {{r2=[[1d20+@{selected|${atb}}]]}}`;
											}
										}
									} else if (d20plus.sheet === "shaped"){
										doRoll = (atb = abil) => {
											return `@{selected|output_option} &{template:5e-shaped} {{ability=1}} {{character_name=@{selected|token_name}}} {{title=${val}}} {{mod=@{selected|${atb}}}} {{roll1=[[1d20+@{selected|${atb}}]]}} {{roll2=[[1d20+@{selected|${atb}}]]}}`;
										}
									}

									try {
										if (token && token.model && token.model.toJSON && token.model.toJSON().represents) {
											const charIdMaybe = token.model.toJSON().represents;
											if (!charIdMaybe) return doRoll();
											const charMaybe = d20.Campaign.characters.get(charIdMaybe);
											if (charMaybe) {
												const atbs = charMaybe.attribs.toJSON();
												const npcAtbMaybe = atbs.find(it => it.name === "npc");

												if (npcAtbMaybe && npcAtbMaybe.current == 1) {
													const npcClean = `npc_${clean}`;
													const bonusMaybe = atbs.find(it => it.name === npcClean);
													if (bonusMaybe) return doRoll(npcClean);
													else return doRoll();
												} else {
													const pcClean = `${clean}_bonus`;
													const bonusMaybe = atbs.find(it => it.name === pcClean);
													if (bonusMaybe) return doRoll(pcClean);
													else return doRoll();
												}
											} else return doRoll();
										} else return doRoll();
									} catch (x) {
										console.error(x);
										return doRoll();
									}
								},
								options
							);
						} else if ("forward-one" === e) {
							d20plus.engine.forwardOneLayer(n);
							i();
						} else if ("back-one" === e) {
							d20plus.engine.backwardOneLayer(n);
							i();
						} else if ("rollertokenresize" === e) {
							resizeToken();
							i();
						} else if ("copy-tokenid" === e) {
							const sel = d20.engine.selected();
							window.prompt("Copy to clipboard: Ctrl+C, Enter", sel[0].model.id);
							i();
						} else if ("copy-pathid" === e) {
							const sel = d20.engine.selected();
							window.prompt("Copy to clipboard: Ctrl+C, Enter", sel[0].model.id);
							i();
						} else if ("token-fly" === e) {
							const sel = d20.engine.selected().filter(it => it && it.type === "image");
							new Promise((resolve, reject) => {
								const $dialog = $(`
									<div title="Flight Height">
										<input type="number" placeholder="Flight height" name="flight">
									</div>
								`).appendTo($("body"));
								const $iptHeight = $dialog.find(`input[name="flight"]`).on("keypress", evt => {
									if (evt.which === 13) { // return
										doHandleOk();
									}
								});

								const doHandleOk = () => {
									const selected = Number($iptHeight.val());
									$dialog.dialog("close");
									if (isNaN(selected)) reject(`Value "${$iptHeight.val()}" was not a number!`);
									else resolve(selected);
								};

								$dialog.dialog({
									dialogClass: "no-close",
									buttons: [
										{
											text: "Cancel",
											click: function () {
												$(this).dialog("close");
												$dialog.remove();
												reject(`User cancelled the prompt`);
											}
										},
										{
											text: "OK",
											click: function () {
												doHandleOk();
											}
										}
									]
								});
							}).then(num => {
								const STATUS_PREFIX = `fluffy-wing@`;
								const statusString = `${num}`.split("").map(it => `${STATUS_PREFIX}${it}`).join(",");
								sel.forEach(s => {
									const existing = s.model.get("statusmarkers");
									if (existing && existing.trim()) {
										s.model.set("statusmarkers", [statusString, ...existing.split(",").filter(it => it && it && !it.startsWith(STATUS_PREFIX))].join(","));
									} else {
										s.model.set("statusmarkers", statusString);
									}
									s.model.save();
								});
							});
							i();
						} else if ("token-light" === e) {
							const SOURCES = {
								"None (Blind)": {
									bright: 0,
									dim: 0
								},
								"Torch/Light (Spell)": {
									bright: 20,
									dim: 20
								},
								"Lamp": {
									bright: 15,
									dim: 30
								},
								"Lantern, Bullseye": {
									bright: 60,
									dim: 60,
									angle: 30
								},
								"Lantern, Hooded": {
									bright: 30,
									dim: 30
								},
								"Lantern, Hooded (Dimmed)": {
									bright: 0,
									dim: 5
								},
								"Candle": {
									bright: 5,
									dim: 5
								},
								"Darkvision": {
									bright: 0,
									dim: 60,
									hidden: true
								},
								"Superior Darkvision": {
									bright: 0,
									dim: 120,
									hidden: true
								}
							};

							const sel = d20.engine.selected().filter(it => it && it.type === "image");
							new Promise((resolve, reject) => {
								const $dialog = $(`
									<div title="Light">
										<label class="flex">
											<span>Set Light Style</span>
											 <select style="width: 250px;">
												${Object.keys(SOURCES).map(it => `<option>${it}</option>`).join("")}
											</select>
										</label>
									</div>
								`).appendTo($("body"));
								const $selLight = $dialog.find(`select`);

								$dialog.dialog({
									dialogClass: "no-close",
									buttons: [
										{
											text: "Cancel",
											click: function () {
												$(this).dialog("close");
												$dialog.remove();
												reject(`User cancelled the prompt`);
											}
										},
										{
											text: "OK",
											click: function () {
												const selected = $selLight.val();
												$dialog.dialog("close");
												if (!selected) reject(`No value selected!`);
												else resolve(selected);
											}
										}
									]
								});
							}).then(key => {
								const light = SOURCES[key];

								const light_otherplayers = !light.hidden;
								// these are all stored as strings
								const dimRad = (light.dim || 0);
								const brightRad = (light.bright || 0);
								const totalRad = dimRad + brightRad;
								const light_angle = `${light.angle}` || "";
								const light_dimradius = `${totalRad - dimRad}`;
								const light_radius = `${totalRad}`;

								sel.forEach(s => {
									s.model.set("light_angle", light_angle);
									s.model.set("light_dimradius", light_dimradius);
									s.model.set("light_otherplayers", light_otherplayers);
									s.model.set("light_radius", light_radius);
									s.model.save();
								});
							});
							i();
						} else if ("unlock-tokens" === e) {
							d20plus.tool.get("UNLOCKER").openFn();
							i();
						} else if ("lock-token" === e) {
							d20.engine.selected().forEach(it => {
								if (it.model) {
									if (it.model.get("VeLocked")) {
										it.lockMovementX = false;
										it.lockMovementY = false;
										it.lockScalingX = false;
										it.lockScalingY = false;
										it.lockRotation = false;

										it.model.set("VeLocked", false);
									} else {
										it.lockMovementX = true;
										it.lockMovementY = true;
										it.lockScalingX = true;
										it.lockScalingY = true;
										it.lockRotation = true;

										it.model.set("VeLocked", true);
									}
									it.saveState();
									it.model.save();
								}
							});
							i();
						} else if ("token-animate" === e) {
							d20plus.anim.animatorTool.pSelectAnimation(lastContextSelection.lastAnimUid).then(animUid => {
								if (animUid == null) return;

								lastContextSelection.lastAnimUid = animUid;
								const selected = d20.engine.selected();
								d20.engine.unselect();
								selected.forEach(it => {
									if (it.model) {
										d20plus.anim.animator.startAnimation(it.model, animUid)
									}
								});
							});
							i();
						} else if ("util-scenes" === e) {
							d20plus.anim.animatorTool.pSelectScene(lastContextSelection.lastSceneUid).then(sceneUid => {
								if (sceneUid == null) return;

								lastContextSelection.lastSceneUid = sceneUid;
								d20plus.anim.animatorTool.doStartScene(sceneUid);
							});
							i();
						}
						// END MOD
						return !1
					}
				}),
				!1
		};
		// END ROLL20 CODE

		/* eslint-enable */

		function getRollableTokenUpdate (imgUrl, curSide) {
			const m = /\?roll20_token_size=(.*)/.exec(imgUrl);
			const toSave = {
				currentSide: curSide,
				imgsrc: imgUrl,
			};
			if (m) {
				toSave.width = 70 * Number(m[1]);
				toSave.height = 70 * Number(m[1])
			}
			return toSave;
		}

		function resizeToken () {
			const sel = d20.engine.selected();

			const options = [["Tiny", 0.5], ["Small", 1], ["Medium", 1], ["Large", 2], ["Huge", 3], ["Gargantuan", 4], ["Colossal", 5]].map(it => `<option value='${it[1]}'>${it[0]}</option>`);
			const dialog = $(`<div><p style='font-size: 1.15em;'><strong>${d20.utils.strip_tags("Select Size")}:</strong> <select style='width: 150px; margin-left: 5px;'>${options.join("")}</select></p></div>`);
			dialog.dialog({
				title: "New Size",
				beforeClose: function () {
					return false;
				},
				buttons: {
					Submit: function () {
						const size = dialog.find("select").val();
						d20.engine.unselect();
						sel.forEach(it => {
							const nxtSize = size * 70;
							const sides = it.model.get("sides");
							if (sides) {
								const ueSides = unescape(sides);
								const cur = it.model.get("currentSide");
								const split = ueSides.split("|");
								if (split[cur].includes("roll20_token_size")) {
									split[cur] = split[cur].replace(/(\?roll20_token_size=).*/, `$1${size}`);
								} else {
									split[cur] += `?roll20_token_size=${size}`;
								}
								const toSaveSides = split.map(it => escape(it)).join("|");
								const toSave = {
									sides: toSaveSides,
									width: nxtSize,
									height: nxtSize,
								};
								// eslint-disable-next-line no-console
								console.log(`Updating token:`, toSave);
								it.model.save(toSave);
							} else {
								// eslint-disable-next-line no-console
								console.warn("Token had no side data!")
							}
						});
						dialog.off();
						dialog.dialog("destroy").remove();
						d20.textchat.$textarea.focus();
					},
					Cancel: function () {
						dialog.off();
						dialog.dialog("destroy").remove();
					},
				},
			});
		}

		d20.token_editor.showContextMenu = r;
		d20.token_editor.closeContextMenu = i;
		$(`#editor-wrapper`).on("click", d20.token_editor.closeContextMenu);
	};

	/* eslint-disable */

	d20plus.engine._getSelectedToMove = () => {
		const n = [];
		for (var l = d20.engine.selected(), c = 0; c < l.length; c++)
			n.push(l[c]);
	};

	d20plus.engine.forwardOneLayer = (n) => {
		d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
			_.each(n, function (e) {
				d20.engine.canvas.bringForward(e)
			}),
			d20.Campaign.activePage().debounced_recordZIndexes()
	};

	d20plus.engine.backwardOneLayer = (n) => {
		d20.engine.canvas.getActiveGroup() && d20.engine.unselect(),
			_.each(n, function (e) {
				d20.engine.canvas.sendBackwards(e)
			}),
			d20.Campaign.activePage().debounced_recordZIndexes()
	};

	// previously "enhanceSnap"
	d20plus.engine.enhanceMouseDown = () => {
		const R = d20plus.overwrites.canvasHandlerDown

		if (FINAL_CANVAS_MOUSEDOWN_LIST.length) {
			FINAL_CANVAS_MOUSEDOWN = (FINAL_CANVAS_MOUSEDOWN_LIST.find(it => it.on === d20.engine.final_canvas) || {}).listener;
		}

		if (FINAL_CANVAS_MOUSEDOWN) {
			d20plus.ut.log("Enhancing hex snap");
			d20.engine.final_canvas.removeEventListener("mousedown", FINAL_CANVAS_MOUSEDOWN);
			d20.engine.final_canvas.addEventListener("mousedown", R);
		}

		// add sub-grid snap
		d20.engine.snapToIncrement = function(e, t) {
			t *= Number(d20plus.cfg.getOrDefault("canvas", "gridSnap"));
			return t * Math.round(e / t);
		}
	};

	d20plus.engine.enhanceMouseUp = () => { // P

	};

	// needs to be called after `enhanceMeasureTool()`
	d20plus.engine.enhanceMouseMove = () => {
		// add missing vars
		var i = d20.engine.canvas;

		// Roll20 bug (present as of 2019-5-25) workaround
		//   when box-selecting + moving tokens, the "object:moving" event throws an exception
		//   try-catch-ignore this, because it's extremely annoying
		const cachedFire = i.fire.bind(i);
		i.fire = function (namespace, opts) {
			if (namespace === "object:moving") {
				try {
					cachedFire(namespace, opts);
				} catch (e) {}
			} else {
				cachedFire(namespace, opts);
			}
		};

		const I = d20plus.overwrites.canvasHandlerMove

		if (FINAL_CANVAS_MOUSEMOVE_LIST.length) {
			FINAL_CANVAS_MOUSEMOVE = (FINAL_CANVAS_MOUSEMOVE_LIST.find(it => it.on === d20.engine.final_canvas) || {}).listener;
		}

		if (FINAL_CANVAS_MOUSEMOVE) {
			d20plus.ut.log("Enhancing mouse move");
			d20.engine.final_canvas.removeEventListener("mousemove", FINAL_CANVAS_MOUSEMOVE);
			d20.engine.final_canvas.addEventListener("mousemove", I);
		}
	};

	/* eslint-enable */

	d20plus.engine.addLineCutterTool = () => {
		const $btnTextTool = $(`.choosetext`);

		const $btnSplitTool = $(`<li class="choosesplitter">✂️ Line Splitter</li>`).click(() => {
			d20plus.setMode("line_splitter");
		});

		$btnTextTool.after($btnSplitTool);
	};

	d20plus.engine._tokenHover = null;
	d20plus.engine._drawTokenHover = () => {
		$(`.Vetools-token-hover`).remove();
		if (!d20plus.engine._tokenHover || !d20plus.engine._tokenHover.text) return;

		const pt = d20plus.engine._tokenHover.pt;
		const txt = unescape(d20plus.engine._tokenHover.text);

		$(`body`).append(`<div class="Vetools-token-hover" style="top: ${pt.y * d20.engine.canvasZoom}px; left: ${pt.x * d20.engine.canvasZoom}px">${txt}</div>`);
	};
	d20plus.engine.addTokenHover = () => {
		// gm notes on shift-hover
		const cacheRenderLoop = d20.engine.renderLoop;
		d20.engine.renderLoop = () => {
			d20plus.engine._drawTokenHover();
			cacheRenderLoop();
		};

		// store data for the rendering function to access
		d20.engine.canvas.on("mouse:move", (data, ...others) => {
			// enable hover from GM layer -> token layer
			let hoverTarget = data.target;
			if (data.e && window.currentEditingLayer === "gmlayer") {
				const cache = window.currentEditingLayer;
				window.currentEditingLayer = "objects";
				hoverTarget = d20.engine.canvas.findTarget(data.e, null, true);
				window.currentEditingLayer = cache;
			}

			if (data.e.shiftKey && hoverTarget && hoverTarget.model) {
				d20.engine.redrawScreenNextTick();
				const gmNotes = hoverTarget.model.get("gmnotes");
				const pt = d20.engine.canvas.getPointer(data.e);
				pt.x -= d20.engine.currentCanvasOffset[0];
				pt.y -= d20.engine.currentCanvasOffset[1];
				d20plus.engine._tokenHover = {
					pt: pt,
					text: gmNotes,
					id: hoverTarget.model.id,
				};
			} else {
				if (d20plus.engine._tokenHover) d20.engine.redrawScreenNextTick();
				d20plus.engine._tokenHover = null;
			}
		})
	};

	d20plus.engine.enhanceMarkdown = () => {
		const OUT_STRIKE = "<span style='text-decoration: line-through'>$1</span>";

		/* eslint-disable */

		// BEGIN ROLL20 CODE
		window.Markdown.parse = function(e) {
			{
				var t = e
					, n = []
					, i = [];
				-1 != t.indexOf("\r\n") ? "\r\n" : -1 != t.indexOf("\n") ? "\n" : ""
			}
			return t = t.replace(/{{{([\s\S]*?)}}}/g, function(e) {
				return n.push(e.substring(3, e.length - 3)),
					"{{{}}}"
			}),
				t = t.replace(new RegExp("<pre>([\\s\\S]*?)</pre>","gi"), function(e) {
					return i.push(e.substring(5, e.length - 6)),
						"<pre></pre>"
				}),
				// BEGIN MOD
				t = t.replace(/~~(.*?)~~/g, OUT_STRIKE),
				// END MOD
				t = t.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>"),
				t = t.replace(/\*(.*?)\*/g, "<em>$1</em>"),
				t = t.replace(/``(.*?)``/g, "<code>$1</code>"),
				t = t.replace(/\[([^\]]+)\]\(([^)]+(\.png|\.gif|\.jpg|\.jpeg))\)/g, '<a href="$2"><img src="$2" alt="$1" /></a>'),
				t = t.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>'),
				t = t.replace(new RegExp("<pre></pre>","g"), function() {
					return "<pre>" + i.shift() + "</pre>"
				}),
				t = t.replace(/{{{}}}/g, function() {
					return n.shift()
				})
		};
		// END ROLL20 CODE

		/* eslint-enable */

		// after a short delay, replace any old content in the chat
		setTimeout(() => {
			$(`.message`).each(function () {
				$(this).html($(this).html().replace(/~~(.*?)~~/g, OUT_STRIKE))
			})
		}, 2500);
	};

	d20plus.engine.enhancePathWidths = () => {
		const $selThicc = $(`#path_width`).css("width", "150px");
		$selThicc.append(`
				<option value="5">Custom 1 (5 px.)</option>
				<option value="5">Custom 2 (5 px.)</option>
				<option value="5">Custom 3 (5 px.)</option>
			`);
		const $iptThicc = $(`<input type="number" style="max-width: 50px;">`).hide();
		const $lblPixels = $(`<label style="display: inline-flex;"> pixels</label>`).hide();
		$selThicc.after($lblPixels).after($iptThicc);

		let $selOpt = null;
		$selThicc.on("change", () => {
			$selOpt = $selThicc.find(`option:selected`);
			const txt = $selOpt.text();
			if (txt.startsWith("Custom")) {
				const thicc = /\((.*?) px\.\)/.exec(txt)[1];
				$lblPixels.show();
				$iptThicc.show().val(Number(thicc));
			} else {
				$lblPixels.hide();
				$iptThicc.hide();
			}
		});

		$iptThicc.on("keyup", () => {
			if (!$selOpt) $selOpt = $selThicc.find(`option:selected`);
			if ($selOpt) {
				const clean = Math.round(Math.max(1, Number($iptThicc.val())));
				$selOpt.val(`${clean}`);
				$selOpt.text($selOpt.text().replace(/\(\d+ px\.\)/, `(${clean} px.)`));
				d20.engine.canvas.freeDrawingBrush.width = clean;
			}
		});
	};

	d20plus.engine.enhanceTransmogrifier = () => {
		JqueryUtil.addSelectors();

		$("#transmogrifier").on("click", () => {
			setTimeout(() => {
				const $btnAlpha = $(`#vetools-transmog-alpha`);
				if (!$btnAlpha.length) {
					const $prependTarget = $(`.ui-dialog-title:textEquals(transmogrifier)`).first().parent().parent().find(`.ui-dialog-content`);
					$(`<button id="#vetools-transmog-alpha" class="btn btn default" style="margin-bottom: 5px;">Sort Items Alphabetically</button>`).on("click", () => {
						// coped from a bookmarklet
						$("iframe").contents().find(".objects").each((c, e) => { let $e = $(e); $e.children().sort((a, b) => { let name1 = $(a).find(".name").text().toLowerCase(); let name2 = $(b).find(".name").text().toLowerCase(); let comp = name1.localeCompare(name2); return comp; }).each((i, c) => $e.append(c)); });
					}).prependTo($prependTarget);
				}
			}, 35);
		})
	};

	d20plus.engine.addLayers = () => {
		d20plus.ut.log("Adding layers");

		d20plus.mod.editingLayerOnclick();
		if (window.is_gm) {
			$(`#floatingtoolbar .choosemap`).html(`<span class="pictos" style="padding: 0 3px 0 3px;">@</span> Map`);
			$(`#floatingtoolbar .choosemap`).after(`
				<li class="choosebackground">
					<span class="pictos">a</span>
					Background
				</li>
			`);
			$(`#floatingtoolbar .chooseobjects`).after(`
				<li class="chooseforeground">
					<span class="pictos">B</span>
					Foreground
				</li>
			`);
			$(`#floatingtoolbar .choosewalls`).after(`
				<li class="chooseweather">
					<span class="pictos">C</span>
					Weather Exclusions
				</li>
			`);
		}

		d20.engine.canvas._renderAll = _.bind(d20plus.mod.renderAll, d20.engine.canvas);
		d20.engine.canvas._layerIteratorGenerator = d20plus.mod.layerIteratorGenerator;
	};

	d20plus.engine.removeLinkConfirmation = function () {
		d20.utils.handleURL = d20plus.mod.handleURL;
		$(document).off("click", "a").on("click", "a", d20.utils.handleURL);
	};

	d20plus.engine.repairPrototypeMethods = function () {
		d20plus.mod.fixHexMethods();
		d20plus.mod.fixVideoMethods();
	};

	d20plus.engine.disableFrameRecorder = function () {
		if (d20.engine.frame_recorder) {
			d20.engine.frame_recorder.active = false;
			d20.engine.frame_recorder._active = false;
		}
	};
}

SCRIPT_EXTENSIONS.push(d20plusEngine);


function baseWeather () {
	d20plus.weather = {};

	d20plus.weather._lastSettingsPageId = null;
	d20plus.weather._initSettingsButton = () => {
		$(`body`).on("click", ".Ve-btn-weather", function () {
			// close the parent page settings + hide the page overlay
			const $this = $(this);
			$this.closest(`[role="dialog"]`).find(`.ui-dialog-buttonpane button:contains("OK")`).click();
			const $barPage = $(`#page-toolbar`);
			if (!$barPage.hasClass("closed")) {
				$barPage.find(`.handle`).click()
			}

			function doShowDialog (page) {
				const $dialog = $(`
					<div title="Weather Configuration">
						<label class="split wth__row">
							<span>Weather Type</span>
							<select name="weatherType1">
								<option>None</option>
								<option>Fog</option>
								<option>Rain</option>
								<option>Ripples</option>
								<option>Snow</option>
								<option>Waves</option>
								<option>Blood Rain</option>
								<option>Custom (see below)</option>
							</select>
						</label>
						<label class="split wth__row">
							<span  class="help" title="When &quot;Custom&quot; is selected, above">Custom Weather Image</span>
							<input name="weatherTypeCustom1" placeholder="https://example.com/pic.png">
						</label>
						<label class="flex wth__row">
							<span>Weather Speed</span>
							<input type="range" name="weatherSpeed1" min="0.01" max="1" step="0.01">
						</label>
						<label class="split wth__row">
							<span>Weather Direction</span>
							<select name="weatherDir1">
								<option>Northerly</option>
								<option>North-Easterly</option>
								<option>Easterly</option>
								<option>South-Easterly</option>
								<option>Southerly</option>
								<option>South-Westerly</option>
								<option>Westerly</option>
								<option>North-Westerly</option>
								<option>Custom (see below)</option>
							</select>
						</label>
						<label class="flex wth__row">
							<span class="help" title="When &quot;Custom&quot; is selected, above">Custom Weather Direction</span>
							<input type="range" name="weatherDirCustom1" min="0" max="360" step="1">
						</label>
						<label class="flex wth__row">
							<span>Weather Opacity</span>
							<input type="range" name="weatherOpacity1" min="0.05" max="1" step="0.01">
						</label>
						<label class="split wth__row">
							<span>Oscillate</span>
							<input type="checkbox" name="weatherOscillate1">
						</label>
						<label class="flex wth__row">
							<span>Oscillation Threshold</span>
							<input type="range" name="weatherOscillateThreshold1" min="0.05" max="1" step="0.01">
						</label>
						<label class="split wth__row">
							<span>Intensity</span>
							<select name="weatherIntensity1">
								<option>Normal</option>
								<option>Heavy</option>
							</select>
						</label>
						<label class="split wth__row">
							<span>Tint</span>
							<input type="checkbox" name="weatherTint1">
						</label>
						<label class="split wth__row">
							<span>Tint Color</span>
							<input type="color" name="weatherTintColor1" value="#4c566d">
						</label>
						<label class="split wth__row">
							<span>Special Effects</span>
							<select name="weatherEffect1">
								<option>None</option>
								<option>Lightning</option>
							</select>
						</label>
					</div>
				`).appendTo($("body"));

				const handleProp = (propName) => $dialog.find(`[name="${propName}"]`).each((i, e) => {
					const $e = $(e);
					if ($e.is(":checkbox")) {
						$e.prop("checked", !!page.get(`bR20cfg_${propName}`));
					} else {
						$e.val(page.get(`bR20cfg_${propName}`));
					}
				});
				const props = [
					"weatherType1",
					"weatherTypeCustom1",
					"weatherSpeed1",
					"weatherDir1",
					"weatherDirCustom1",
					"weatherOpacity1",
					"weatherOscillate1",
					"weatherOscillateThreshold1",
					"weatherIntensity1",
					"weatherTint1",
					"weatherTintColor1",
					"weatherEffect1",
				];
				props.forEach(handleProp);

				function doSaveValues () {
					props.forEach(propName => {
						page.set(`bR20cfg_${propName}`, (() => {
							const $e = $dialog.find(`[name="${propName}"]`);
							if ($e.is(":checkbox")) {
								return !!$e.prop("checked");
							} else {
								return $e.val();
							}
						})())
					});
					page.save();
				}

				$dialog.dialog({
					width: 500,
					dialogClass: "no-close",
					buttons: [
						{
							text: "OK",
							click: function () {
								$(this).dialog("close");
								$dialog.remove();
								doSaveValues();
							},
						},
						{
							text: "Apply",
							click: function () {
								doSaveValues();
							},
						},
						{
							text: "Cancel",
							click: function () {
								$(this).dialog("close");
								$dialog.remove();
							},
						},
					],
				});
			}

			if (d20plus.weather._lastSettingsPageId) {
				const page = d20.Campaign.pages.get(d20plus.weather._lastSettingsPageId);
				if (page) {
					doShowDialog(page);
				} else d20plus.ut.error(`No page found with ID "${d20plus.weather._lastSettingsPageId}"`);
			} else d20plus.ut.error(`No page settings button was clicked?!`);
		}).on("mousedown", ".chooseablepage .js__settings-page", function () {
			const $this = $(this);
			d20plus.weather._lastSettingsPageId = $this.closest(`[data-pageid]`).data("pageid");
		});
	};

	d20plus.weather.addWeather = () => {
		d20plus.weather._initSettingsButton();

		window.force = false; // missing variable in Roll20's code(?); define it here

		d20plus.ut.log("Adding weather");

		const MAX_ZOOM = 2.5; // max canvas zoom
		const tmp = []; // temp vector
		// cache images
		const IMAGES = {
			"Rain": new Image(),
			"Snow": new Image(),
			"Fog": new Image(),
			"Waves": new Image(),
			"Ripples": new Image(),
			"Blood Rain": new Image(),
		};
		IMAGES.Rain.src = "https://i.imgur.com/lZrqiVk.png";
		IMAGES.Snow.src = "https://i.imgur.com/uwLQjWY.png";
		IMAGES.Fog.src = "https://i.imgur.com/SRsUpHW.png";
		IMAGES.Waves.src = "https://i.imgur.com/iYEzmvB.png";
		IMAGES.Ripples.src = "https://i.imgur.com/fFCr0yx.png";
		IMAGES["Blood Rain"].src = "https://i.imgur.com/SP2aoeq.png";
		const SFX = {
			lightning: [],
		};

		// FIXME find a better way of handling this; `clip` is super-slow
		const clipMode = "EXCLUDE";

		function SfxLightning () {
			this.brightness = 255;
		}

		const $wrpEditor = $("#editor-wrapper");

		// add custom canvas
		const $wrpCanvas = $wrpEditor.find(".canvas-container");

		// make buffer canvas
		const $canBuf = $("<canvas style='position: absolute; z-index: -100; left:0; top: 0; pointer-events: none;' tabindex='-1'/>").appendTo($wrpCanvas);
		const cvBuf = $canBuf[0];
		const ctxBuf = cvBuf.getContext("2d");

		// make weather canvas
		const $canvasWeather = $("<canvas id='Vet-canvas-weather' style='position: absolute; z-index: 2; left:0; top: 0; pointer-events: none;' tabindex='-1'/>").appendTo($wrpCanvas);
		const cv = $canvasWeather[0];
		d20.engine.weathercanvas = cv;

		// add our canvas to those adjusted when canvas size changes
		const cachedSetCanvasSize = d20.engine.setCanvasSize;
		d20.engine.setCanvasSize = function (e, n) {
			cv.width = e;
			cv.height = n;

			cvBuf.width = e;
			cvBuf.height = n;

			cachedSetCanvasSize(e, n);
		};

		cv.width = cvBuf.width = d20.engine.canvas.width;
		cv.height = cvBuf.height = d20.engine.canvas.height;

		const ctx = cv.getContext("2d");

		const CTX = {
			_hasWarned: new Set(),
		};

		function ofX (x) { // offset X
			return x - d20.engine.currentCanvasOffset[0];
		}

		function ofY (y) { // offset Y
			return y - d20.engine.currentCanvasOffset[1];
		}

		function lineIntersectsBounds (points, bounds) {
			return d20plus.math.doPolygonsIntersect([points[0], points[2], points[3], points[1]], bounds);
		}

		function copyPoints (toCopy) {
			return [...toCopy.map(pt => [...pt])];
		}

		function getImage (page) {
			const imageName = page.get("bR20cfg_weatherType1");

			switch (imageName) {
				case "Rain":
				case "Snow":
				case "Fog":
				case "Waves":
				case "Ripples":
				case "Blood Rain":
					IMAGES["Custom"] = null;
					return IMAGES[imageName];
				case "Custom (see below)":
					if (!IMAGES["Custom"] || (
						(IMAGES["Custom"].src !== page.get("bR20cfg_weatherTypeCustom1") && IMAGES["Custom"]._errorSrc == null)
						|| (IMAGES["Custom"]._errorSrc != null && IMAGES["Custom"]._errorSrc !== page.get("bR20cfg_weatherTypeCustom1")))
					) {
						IMAGES["Custom"] = new Image();
						IMAGES["Custom"]._errorSrc = null;
						IMAGES["Custom"].onerror = () => {
							if (IMAGES["Custom"]._errorSrc == null) {
								IMAGES["Custom"]._errorSrc = page.get("bR20cfg_weatherTypeCustom1");
								alert(`Custom weather image "${IMAGES["Custom"].src}" failed to load!`);
							}
							IMAGES["Custom"].src = IMAGES["Rain"].src;
						};
						IMAGES["Custom"].src = page.get("bR20cfg_weatherTypeCustom1");
					}
					return IMAGES["Custom"];
				default:
					IMAGES["Custom"] = null;
					return null;
			}
		}

		function getDirectionRotation (page) {
			const dir = page.get("bR20cfg_weatherDir1");
			switch (dir) {
				case "Northerly": return 0.25 * Math.PI;
				case "North-Easterly": return 0.5 * Math.PI;
				case "Easterly": return 0.75 * Math.PI;
				case "South-Easterly": return Math.PI;
				case "Southerly": return 1.25 * Math.PI;
				case "South-Westerly": return 1.5 * Math.PI;
				case "Westerly": return 1.75 * Math.PI;
				case "North-Westerly": return 0;
				case "Custom (see below)":
					return Number(page.get("bR20cfg_weatherDirCustom1") || 0) * Math.PI / 180;
				default: return 0;
			}
		}

		function getOpacity (page) {
			return page.get("bR20cfg_weatherOpacity1") || 1;
		}

		let oscillateMode = null;
		function isOscillating (page) {
			return !!page.get("bR20cfg_weatherOscillate1");
		}

		function getOscillationThresholdFactor (page) {
			return page.get("bR20cfg_weatherOscillateThreshold1") || 1;
		}

		function getIntensity (page) {
			const tint = page.get("bR20cfg_weatherIntensity1");
			switch (tint) {
				case "Heavy": return 1;
				default: return 0;
			}
		}

		function getTintColor (page) {
			const tintEnabled = page.get("bR20cfg_weatherTint1");
			if (tintEnabled) {
				return `${(page.get("bR20cfg_weatherTintColor1") || "#4c566d")}80`;
			} else return null;
		}

		function getEffect (page) {
			const effect = page.get("bR20cfg_weatherEffect1");
			switch (effect) {
				case "Lightning": return "lightning";
				default: return null;
			}
		}

		function handleSvgCoord (coords, obj, basesXY, center, angle) {
			const vec = [
				ofX(coords[0] * obj.scaleX) + basesXY[0],
				ofY(coords[1] * obj.scaleY) + basesXY[1],
			];
			d20plus.math.vec2.scale(vec, vec, d20.engine.canvasZoom);
			if (angle) d20plus.math.vec2.rotate(vec, vec, center, angle);
			return vec;
		}

		let accum = 0;
		let then = 0;
		let image;
		let currentSfx;
		let hasWeather = false;
		function drawFrame (now) {
			const deltaTime = now - then;
			then = now;

			const page = d20 && d20.Campaign && d20.Campaign.activePage ? d20.Campaign.activePage() : null;
			if (page && page.get("bR20cfg_weatherType1") !== "None") {
				image = getImage(page);
				currentSfx = getEffect(page);

				// generate SFX
				if (currentSfx) {
					if (currentSfx === "lightning" && Math.random() > 0.999) SFX.lightning.push(new SfxLightning());
				} else {
					SFX.lightning = [];
				}

				if (hasWeather) ctx.clearRect(0, 0, cv.width, cv.height);
				const hasImage = image && image.complete;
				const tint = getTintColor(page);
				const scaledW = hasImage ? Math.ceil((image.width * d20.engine.canvasZoom) / MAX_ZOOM) : -1;
				const scaledH = hasImage ? Math.ceil((image.height * d20.engine.canvasZoom) / MAX_ZOOM) : -1;
				const hasSfx = SFX.lightning.length;
				if (hasImage || tint || hasSfx) {
					hasWeather = true;

					// draw weather
					if (
						hasImage
						&& !(scaledW <= 0 || scaledH <= 0) // sanity check
					) {
						// mask weather
						const doMaskStep = () => {
							ctxBuf.clearRect(0, 0, cvBuf.width, cvBuf.height);

							ctxBuf.fillStyle = "#ffffffff";

							const objectLen = d20.engine.canvas._objects.length;
							for (let i = 0; i < objectLen; ++i) {
								const obj = d20.engine.canvas._objects[i];
								if (obj.type === "path" && obj.model && obj.model.get("layer") === "weather") {
									// obj.top is X pos of center of object
									// obj.left is Y pos of center of object
									const xBase = (obj.left - (obj.width * obj.scaleX / 2));
									const yBase = (obj.top - (obj.height * obj.scaleY / 2));
									const basesXY = [xBase, yBase];
									const angle = (obj.angle > 360 ? obj.angle - 360 : obj.angle) / 180 * Math.PI;
									const center = [ofX(obj.left), ofY(obj.top)];
									d20plus.math.vec2.scale(center, center, d20.engine.canvasZoom);

									ctxBuf.beginPath();
									obj.path.forEach(opp => {
										const [op, x, y, ...others] = opp;
										switch (op) {
											case "M": {
												const vec = handleSvgCoord([x, y], obj, basesXY, center, angle);
												ctxBuf.moveTo(vec[0], vec[1]);
												break;
											}
											case "L": {
												const vec = handleSvgCoord([x, y], obj, basesXY, center, angle);
												ctxBuf.lineTo(vec[0], vec[1]);
												break;
											}
											case "C": {
												const control1 = handleSvgCoord([x, y], obj, basesXY, center, angle);
												const control2 = handleSvgCoord([others[0], others[1]], obj, basesXY, center, angle);
												const end = handleSvgCoord([others[2], others[3]], obj, basesXY, center, angle);
												ctxBuf.bezierCurveTo(...control1, ...control2, ...end);
												break;
											}
											default:
												if (!CTX._hasWarned.has(op)) {
													CTX._hasWarned.add(op);
													// eslint-disable-next-line no-console
													console.error(`UNHANDLED OP!: ${op}`);
												}
										}
									});
									ctxBuf.fill();
									ctxBuf.closePath();
								}
							}

							// draw final weather mask
							/// / change drawing mode
							ctx.globalCompositeOperation = "destination-out";
							ctx.drawImage(cvBuf, 0, 0);

							// handle opacity
							const opacity = Number(getOpacity(page));
							if (opacity !== 1) {
								ctxBuf.clearRect(0, 0, cvBuf.width, cvBuf.height);
								ctxBuf.fillStyle = `#ffffff${Math.round((1 - opacity) * 255).toString(16)}`;
								ctxBuf.fillRect(0, 0, cvBuf.width, cvBuf.height);
								ctx.drawImage(cvBuf, 0, 0);
							}

							/// / reset drawing mode
							ctx.globalCompositeOperation = "source-over";
						};

						// if (clipMode === "INCLUDE") doMaskStep(true);

						const speed = page.get("bR20cfg_weatherSpeed1") || 0.1;
						const speedFactor = speed * d20.engine.canvasZoom;
						const maxAccum = Math.floor(scaledW / speedFactor);
						const rot = getDirectionRotation(page);
						const w = scaledW;
						const h = scaledH;
						const boundingBox = [
							[
								-1.5 * w,
								-1.5 * h,
							],
							[
								-1.5 * w,
								cv.height + (1.5 * h) + d20.engine.currentCanvasOffset[1],
							],
							[
								cv.width + (1.5 * w) + d20.engine.currentCanvasOffset[0],
								cv.height + (1.5 * h) + d20.engine.currentCanvasOffset[1],
							],
							[
								cv.width + (1.5 * w) + d20.engine.currentCanvasOffset[0],
								-1.5 * h,
							],
						];
						const BASE_OFFSET_X = -w / 2;
						const BASE_OFFSET_Y = -h / 2;

						// calculate resultant points of a rotated shape
						const pt00 = [0, 0];
						const pt01 = [0, 1];
						const pt10 = [1, 0];
						const pt11 = [1, 1];
						const basePts = [
							pt00,
							pt01,
							pt10,
							pt11,
						].map(pt => [
							(pt[0] * w) + BASE_OFFSET_X - d20.engine.currentCanvasOffset[0],
							(pt[1] * h) + BASE_OFFSET_Y - d20.engine.currentCanvasOffset[1],
						]);
						basePts.forEach(pt => d20plus.math.vec2.rotate(pt, pt, [0, 0], rot));

						// calculate animation values
						(() => {
							if (isOscillating(page)) {
								const oscThreshFactor = getOscillationThresholdFactor(page);

								if (oscillateMode == null) {
									oscillateMode = 1;
									accum += deltaTime;
									if (accum >= maxAccum * oscThreshFactor) accum -= maxAccum;
								} else {
									if (oscillateMode === 1) {
										accum += deltaTime;
										if (accum >= maxAccum * oscThreshFactor) {
											accum -= 2 * deltaTime;
											oscillateMode = -1;
										}
									} else {
										accum -= deltaTime;
										if (accum <= 0) {
											oscillateMode = 1;
											accum += 2 * deltaTime;
										}
									}
								}
							} else {
								oscillateMode = null;
								accum += deltaTime;
								if (accum >= maxAccum) accum -= maxAccum;
							}
						})();

						const intensity = getIntensity(page) * speedFactor;
						const timeOffsetX = Math.ceil(speedFactor * accum);
						const timeOffsetY = Math.ceil(speedFactor * accum);

						/// / rotate coord space
						ctx.rotate(rot);

						// draw base image
						const doDraw = (offsetX, offsetY) => {
							const xPos = BASE_OFFSET_X + timeOffsetX + offsetX - d20.engine.currentCanvasOffset[0];
							const yPos = BASE_OFFSET_Y + timeOffsetY + offsetY - d20.engine.currentCanvasOffset[1];
							ctx.drawImage(
								image,
								xPos,
								yPos,
								w,
								h,
							);

							if (intensity) {
								const offsetIntensity = -Math.floor(w / 4);
								ctx.drawImage(
									image,
									xPos + offsetIntensity,
									yPos + offsetIntensity,
									w,
									h,
								);
							}
						}

						const inBounds = (nextPts) => {
							return lineIntersectsBounds(nextPts, boundingBox);
						}

						const moveXDir = (pt, i, isAdd) => {
							if (i % 2) d20plus.math.vec2.sub(tmp, basePts[3], basePts[1]);
							else d20plus.math.vec2.sub(tmp, basePts[2], basePts[0]);

							if (isAdd) d20plus.math.vec2.add(pt, pt, tmp);
							else d20plus.math.vec2.sub(pt, pt, tmp);
						}

						const moveYDir = (pt, i, isAdd) => {
							if (i > 1) d20plus.math.vec2.sub(tmp, basePts[3], basePts[2]);
							else d20plus.math.vec2.sub(tmp, basePts[1], basePts[0]);

							if (isAdd) d20plus.math.vec2.add(pt, pt, tmp);
							else d20plus.math.vec2.sub(pt, pt, tmp);
						}

						const getMaxMoves = () => {
							const hyp = [];
							d20plus.math.vec2.sub(hyp, boundingBox[2], boundingBox[0]);

							const dist = d20plus.math.vec2.len(hyp);
							const maxMoves = dist / Math.min(w, h);
							return [Math.abs(hyp[0]) > Math.abs(hyp[1]) ? "x" : "y", maxMoves];
						};

						const handleXAxisYIncrease = (nxtPts, maxMoves, moves, xDir) => {
							const handleY = (dir) => {
								let subNxtPts, subMoves;
								subNxtPts = copyPoints(nxtPts);
								subMoves = 0;
								while (subMoves <= maxMoves[1]) {
									subNxtPts.forEach((pt, i) => moveYDir(pt, i, dir > 0));
									subMoves++;
									if (inBounds(subNxtPts)) doDraw(xDir * moves * w, dir * (subMoves * h));
								}
							};

							handleY(1); // y axis increasing
							handleY(-1); // y axis decreasing
						};

						const handleYAxisXIncrease = (nxtPts, maxMoves, moves, yDir) => {
							const handleX = (dir) => {
								let subNxtPts, subMoves;
								subNxtPts = copyPoints(nxtPts);
								subMoves = 0;
								while (subMoves <= maxMoves[1]) {
									subNxtPts.forEach((pt, i) => moveXDir(pt, i, dir > 0));
									subMoves++;
									if (lineIntersectsBounds(subNxtPts, boundingBox)) doDraw(dir * (subMoves * w), yDir * moves * h);
								}
							};

							handleX(1); // x axis increasing
							handleX(-1); // x axis decreasing
						};

						const handleBasicX = (maxMoves) => {
							const handleX = (dir) => {
								let nxtPts, moves;
								nxtPts = copyPoints(basePts);
								moves = 0;
								while (moves < maxMoves) {
									nxtPts.forEach((pt, i) => moveXDir(pt, i, dir > 0));
									moves++;
									if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(dir * (moves * w), 0);
								}
							};

							handleX(1); // x axis increasing
							handleX(-1); // x axis decreasing
						};

						const handleBasicY = (maxMoves) => {
							const handleY = (dir) => {
								let nxtPts, moves;
								nxtPts = copyPoints(basePts);
								moves = 0;
								while (moves < maxMoves) {
									nxtPts.forEach((pt, i) => moveYDir(pt, i, dir > 0));
									moves++;
									if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(0, dir * (moves * h));
								}
							};

							handleY(1); // y axis increasing
							handleY(-1); // y axis decreasing
						};

						doDraw(0, 0);

						(() => {
							// choose largest axis
							const maxMoves = getMaxMoves();

							if (maxMoves[0] === "x") {
								const handleX = (dir) => {
									let nxtPts, moves;
									nxtPts = copyPoints(basePts);
									moves = 0;
									while (moves < maxMoves[1]) {
										nxtPts.forEach((pt, i) => moveXDir(pt, i, dir > 0));
										moves++;
										if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(dir * (moves * w), 0);
										handleXAxisYIncrease(nxtPts, maxMoves, moves, dir);
									}
								};

								handleBasicY(maxMoves[1]);
								handleX(1); // x axis increasing
								handleX(-1); // x axis decreasing
							} else {
								const handleY = (dir) => {
									let nxtPts, moves;
									nxtPts = copyPoints(basePts);
									moves = 0;
									while (moves < maxMoves[1]) {
										nxtPts.forEach((pt, i) => moveYDir(pt, i, dir > 0));
										moves++;
										if (lineIntersectsBounds(nxtPts, boundingBox)) doDraw(0, dir * (moves * h));
										handleYAxisXIncrease(nxtPts, maxMoves, moves, dir);
									}
								};

								handleBasicX(maxMoves[1]);
								handleY(1); // y axis increasing
								handleY(-1); // y axis decreasing
							}
						})();

						/// / revert coord space rotation
						ctx.rotate(-rot);

						if (clipMode === "EXCLUDE") doMaskStep(false);
					}

					// draw sfx
					if (hasSfx) {
						for (let i = SFX.lightning.length - 1; i >= 0; --i) {
							const l = SFX.lightning[i];
							if (l.brightness <= 5) {
								SFX.lightning.splice(i, 1);
							} else {
								ctx.fillStyle = `#effbff${l.brightness.toString(16).padStart(2, "0")}`;
								ctx.fillRect(0, 0, cv.width, cv.height);
								l.brightness -= Math.floor(deltaTime);
							}
						}
					}

					// draw tint
					if (tint) {
						ctx.fillStyle = tint;
						ctx.fillRect(0, 0, cv.width, cv.height);
					}
				}

				requestAnimationFrame(drawFrame);
			} else {
				// if weather is disabled, maintain a background tick
				if (hasWeather) {
					ctx.clearRect(0, 0, cv.width, cv.height);
					hasWeather = false;
				}
				setTimeout(() => {
					drawFrame(0);
				}, 1000);
			}
		}

		requestAnimationFrame(drawFrame);
	};
}

SCRIPT_EXTENSIONS.push(baseWeather);


function d20plusJournal () {
	d20plus.journal = {};

	d20plus.journal.lastClickedFolderId = null;

	d20plus.journal.addJournalCommands = () => {
		// Create new Journal commands
		// stash the folder ID of the last folder clicked
		$("#journalfolderroot").on("contextmenu", ".dd-content", function (e) {
			if ($(this).parent().hasClass("dd-folder")) {
				const lastClicked = $(this).parent();
				d20plus.journal.lastClickedFolderId = lastClicked.attr("data-globalfolderid");
			}

			if ($(this).parent().hasClass("character")) {
				$(`.Vetools-make-tokenactions`).show();
			} else {
				$(`.Vetools-make-tokenactions`).hide();
			}
		});

		let first = $("#journalitemmenu ul li").first();
		// "Make Tokenactions" option
		first.after(`<li class="Vetools-make-tokenactions" data-action-type="additem">Make Tokenactions</li>`);
		$("#journalitemmenu ul").on(window.mousedowntype, "li[data-action-type=additem]", function () {
			let id = $currentItemTarget.attr("data-itemid");
			let character = d20.Campaign.characters.get(id);
			d20plus.ut.log("Making Token Actions..");
			if (character) {
				let npc = character.attribs.find(function (a) {
					return a.get("name").toLowerCase() === "npc";
				});
				let isNPC = npc ? parseInt(npc.get("current")) : 0;
				if (isNPC) {
					// Npc specific tokenactions
					character.abilities.create({
						name: "Perception",
						istokenaction: true,
						action: d20plus.actionMacroPerception,
					});
					character.abilities.create({
						name: "DR/Immunities",
						istokenaction: true,
						action: d20plus.actionMacroDrImmunities,
					});
					character.abilities.create({
						name: "Stats",
						istokenaction: true,
						action: d20plus.actionMacroStats,
					});
					character.abilities.create({
						name: "Saves",
						istokenaction: true,
						action: d20plus.actionMacroSaves,
					});
					character.abilities.create({
						name: "Skill-Check",
						istokenaction: true,
						action: d20plus.actionMacroSkillCheck,
					});
					character.abilities.create({
						name: "Ability-Check",
						istokenaction: true,
						action: d20plus.actionMacroAbilityCheck,
					});
				} else {
					// player specific tokenactions
					// @{selected|repeating_attack_$0_atkname}
					character.abilities.create({
						name: "Attack 1",
						istokenaction: true,
						action: "%{selected|repeating_attack_$0_attack}",
					});
					character.abilities.create({
						name: "Attack 2",
						istokenaction: true,
						action: "%{selected|repeating_attack_$1_attack}",
					});
					character.abilities.create({
						name: "Attack 3",
						istokenaction: true,
						action: "%{selected|repeating_attack_$2_attack}",
					});
					character.abilities.create({
						name: "Tool 1",
						istokenaction: true,
						action: "%{selected|repeating_tool_$0_tool}",
					});
					// " + character.get("name") + "
					character.abilities.create({
						name: "Whisper GM",
						istokenaction: true,
						action: "/w gm ?{Message to whisper the GM?}",
					});
					character.abilities.create({
						name: "Favorite Spells",
						istokenaction: true,
						action: "/w @{character_name} &{template:npcaction} {{rname=Favorite Spells}} {{description=Favorite Spells are the first spells in each level of your spellbook.\n\r[Cantrip](~selected|repeating_spell-cantrip_$0_spell)\n[1st Level](~selected|repeating_spell-1_$0_spell)\n\r[2nd Level](~selected|repeating_spell-2_$0_spell)\n\r[3rd Level](~selected|repeating_spell-3_$0_spell)\n\r[4th Level](~selected|repeating_spell-4_$0_spell)\n\r[5th Level](~selected|repeating_spell-5_$0_spell)}}",
					});
					character.abilities.create({
						name: "Dual Attack",
						istokenaction: false,
						action: "%{selected|repeating_attack_$0_attack}\n\r%{selected|repeating_attack_$0_attack}",
					});
					character.abilities.create({
						name: "Saves",
						istokenaction: true,
						action: "@{selected|wtype}&{template:simple} @{selected|rtype}?{Save|Strength, +@{selected|strength_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Strength Save&#125;&#125 {{mod=@{selected|strength_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|strength_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Dexterity, +@{selected|dexterity_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Dexterity Save&#125;&#125 {{mod=@{selected|dexterity_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|dexterity_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Constitution, +@{selected|constitution_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Constitution Save&#125;&#125 {{mod=@{selected|constitution_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|constitution_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Intelligence, +@{selected|intelligence_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Intelligence Save&#125;&#125 {{mod=@{selected|intelligence_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|intelligence_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Wisdom, +@{selected|wisdom_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Wisdom Save&#125;&#125 {{mod=@{selected|wisdom_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|wisdom_save_bonus}@{selected|pbd_safe}]]&#125;&#125; |Charisma, +@{selected|charisma_save_bonus}@{selected|pbd_safe}]]&#125;&#125; {{rname=Charisma Save&#125;&#125 {{mod=@{selected|charisma_save_bonus}&#125;&#125; {{r1=[[@{selected|d20}+@{selected|charisma_save_bonus}@{selected|pbd_safe}]]&#125;&#125;}@{selected|global_save_mod}@{selected|charname_output",
					});
					character.abilities.create({
						name: "Skill-Check",
						istokenaction: true,
						action: "@{selected|wtype}&{template:simple} @{selected|rtype}?{Ability|Acrobatics, +@{selected|acrobatics_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Acrobatics&#125;&#125; {{mod=@{selected|acrobatics_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|acrobatics_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Animal Handling, +@{selected|animal_handling_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Animal Handling&#125;&#125; {{mod=@{selected|animal_handling_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|animal_handling_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Arcana, +@{selected|arcana_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Arcana&#125;&#125; {{mod=@{selected|arcana_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|arcana_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Athletics, +@{selected|athletics_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Athletics&#125;&#125; {{mod=@{selected|athletics_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|athletics_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Deception, +@{selected|deception_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Deception&#125;&#125; {{mod=@{selected|deception_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|deception_bonus}@{selected|pbd_safe} ]]&#125;&#125; |History, +@{selected|history_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=History&#125;&#125; {{mod=@{selected|history_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|history_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Insight, +@{selected|insight_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Insight&#125;&#125; {{mod=@{selected|insight_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|insight_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Intimidation, +@{selected|intimidation_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Intimidation&#125;&#125; {{mod=@{selected|intimidation_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|intimidation_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Investigation, +@{selected|investigation_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Investigation&#125;&#125; {{mod=@{selected|investigation_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|investigation_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Medicine, +@{selected|medicine_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Medicine&#125;&#125; {{mod=@{selected|medicine_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|medicine_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Nature, +@{selected|nature_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Nature&#125;&#125; {{mod=@{selected|nature_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|nature_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Perception, +@{selected|perception_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Perception&#125;&#125; {{mod=@{selected|perception_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|perception_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Performance, +@{selected|performance_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Performance&#125;&#125; {{mod=@{selected|performance_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|performance_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Persuasion, +@{selected|persuasion_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Persuasion&#125;&#125; {{mod=@{selected|persuasion_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|persuasion_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Religion, +@{selected|religion_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Religion&#125;&#125; {{mod=@{selected|religion_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|religion_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Sleight of Hand, +@{selected|sleight_of_hand_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Sleight of Hand&#125;&#125; {{mod=@{selected|sleight_of_hand_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|sleight_of_hand_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Stealth, +@{selected|stealth_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Stealth&#125;&#125; {{mod=@{selected|stealth_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|stealth_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Survival, +@{selected|survival_bonus}@{selected|pbd_safe} ]]&#125;&#125; {{rname=Survival&#125;&#125; {{mod=@{selected|survival_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|survival_bonus}@{selected|pbd_safe} ]]&#125;&#125; |Strength, +@{selected|strength_mod}@{selected|jack_attr}[STR]]]&#125;&#125; {{rname=Strength&#125;&#125; {{mod=@{selected|strength_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|strength_mod}@{selected|jack_attr}[STR]]]&#125;&#125; |Dexterity, +@{selected|dexterity_mod}@{selected|jack_attr}[DEX]]]&#125;&#125; {{rname=Dexterity&#125;&#125; {{mod=@{selected|dexterity_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|dexterity_mod}@{selected|jack_attr}[DEX]]]&#125;&#125; |Constitution, +@{selected|constitution_mod}@{selected|jack_attr}[CON]]]&#125;&#125; {{rname=Constitution&#125;&#125; {{mod=@{selected|constitution_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|constitution_mod}@{selected|jack_attr}[CON]]]&#125;&#125; |Intelligence, +@{selected|intelligence_mod}@{selected|jack_attr}[INT]]]&#125;&#125; {{rname=Intelligence&#125;&#125; {{mod=@{selected|intelligence_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|intelligence_mod}@{selected|jack_attr}[INT]]]&#125;&#125; |Wisdom, +@{selected|wisdom_mod}@{selected|jack_attr}[WIS]]]&#125;&#125; {{rname=Wisdom&#125;&#125; {{mod=@{selected|wisdom_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|wisdom_mod}@{selected|jack_attr}[WIS]]]&#125;&#125; |Charisma, +@{selected|charisma_mod}@{selected|jack_attr}[CHA]]]&#125;&#125; {{rname=Charisma&#125;&#125; {{mod=@{selected|charisma_mod}@{selected|jack_bonus}&#125;&#125; {{r1=[[ @{selected|d20} + @{selected|charisma_mod}@{selected|jack_attr}[CHA]]]&#125;&#125; } @{selected|global_skill_mod} @{selected|charname_output}",
					});
				}
				// for everyone
				character.abilities.create({
					name: "Initiative",
					istokenaction: true,
					action: d20plus.actionMacroInit,
				});
			}
		});

		// New command on FOLDERS
		const last = $("#journalmenu ul li").last();
		last.before("<li data-action-type=\"archiveall\">Archive All Contents</li>");

		const $journalUl = $("#journalmenu ul");

		$journalUl.on(window.mousedowntype, "li[data-action-type=archiveall]", function () {
			d20plus.journal.recursiveArchiveDirById(d20plus.journal.lastClickedFolderId, true);
			$("#journalmenu").hide();
		});
	};

	/**
	 * Takes a path made up of strings and arrays of strings, and turns it into one flat array of strings
	 * Note that paths must be of the form ["folder", "subfolder", "subsubfolder", etc]
	 */
	d20plus.journal.getCleanPath = function (...path) {
		const clean = [];
		getStrings(clean, path);
		return clean.map(s => s.trim()).filter(s => s);

		function getStrings (stack, toProc) {
			toProc.forEach(tp => {
				if (typeof tp === "string") {
					stack.push(tp);
				} else if (tp instanceof Array) {
					getStrings(stack, tp);
				} else {
					throw new Error("Object in path was not a string or an array")
				}
			});
		}
	};

	d20plus.journal.makeDirTree = function (...path) {
		const parts = d20plus.journal.getCleanPath(path);
		// path e.g. d20plus.journal.makeDirTree("Spells", "Cantrips", "1")
		// roll20 allows a max directory depth of 4 :joy: (5, but the 5th level is unusable)
		if (parts.length > 4) throw new Error("Max directory depth exceeded! The maximum is 4.")

		const madeSoFar = [];

		const root = {i: d20plus.ut.getJournalFolderObj()};

		// roll20 folder management is dumb, so just pick the first folder with the right name if there's multiple
		let curDir = root;
		parts.forEach(toMake => {
			const existing = curDir.i.find((it) => {
				// n is folder name (only folders have the n property)
				return it.n && it.n === toMake && it.i;
			});
			if (!existing) {
				if (curDir.id) {
					d20.journal.addFolderToFolderStructure(toMake, curDir.id);
				} else {
					// root has no id
					d20.journal.addFolderToFolderStructure(toMake);
				}
			}
			d20.journal.refreshJournalList();
			madeSoFar.push(toMake);

			// we have to save -> reread the entire directory JSON -> walk back to where we were
			let nextDir = {i: JSON.parse(d20.Campaign.get("journalfolder"))};
			madeSoFar.forEach(f => {
				nextDir = nextDir.i.find(dir => dir.n && (dir.n.toLowerCase() === f.toLowerCase()));
			});

			curDir = nextDir;
		});
		return curDir;
	};

	d20plus.journal.recursiveRemoveDirById = function (folderId, withConfirmation) {
		if (!withConfirmation || confirm("Are you sure you want to delete this folder, and everything in it? This cannot be undone.")) {
			const folder = $(`[data-globalfolderid='${folderId}']`);
			if (folder.length) {
				d20plus.ut.log("Nuking directory...");
				const childItems = folder.find("[data-itemid]").each((i, e) => {
					const $e = $(e);
					const itemId = $e.attr("data-itemid");
					let toDel = d20.Campaign.handouts.get(itemId);
					toDel || (toDel = d20.Campaign.characters.get(itemId));
					if (toDel) toDel.destroy();
				});
				const childFolders = folder.find(`[data-globalfolderid]`).remove();
				folder.remove();
				$("#journalfolderroot").trigger("change");
			}
		}
	};

	d20plus.journal.recursiveArchiveDirById = function (folderId, withConfirmation) {
		if (!withConfirmation || confirm("Are you sure you want to archive this folder, and everything in it? This cannot be undone.")) {
			const folder = $(`[data-globalfolderid='${folderId}']`);
			if (folder.length) {
				d20plus.ut.log("Archiving directory...");
				folder.find("[data-itemid]").each((i, e) => {
					const $e = $(e);
					const itemId = $e.attr("data-itemid");
					let toArchive = d20.Campaign.handouts.get(itemId);
					toArchive || (toArchive = d20.Campaign.characters.get(itemId));
					if (toArchive && toArchive.attributes) {
						toArchive.attributes.archived = true;
						toArchive.save()
					}
				});
			}
		}
	};

	d20plus.journal.removeDirByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveDirByPath(true, path);
	};

	d20plus.journal.checkDirExistsByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveDirByPath(false, path);
	};

	d20plus.journal._checkOrRemoveDirByPath = function (doDelete, path) {
		const parts = d20plus.journal.getCleanPath(path);

		const root = {i: d20plus.ut.getJournalFolderObj()};

		let curDir = root;
		for (let i = 0; i < parts.length; ++i) {
			const p = parts[i];
			let lastId;
			const existing = curDir.i.find((it) => {
				lastId = it.id;
				// n is folder name (only folders have the n property)
				return it.n && it.n === p;
			});
			if (!existing) return false;
			if (!doDelete) return true;
			curDir = existing;
			if (i === parts.length - 1) {
				d20plus.journal.recursiveRemoveDirById(lastId, false);
				return true;
			}
		}
	};

	d20plus.journal.getExportableJournal = () => {
		// build a list of (id, path) pairs
		const out = [];

		function recurse (entry, pos) {
			if (entry.i) {
				// pos.push({name: entry.n, id: entry.id}); // if IDs are required, use this instead?
				pos.push(entry.n);
				entry.i.forEach(nxt => recurse(nxt, pos));
				pos.pop();
			} else {
				out.push({id: entry, path: MiscUtil.copy(pos)});
			}
		}

		const root = {i: d20plus.ut.getJournalFolderObj(), n: "Root", id: "root"};
		recurse(root, []);
		return out;
	};

	d20plus.journal.removeFileByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveFileByPath(true, path);
	};

	d20plus.journal.checkFileExistsByPath = function (...path) {
		path = d20plus.journal.getCleanPath(path);
		return d20plus.journal._checkOrRemoveFileByPath(false, path);
	};

	d20plus.journal._checkOrRemoveFileByPath = function (doDelete, path) {
		const parts = d20plus.journal.getCleanPath(path);

		const root = {i: d20plus.ut.getJournalFolderObj()};

		let curDir = root;
		for (let i = 0; i < parts.length; ++i) {
			const p = parts[i];
			let lastId;
			const existing = curDir.i.find((it) => {
				if (i === parts.length - 1) {
					// for the last item, check handouts/characters to see if the match it (which could be a string ID)
					const char = d20.Campaign.characters.get(it);
					const handout = d20.Campaign.handouts.get(it);
					if ((char && char.get("name") === p) || (handout && handout.get("name") === p)) {
						lastId = it;
						return true;
					}
				} else {
					lastId = it.id;
					// n is folder name (only folders have the n property)
					return it.n && it.n === p;
				}
				return false;
			});
			if (!existing) return false;
			curDir = existing;
			if (i === parts.length - 1) {
				if (doDelete) {
					// on the last item, delete
					let toDel = d20.Campaign.handouts.get(lastId);
					toDel || (toDel = d20.Campaign.characters.get(lastId))
					if (toDel) toDel.destroy();
				}
				return true;
			}
		}
		return false;
	};
}

SCRIPT_EXTENSIONS.push(d20plusJournal);


function baseCss () {
	d20plus.css = {};

	// Convert to regular CSS:
	// `[ ... rules ... ].map(it => `${it.s} {\n${it.r.split(";").map(str => str.trim()).join(";\n")}}\n`).join("\n")`
	d20plus.css.baseCssRules = [
		// generic
		{
			s: ".inline-block, .display-inline-block",
			r: "display: inline-block;",
		},
		{
			s: ".bold",
			r: "font-weight: bold;",
		},
		{
			s: ".italic",
			r: "font-style: italic;",
		},
		{
			s: ".clickable",
			r: "cursor: pointer;",
		},
		{
			s: ".split",
			r: "display: flex; justify-content: space-between;",
		},
		{
			s: ".relative",
			r: "position: relative !important;",
		},
		{
			s: ".flex",
			r: "display: flex;",
		},
		{
			s: ".flex-col",
			r: "display: flex; flex-direction: column;",
		},
		{
			s: ".flex-v-center",
			r: "display: flex; align-items: center;",
		},
		{
			s: ".flex-vh-center",
			r: "display: flex; justify-content: center; align-items: center;",
		},
		{
			s: ".no-shrink",
			r: "flex-shrink: 0;",
		},
		{
			s: ".flex-1",
			r: "flex: 1",
		},
		{
			s: ".full-width",
			r: "width: 100%;",
		},
		{
			s: ".full-height",
			r: "height: 100%;",
		},
		{
			s: ".text-center",
			r: "text-align: center;",
		},
		{
			s: ".text-right",
			r: "text-align: right;",
		},
		{
			s: ".is-error",
			r: "color: #d60000;",
		},
		{
			s: ".flex-label",
			r: "display: inline-flex; align-items: center;",
		},
		{
			s: ".sel-xs",
			r: `
				height: 18px;
				line-height: 18px;
				margin: 0;
				padding: 0;
			`,
		},
		{
			s: ".btn-xs",
			r: `
				height: 18px;
				line-height: 18px;
				margin: 0;
				padding: 0 4px;
			`,
		},
		// // fix Roll20's <p> margins in the text editor // FIXME make this configurable
		// {
		// 	s: ".note-editable p",
		// 	r: "margin-bottom: 0;"
		// },
		// ensure rightclick menu width doesn't break layout // FIXME might be fixing the symptoms and not the cause
		{
			s: ".actions_menu.d20contextmenu > ul > li",
			r: "max-width: 100px;",
		},
		// page view enhancement
		{
			s: "#page-toolbar",
			r: "height: calc(90vh - 40px);",
		},
		{
			s: "#page-toolbar .container",
			r: "height: 100%; white-space: normal;",
		},
		{
			s: "#page-toolbar .pages .availablepage",
			r: "width: 100px; height: 100px;",
		},
		{
			s: "#page-toolbar .pages .availablepage img.pagethumb",
			r: "max-width: 60px; max-height: 60px;",
		},
		{
			s: "#page-toolbar .pages .availablepage span",
			r: "bottom: 1px;",
		},
		{
			s: "#page-toolbar",
			r: "background: #a8aaad80;",
		},
		// search
		{
			s: ".Vetoolsresult",
			r: "background: #ff8080;",
		},
		// config editor
		{
			s: "div.config-table-wrapper",
			r: "min-height: 200px; width: 100%; height: 100%; max-height: 460px; overflow-y: auto; transform: translateZ(0);",
		},
		{
			s: "table.config-table",
			r: "width: 100%; table-layout: fixed;",
		},
		{
			s: "table.config-table tbody tr:nth-child(odd)",
			r: "background-color: #f8f8f8;",
		},
		{
			s: "table.config-table tbody td > *",
			r: "vertical-align: middle; margin: 0;",
		},
		{
			s: ".config-name",
			r: "display: inline-block; line-height: 35px; width: 100%;",
		},
		// tool list
		{
			s: ".tools-list",
			r: "max-height: 70vh;",
		},
		{
			s: ".tool-row",
			r: "min-height: 40px; display: flex; flex-direction: row; align-items: center;",
		},
		{
			s: ".tool-row:nth-child(odd)",
			r: "background-color: #f0f0f0;",
		},
		{
			s: ".tool-row > *",
			r: "flex-shrink: 0;",
		},
		// warning overlay
		{
			s: ".temp-warning",
			r: "position: fixed; top: 12px; left: calc(50vw - 200px); z-index: 10000; width: 320px; background: transparent; color: red; font-weight: bold; font-size: 150%; font-variant: small-caps; border: 1px solid red; padding: 4px; text-align: center; border-radius: 4px;",
		},
		// GM hover text
		{
			s: ".Vetools-token-hover",
			r: "pointer-events: none; position: fixed; z-index: 100000; background: white; padding: 5px 5px 0 5px; border-radius: 5px;     border: 1px solid #ccc; max-width: 450px;",
		},
		// drawing tools bar
		{
			s: "#drawingtools.line_splitter .currentselection:after",
			r: "content: '✂️';",
		},
		// chat tag
		{
			s: ".userscript-hacker-chat",
			r: "margin-left: -45px; margin-right: -5px; margin-bottom: -7px; margin-top: -15px; display: inline-block; font-weight: bold; font-family: 'Lucida Console', Monaco, monospace; color: #20C20E; background: black; padding: 3px; min-width: calc(100% + 60px);",
		},
		{
			s: ".userscript-hacker-chat a",
			r: "color: white;",
		},
		{
			s: ".withoutavatars .userscript-hacker-chat",
			r: "margin-left: -15px; min-width: calc(100% + 30px);",
		},
		{
			s: ".Ve-btn-chat",
			r: "margin-top: 10px; margin-left: -35px;",
		},
		{
			s: ".withoutavatars .Ve-btn-chat",
			r: "margin-left: -5px;",
		},
		// Bootstrap-alikes
		{
			s: ".col",
			r: "display: inline-block;",
		},
		{
			s: ".col-1",
			r: "width: 8.333%;",
		},
		{
			s: ".col-2",
			r: "width: 16.666%;",
		},
		{
			s: ".col-3",
			r: "width: 25%;",
		},
		{
			s: ".col-4",
			r: "width: 33.333%;",
		},
		{
			s: ".col-5",
			r: "width: 41.667%;",
		},
		{
			s: ".col-6",
			r: "width: 50%;",
		},
		{
			s: ".col-7",
			r: "width: 58.333%;",
		},
		{
			s: ".col-8",
			r: "width: 66.667%;",
		},
		{
			s: ".col-9",
			r: "width: 75%;",
		},
		{
			s: ".col-10",
			r: "width: 83.333%;",
		},
		{
			s: ".col-11",
			r: "width: 91.667%;",
		},
		{
			s: ".col-12",
			r: "width: 100%;",
		},
		{
			s: ".ib",
			r: "display: inline-block;",
		},
		{
			s: ".float-right",
			r: "float: right;",
		},
		{
			s: ".my-0",
			r: "margin-top: 0 !important; margin-bottom: 0 !important;",
		},
		{
			s: ".m-1",
			r: "margin: 0.25rem !important;",
		},
		{
			s: ".mt-2",
			r: "margin-top: 0.5rem !important;",
		},
		{
			s: ".mr-1",
			r: "margin-right: 0.25rem !important;",
		},
		{
			s: ".ml-1",
			r: "margin-left: 0.25rem !important;",
		},
		{
			s: ".mr-2",
			r: "margin-right: 0.5rem !important;",
		},
		{
			s: ".ml-2",
			r: "margin-left: 0.5rem !important;",
		},
		{
			s: ".mb-2",
			r: "margin-bottom: 0.5rem !important;",
		},
		{
			s: ".mb-1",
			r: "margin-bottom: 0.25rem !important;",
		},
		{
			s: ".p-2",
			r: "padding: 0.5rem !important;",
		},
		{
			s: ".p-3",
			r: "padding: 1rem !important;",
		},
		{
			s: ".split",
			r: "display: flex; justify-content: space-between;",
		},
		{
			s: ".split--center",
			r: "align-items: center;",
		},
		// image rows
		{
			s: ".import-cb-label--img",
			r: "display: flex; height: 64px; align-items: center; padding: 4px;",
		},
		{
			s: ".import-label__img",
			r: "display: inline-block; width: 60px; height: 60px; padding: 0 5px;",
		},
		// importer
		{
			s: ".import-cb-label",
			r: "display: block; margin-right: -13px !important;",
		},
		{
			s: ".import-cb-label span",
			r: "display: inline-block; overflow: hidden; max-height: 18px; letter-spacing: -1px; font-size: 12px;",
		},
		{
			s: ".import-cb-label span.readable",
			r: "letter-spacing: initial",
		},
		{
			s: ".import-cb-label .source",
			r: "width: calc(16.667% - 28px);'",
		},
		// horizontal toolbar
		{
			s: "#secondary-toolbar:hover",
			r: "opacity: 1 !important;",
		},
		// addon layer bar
		{
			s: "#floatinglayerbar ul",
			r: "margin: 0; padding: 0;",
		},
		{
			s: "#floatinglayerbar li:hover, #floatinglayerbar li.activebutton",
			r: "color: #333; background-color: #54C3E8; cursor: pointer;",
		},
		{
			s: "#floatinglayerbar li",
			r: "padding: 3px; margin: 0; border-bottom: 1px solid #999; display: block; text-align: center; line-height: 22px; font-size: 22px; color: #999; position: relative;",
		},
		{
			s: "#floatinglayerbar.map li.choosemap, #floatinglayerbar.objects li.chooseobjects, #floatinglayerbar.gmlayer li.choosegmlayer, #floatinglayerbar.walls li.choosewalls, #floatinglayerbar.weather li.chooseweather, #floatinglayerbar.foreground li.chooseforeground, #floatinglayerbar.background li.choosebackground",
			r: "background-color: #54C3E8; color: #333;",
		},
		// extra layer buttons
		{
			s: "#editinglayer.weather div.submenu li.chooseweather, #editinglayer.foreground div.submenu li.chooseforeground, #editinglayer.background div.submenu li.choosebackground",
			r: "background-color: #54C3E8; color: #333;",
		},
		{
			s: "#editinglayer.weather .currentselection:after",
			r: "content: \"C\";",
		},
		{
			s: "#editinglayer.foreground .currentselection:after",
			r: "content: \"B\";",
		},
		{
			s: "#editinglayer.background .currentselection:after",
			r: "content: \"a\";",
		},
		// adjust the "Talking to Yourself" box
		{
			s: "#textchat-notifier",
			r: "top: -5px; background-color: red; opacity: 0.5; color: white;",
		},
		{
			s: "#textchat-notifier:after",
			r: "content: '!'",
		},
		{
			s: ".ctx__layer-icon",
			r: `
			display: inline-block;
			width: 12px;
			text-align: center;
			`,
		},
		// fix the shitty undersized "fire" icon
		{
			s: ".choosewalls > .pictostwo",
			r: "width: 15px; height: 17px; display: inline-block; text-align: center;",
		},
		{
			s: "#editinglayer.walls > .pictos",
			r: "width: 20px; height: 22px; display: inline-block; text-align: center; font-size: 0.9em;",
		},
		// weather config window
		{
			s: ".ui-dialog .wth__row",
			r: "margin-bottom: 10px; align-items: center; padding: 0 0 5px; border-bottom: 1px solid #eee;",
		},
		{
			s: ".wth__row select",
			r: "margin-bottom: 0",
		},
		{
			s: `.wth__row input[type="range"]`,
			r: "width: calc(100% - 8px);",
		},
		// context menu
		{
			s: `.ctx__divider`,
			r: "width: calc(100% - 2px); border: 1px solid black;",
		},
		// sidebar fix
		/* {
			s: `#rightsidebar`,
			r: `
			    display: flex;
			    flex-direction: column;
			`
		},
		{
			s: `#rightsidebar ul.tabmenu`,
			r: `
			    padding: 0;
    			flex-shrink: 0;
    			position: relative;
    			top: 0;
    			width: 100%;
			`
		},
		{
			s: `#rightsidebar .ui-tabs-panel`,
			r: `
				height: 100% !important;
				display: block;
				top: 0;
			`
		},
		{
			s: `#textchat-input`,
			r: `
				position: relative;
    			flex-shrink: 0;
			`
		},
		{
			s: `#textchat-input textarea`,
			r: `
				width: calc(100% - 8px) !important;
				resize: vertical;
			`
		}, */
		// Ensure page toolbar is displayed
		{
			s: `#page-toolbar`,
			r: `display: block;`,
		},
	];

	d20plus.css.baseCssRulesPlayer = [
		{
			s: ".player-hidden",
			r: "display: none !important;",
		},
		// Force-hide page toolbar
		{
			s: `#page-toolbar`,
			r: `display: none;`,
		},
	];

	d20plus.css.cssRules = []; // other scripts should populate this

	// Mirrors of 5etools CSS
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		{
			s: ".copied-tip",
			r: "pointer-events: none; position: fixed; background: transparent; user-select: none; z-index: 100000; width: 80px; height: 24px; line-height: 24px;",
		},
		{
			s: ".copied-tip > span",
			r: "display: inline-block; width: 100%; text-align: center;",
		},
		{
			s: ".help",
			r: "cursor: help; text-decoration: underline; text-decoration-style: dotted;",
		},
		{
			s: ".help--subtle",
			r: "cursor: help;",
		},
	]);

	// Art repo browser CSS
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		// full-width images search header
		{
			s: "#imagedialog .searchbox",
			r: "width: calc(100% - 10px)",
		},
		/// ////////////
		{
			s: ".artr__win",
			r: "display: flex; align-items: stretch; width: 100%; height: 100%; padding: 0 !important;",
		},
		// fix box sizing
		{
			s: ".artr__win *",
			r: "box-sizing: border-box;",
		},
		// custom scrollbars
		{
			s: ".artr__win *::-webkit-scrollbar",
			r: "width: 9px; height: 9px;",
		},
		{
			s: ".artr__win *::-webkit-scrollbar-track",
			r: "background: transparent;",
		},
		{
			s: ".artr__win *::-webkit-scrollbar-thumb",
			r: "background: #cbcbcb;",
		},
		/// ////////////
		{
			s: ".artr__side",
			r: "width: 300px; height: 100%; border-right: 1px solid #ccc; background: #f8f8f8; position: relative; flex-shrink: 0; display: flex; flex-direction: column;",
		},
		{
			s: ".artr__side__head",
			r: "flex-shrink: 0; font-weight: bold; margin-bottom: 7px; margin-bottom: 7px; border-bottom: 3px solid #ccc; background: white;",
		},
		{
			s: ".artr__side__head__title",
			r: "font-size: 16px; font-weight: bold;",
		},
		{
			s: ".artr__side__body",
			r: "flex-shrink: 0; overflow-y: auto; transform: translateZ(0);",
		},
		{
			s: ".artr__side__tag_header",
			r: "width: 100%; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; padding: 0 6px; cursor: pointer; margin-bottom: 10px;",
		},
		{
			s: ".artr__side__tag_grid",
			r: "display: flex; width: 100%; flex-wrap: wrap; margin-bottom: 15px; background: #f0f0f0; border-radius: 5px;",
		},
		{
			s: ".artr__side__tag",
			r: "padding: 2px 4px; margin: 2px 4px; font-size: 11px;",
		},
		{
			s: `.artr__side__tag[data-state="1"]`,
			r: "background-image: linear-gradient(#fff, #337ab7);",
		},
		{
			s: `.artr__side__tag[data-state="1"]:hover`,
			r: "background-image: linear-gradient(rgb(#337ab7), rgb(#337ab7)); background-position: 0; transition: none;",
		},
		{
			s: `.artr__side__tag[data-state="2"]`,
			r: "background-image: linear-gradient(#fff, #8a1a1b);",
		},
		{
			s: `.artr__side__tag[data-state="2"]:hover`,
			r: "background-image: linear-gradient(rgb(#8a1a1b), rgb(#8a1a1b)); background-position: 0; transition: none;",
		},
		{
			s: ".artr__main",
			r: "width: 100%; height: 100%; display: flex; overflow-y: auto; flex-direction: column; position: relative;",
		},
		{
			s: ".artr__side__loading, .artr__main__loading",
			r: "width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;     font-style: italic;",
		},
		{
			s: ".artr__bread",
			r: "width: 100%; margin-bottom: 2px;",
		},
		{
			s: ".artr__crumb",
			r: "border: 1px solid #ccc; border-radius: 5px; padding: 0 5px; display: inline-block; cursor: pointer; user-select: none;",
		},
		{
			s: ".artr__crumb--sep",
			r: "border: 0; cursor: default;",
		},
		{
			s: ".artr__search",
			r: "flex-shrink: 0; width: 100%; border-bottom: 1px solid #ccc; display: flex; flex-direction: column;",
		},
		{
			s: ".artr__search__field",
			r: "width: 100%; height: 26px;",
		},
		{
			s: ".artr__view",
			r: "position: absolute; top: 64px; bottom: 0; left: 0; right: 0; overflow-y: auto; transform: translateZ(0); background-color: whitesmoke;",
		},
		{
			s: ".artr__view_inner",
			r: "display: flex; width: 100%; height: 100%; flex-wrap: wrap; align-content: flex-start;",
		},
		{
			s: ".artr__no_results_wrp",
			r: "width: 100%; height: 100%; display: flex; justify-content: center;",
		},
		{
			s: ".artr__no_results",
			r: "width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;",
		},
		{
			s: ".artr__no_results_headline",
			r: "font-size: 125%; font-weight: bold;",
		},
		{
			s: ".artr__item",
			r: "width: 180px; margin: 5px; box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.75); display: block; background: white; position: relative;",
			// Using flex makes scrolling extremely sluggish
			// display: flex; flex-direction: column; cursor: pointer; float: left;
		},
		{
			s: ".artr__item__stats",
			r: "position: absolute; left: 0; top: 0; display: none;",
		},
		{
			s: ".artr__item:hover .artr__item__stats",
			r: "display: block;",
		},
		{
			s: ".artr__item__stats_item",
			r: "color: grey; background: white; border-radius: 5px; margin: 4px 2px; padding: 0 2px; text-align: center; border: 1px solid #e0e0e0",
		},
		{
			s: ".artr__item__menu",
			r: "position: absolute; right: 0; top: 0; display: none;",
		},
		{
			s: ".artr__item:hover .artr__item__menu",
			r: "display: block;",
		},
		{
			s: ".artr__item__menu_item",
			r: "cursor: pointer; color: grey; font-size: 26px; line-height: 24px; border-radius: 5px; margin: 4px; padding: 2px; text-align: center; display: block; border: 1px solid #ccc; background: white;",
		},
		{
			s: ".artr__item--index",
			r: "height: 240px;",
		},
		{
			s: ".artr__item--item",
			r: "height: 180px;",
		},
		{
			s: ".artr__item:hover",
			r: "box-shadow: 0 0 8px 0 rgba(38, 167, 242, 1); opacity: 0.95;",
		},
		{
			s: ".artr__item--back",
			r: "display: flex; justify-content: center; align-items: center; font-size: 24px; color: #888;",
		},
		{
			s: ".artr__item__top",
			r: "width: 100%; height: 180px; flex-shrink: 0; margin: 0 auto; display: flex; align-items: center;",
		},
		{
			s: ".artr__item__top--quart",
			r: "display: flex; flex-wrap: wrap;",
		},
		{
			s: ".artr__item__bottom",
			r: "width: 100%; height: 60px; flex-shrink: 0;  border-top: 1px solid #ccc; background: #f8f8f8; display: flex; flex-direction: column; font-size: 12px; justify-content: space-evenly;",
		},
		{
			s: ".artr__item__bottom__row",
			r: "width: 100% height: 20px; flex-shrink: 0; padding: 4px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;",
		},
		{
			s: ".artr__item__thumbnail",
			r: "max-width: 100%; max-height: 100%; display: block; margin: 0 auto;",
		},
		{
			s: ".atr__item__quart",
			r: "width: 50%; height: 50%; display: block; margin: 0;",
		},
		{
			s: ".atr__item__quart--more",
			r: "display: flex; justify-content: center; align-items: center;",
		},
		{
			s: ".artr__item__full",
			r: "width: 100%; height: 180px; margin: 0 auto; display: flex; align-items: center; padding: 3px;",
		},
		{
			s: ".artr__wrp_big_img",
			r: "position: fixed; top: 0; bottom: 0; right: 0; left: 0; background: #30303080; padding: 30px; display: flex; justify-content: center; align-items: center; z-index: 99999;",
		},
		{
			s: ".artr__big_img",
			r: "display: block; max-width: 100%; max-height: 100%;",
		},
	]);

	// Animator CSS -- `anm__` prefix
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		// fix box sizing
		{
			s: ".anm__win *",
			r: "box-sizing: border-box;",
		},
		{
			s: ".ui-dialog .anm__row",
			r: `
    			display: flex;
    			align-items: center;
    			margin-bottom: 3px;
    			height: 20px;
			`,
		},
		{
			s: ".anm__row > div",
			r: `
				display: inline-flex;
			`,
		},
		{
			s: ".anm__row-btn",
			r: `
				padding: 0 6px;
			`,
		},
		{
			s: ".anm__row-wrp-cb",
			r: `
				justify-content: center;
				align-items: center;
			`,
		},
		{
			s: ".anm__wrp-sel-all",
			r: `
				align-items: center;
				margin-bottom: 5px;
				display: flex;
				justify-content: space-between;
			`,
		},
		{
			s: ".anm-edit__ipt-lines-wrp",
			r: `
				flex-basis: 100%;
				flex-shrink: 100;
			`,
		},
		{
			s: ".anm-edit__gui .anm-edit__gui-hidden",
			r: `
				display: none;
			`,
		},
		{
			s: ".anm-edit__text .anm-edit__gui-visible",
			r: `
				display: none;
			`,
		},
		{
			s: ".anm-edit__ipt-lines-wrp--gui",
			r: `
				overflow-y: auto;
				display: flex;
				flex-direction: column;
			`,
		},
		{
			s: ".anm-edit__ipt-lines-wrp--gui > *",
			r: `
				flex-shrink: 0;
			`,
		},
		{
			s: ".anm-edit__ipt-lines",
			r: `
				resize: none;
				width: 100%;
				height: 100%;
				margin-bottom: 0;
			`,
		},
		{
			s: ".anm-edit__gui-row",
			r: `
				padding: 4px;
				border: 1px solid #ccc;
				border-radius: 3px;
				margin-bottom: 3px;
			`,
		},
		{
			s: ".anm-edit__gui-row:nth-child(even)",
			r: `
				background: #f8f8f8;
			`,
		},
		{
			s: ".anm-edit__gui-row-name",
			r: `
				color: white;
				-webkit-text-stroke: 1px #555;
				text-stroke: 1px black;
				padding: 3px 5px;
				border-radius: 3px;
				font-size: 16px;
				display: inline-block;
				min-width: 150px;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Move",
			r: `
				background: #ff0004;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Rotate",
			r: `
				background: #ff6c00;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Copy",
			r: `
				background: #fff700;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Flip",
			r: `
				background: #a3ff00;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Scale",
			r: `
				background: #5eff00;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Layer",
			r: `
				background: #00ff25;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--Lighting",
			r: `
				background: #00ffb6;
			`,
		},
		{
			s: [
				".anm-edit__gui-row-name--SetProperty",
				".anm-edit__gui-row-name--SumProperty",
			],
			r: `
				background: #006bff;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--TriggerMacro",
			r: `
				background: #0023ff;
			`,
		},
		{
			s: ".anm-edit__gui-row-name--TriggerAnimation",
			r: `
				background: #9800ff;
			`,
		},
		{
			s: ".anm-scene__wrp-tokens",
			r: `
				width: 100%;
				max-height: 100%;
				overflow-y: auto;
				display: flex;
				flex-wrap: wrap;
			`,
		},
		{
			s: ".anm-scene__wrp-token",
			r: `
				width: 80px;
				height: 100px;
				background: #f0f0f0;
				box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.75);
				margin: 4px;
				display: flex;
				flex-direction: column;
				padding: 3px;
			`,
		},
		{
			s: ".anm-scene__wrp-token--active",
			r: `
				background: #a0f0ff;
			`,
		},
		{
			s: ".anm-scene__wrp-token-name",
			r: `
				height: 20px;
				overflow: hidden;
			`,
		},
		{
			s: ".anm-scene__wrp-token-name-inner",
			r: `
				height: 20px;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			`,
		},
		{
			s: ".flex-row",
			r: `
			    display: flex;
			    float: left;
				align-items: center;
			    margin-bottom: 5px;
			`,
		},
		{
			s: ".pagedetails .flex-row input.units,.pagedetails .flex-row input.pixels",
			r: `
				width: 20%;
			    text-align: center;
			    border: 1px solid;
			    border-radius: 5px;
			    margin: 0 2%;
			`,
		},
	]);

	// Jukebox CSS
	d20plus.css.cssRules = d20plus.css.cssRules.concat([
		{
			s: ".jukebox-widget-button",
			r: `
    			flex: 1;
    			text-overflow: ellipsis;
    			overflow: hidden;
    			min-width: 50px;
			`,
		},
		{
			s: ".jukebox-widget-slider",
			r: `
    			margin: 10px;
    			display: inline-block;
    			flex: 15;
			`,
		},
		{
			s: ".jukebox-widget-button",
			r: `
    			letter-spacing: -1px
			`,
		},
	]);
}

SCRIPT_EXTENSIONS.push(baseCss);


function baseUi () {
	d20plus.ui = {};

	d20plus.ui.addHtmlHeader = () => {
		d20plus.ut.log("Add HTML");
		const $body = $("body");

		const $wrpSettings = $(`<div id="betteR20-settings"/>`);
		$("#mysettings > .content").children("hr").first().before($wrpSettings);

		$wrpSettings.append(d20plus.settingsHtmlHeader);
		$body.append(d20plus.configEditorHTML);
		if (window.is_gm) {
			$(`#imagedialog`).find(`.searchbox`).find(`.tabcontainer`).first().after(d20plus.artTabHtml);
			$(`#button-add-external-art`).on(window.mousedowntype, d20plus.art.button);

			$body.append(d20plus.addArtHTML);
			$body.append(d20plus.addArtMassAdderHTML);
			$body.append(d20plus.tool.toolsListHtml);
			$("#d20plus-artfolder").dialog({
				autoOpen: false,
				resizable: true,
				width: 1000,
				height: 800,
			});
			$("#d20plus-artmassadd").dialog({
				autoOpen: false,
				resizable: true,
				width: 800,
				height: 650,
			});
		}
		const $cfgEditor = $("#d20plus-configeditor");
		$cfgEditor.dialog({
			autoOpen: false,
			resizable: true,
			width: 800,
			height: 650,
		});
		$cfgEditor.parent().append(d20plus.configEditorButtonBarHTML);

		// shared GM/player conent
		// quick search box
		const $iptSearch = $(`<input id="player-search" class="ui-autocomplete-input" autocomplete="off" placeholder="Quick search by name...">`);
		const $wrprResults = $(`<div id="player-search-results" class="content searchbox"/>`);

		if (window.is_gm) {
			$iptSearch.css("width", "calc(100% - 5px)");
			const $addPoint = $("#journal").find("button.btn.superadd");
			$addPoint.after($wrprResults);
			$addPoint.after(`<br>`);
			$addPoint.after($iptSearch);
			$addPoint.after(`<br><br>`);
		} else {
			const $wrprControls = $(`<div class="content searchbox" id="search-wrp-controls"/>`);
			$(`#journal .content`).before($wrprControls).before($wrprResults);
			$iptSearch.css("max-width", "calc(100% - 140px)");
			$wrprControls.append($iptSearch);
		}
		d20plus.engine.initQuickSearch($iptSearch, $wrprResults);
	};

	d20plus.ui.addHtmlFooter = () => {
		const $wrpSettings = $(`#betteR20-settings`);
		$wrpSettings.append(d20plus.settingsHtmlPtFooter);

		$("#mysettings > .content a#button-edit-config").on(window.mousedowntype, d20plus.cfg.openConfigEditor);
		d20plus.tool.addTools();
	};

	d20plus.ui.addQuickUiGm = () => {
		const $wrpBtnsMain = $(`#floatingtoolbar`);

		// add quick layer selection panel
		const $ulBtns = $(`<div id="floatinglayerbar"><ul/></div>`)
			.css({
				width: 30,
				position: "absolute",
				left: 20,
				top: $wrpBtnsMain.height() + 45,
				border: "1px solid #666",
				boxShadow: "1px 1px 3px #666",
				zIndex: 10600,
				backgroundColor: "rgba(255,255,255,0.80)",
			})
			.appendTo($(`body`)).find(`ul`);

		const handleClick = (clazz, evt) => $wrpBtnsMain.find(`.${clazz}`).trigger("click", evt);
		$(`<li title="Map" class="choosemap"><span class="pictos" style="padding: 0 3px;">@</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosemap`, evt));
		$(`<li title="Background" class="choosebackground"><span class="pictos">a</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosebackground`, evt));
		$(`<li title="Objects & Tokens" class="chooseobjects"><span class="pictos">b</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`chooseobjects`, evt));
		$(`<li title="Foreground" class="chooseforeground"><span class="pictos">B</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`chooseforeground`, evt));
		$(`<li title="GM Info Overlay" class="choosegmlayer"><span class="pictos">E</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosegmlayer`, evt));
		$(`<li title="Dynamic Lighting" class="choosewalls"><span class="pictostwo">r</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`choosewalls`, evt));
		$(`<li title="Weather Exclusions" class="chooseweather"><span class="pictos">C</span></li>`).appendTo($ulBtns).click((evt) => handleClick(`chooseweather`, evt));

		$("body").on("click", "#editinglayer li", function () {
			$("#floatinglayerbar").removeClass("map")
				.removeClass("background")
				.removeClass("objects")
				.removeClass("foreground")
				.removeClass("gmlayer")
				.removeClass("walls")
				.removeClass("weather");
			setTimeout(() => {
				$("#floatinglayerbar").addClass(window.currentEditingLayer)
			}, 1);
		});

		// add "desc sort" button to init tracker
		const $initTracker = $(`#initiativewindow`);
		const addInitSortBtn = () => {
			$(`<div class="btn" id="init-quick-sort-desc" style="margin-right: 5px;"><span class="pictos">}</span></div>`).click(() => {
				// this will throw a benign error if the settings dialog has never been opened
				$("#initiativewindow_settings .sortlist_numericdesc").click();
			}).prependTo($initTracker.parent().find(`.ui-dialog-buttonset`));
		};
		if (d20.Campaign.initiativewindow.model.attributes.initiativepage) {
			addInitSortBtn();
		} else {
			d20.Campaign.initiativewindow.model.on("change", (e) => {
				if (d20.Campaign.initiativewindow.model.attributes.initiativepage && $(`#init-quick-sort-desc`).length === 0) {
					addInitSortBtn();
					d20plus.cfg.baseHandleConfigChange();
				}
			})
		}
	};

	/**
	 * Prompt the user to choose from a list of checkboxes. By default, one checkbox can be selected, but a "count"
	 * option can be provided to allow the user to choose multiple options.
	 *
	 * @param dataArray options to choose from
	 * @param dataTitle title for the window
	 * @param displayFormatter function to format dataArray for display
	 * @param count exact number of  options the user must, mutually exclusive with countMin and countMax
	 * @param countMin lowest number of options the user must choose, requires countMax, mutually exclusive with count
	 * @param countMax highest number of options the user must choose, requires countMax, mutually exclusive with count
	 * @param additionalHTML additional html code, such as a button
	 * @param note add a note at the bottom of the window
	 * @param messageCountIncomplete message when user does not choose correct number of choices
	 * @param random show button for random choices
	 * @param randomMax Enforce max random choices
	 * @param totallyRandom select randomly number of items between countMin and countMax. Requires count to be null. This has higher priority than randomMax
	 * @return {Promise}
	 */
	d20plus.ui.chooseCheckboxList = async function (dataArray, dataTitle, {displayFormatter = null, count = null, countMin = null, countMax = null, additionalHTML = null, note = null, messageCountIncomplete = null , random = null, randomMax = null, totallyRandom = null} = {}) {
		return new Promise((resolve, reject) => {
			// Ensure count, countMin, and countMax don't mess up
			// Note if(var) is false if the number is 0. countMin is the only count allowed to be 0
			if ((Number.isInteger(count) && Number.isInteger(countMin))
			|| (Number.isInteger(count) && Number.isInteger(countMax))
			|| (count == null && (Number.isInteger(countMin) ^ Number.isInteger(countMax)))
			|| (countMin > countMax)) {
				reject(new Error("Bad arguments--count is mutually exclusive with countMin and countMax, and countMin and countMax require each other."))
			}
			const useRange = Number.isInteger(countMin) && countMax;

			// Generate the HTML
			const $dialog = $(`
				<div title="${dataTitle}">
					${Number.isInteger(count) ? `<div name="remain" class="bold">Remaining: ${count}</div>` : ""}
					${Number.isInteger(countMax) ? `<div name="remain" class="bold">Remaining: ${countMax}, Minimum: ${countMin}</div>` : ""}
					<div>
						${dataArray.map(it => `<label class="split"><span>${displayFormatter ? displayFormatter(it) : it}</span> <input data-choice="${it}" type="checkbox"></label>`).join("")}
					</div>
					${additionalHTML ? `<br><div>${additionalHTML}</div>` : ""}
					${note ? `<br><div class="italic">${note}</div>` : ""}
				</div>
			`).appendTo($("body"));
			const $remain = $dialog.find(`[name="remain"]`);
			const $cbChoices = $dialog.find(`input[type="checkbox"]`);

			// Ensure the proper number of items is chosen
			if (count != null || useRange) {
				const targetCount = count || countMax;
				const remainMin = countMax ? `, Minimum: ${countMin}` : "";
				$cbChoices.on("change", function () {
					const $e = $(this);
					let selectedCount = getSelected().length;
					if (selectedCount > targetCount) {
						$e.prop("checked", false);
						selectedCount--;
					}
					$remain.text(`Remaining: ${targetCount - selectedCount}${remainMin}`);
				});
			}

			function getSelected () {
				return $cbChoices.map((i, e) => ({choice: $(e).data("choice"), selected: $(e).prop("checked")})).get()
					.filter(it => it.selected).map(it => it.choice);
			}

			// Accept or reject selection
			$dialog.dialog({
				dialogClass: "no-close",
				buttons: [
					{
						text: "Cancel",
						click: function () {
							$(this).dialog("close");
							$dialog.remove();
							reject(new Error(`User cancelled the prompt`));
						},
					},
					(random?{
						text: "Choose randomly",
						click: function () {
							document.querySelectorAll('input[type=checkbox]').forEach(el => el.checked = false);
							var alreadySelected=[];
							if (count != null){
								for (var i=0;i<count;i++){
									var randomSelection=dataArray[Math.floor(Math.random()*dataArray.length)];
									while(alreadySelected.includes(randomSelection)){
										randomSelection=dataArray[Math.floor(Math.random()*dataArray.length)];
									}
									alreadySelected.push(randomSelection);
									var chkbx=document.querySelector("[data-choice=\""+randomSelection+"\"]");
									chkbx.checked=true;
								}
							}else{
								if (totallyRandom){
									var loops=Math.floor(Math.random() * (countMax - countMin + 1) + countMin);
								}else{
									var loops=randomMax?countMax:countMin;
								}
								
								for (var i=0;i<loops;i++){
									var randomSelection=dataArray[Math.floor(Math.random()*dataArray.length)];
									if (randomMax){
										while(alreadySelected.includes(randomSelection)){
											randomSelection=dataArray[Math.floor(Math.random()*dataArray.length)];
										}
									}
									alreadySelected.push(randomSelection);
									var chkbx=document.querySelector("[data-choice=\""+randomSelection+"\"]");
									chkbx.checked=true;
								}
							}
							
						},
					}:null),
					{
						text: "OK",
						click: function () {
							const selected = getSelected();
							if (Number.isInteger(countMin) && countMax && count == null && selected.length >= countMin && selected.length <= countMax) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else if (!useRange && (selected.length === count || count == null)) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else {
								alert(messageCountIncomplete ?? "Please select more options!");
							}
						},
					},
				].filter(Boolean),
			})
		});
	};

	/**
	 * Prompt the user to choose from a list of radios. Radio button allow exactly one choice. 
	 *
	 * @param dataArray options to choose from
	 * @param dataTitle title for the window
	 * @param displayFormatter function to format dataArray for display
	 * @param random show button for random choices
	 * @param additionalHTML additional html code, such as a button
	 * @param note add a note at the bottom of the window
	 * @param messageCountIncomplete message when user does not choose correct number of choices
	 * @return {Promise}
	 */
	 d20plus.ui.chooseRadioList = async function (dataArray, dataTitle, {displayFormatter = null, random = null, additionalHTML = null, note = null, messageCountIncomplete = null} = {}) {
		return new Promise((resolve, reject) => {


			// Generate the HTML
			const $dialog = $(`
				<div title="${dataTitle}">
					<div>
						${dataArray.map(it => `<label class="split"><span>${displayFormatter ? displayFormatter(it) : it}</span> <input data-choice="${it}" type="radio" name="`+dataTitle+`"></label>`).join("")}
					</div>
					${additionalHTML ? `<br><div>${additionalHTML}</div>` : ""}
					${note ? `<br><div class="italic">${note}</div>` : ""}
				</div>
			`).appendTo($("body"));
			const $remain = $dialog.find(`[name="remain"]`);
			const $cbChoices = $dialog.find(`input[type="radio"]`);


			function getSelected () {
				return $cbChoices.map((i, e) => ({choice: $(e).data("choice"), selected: $(e).prop("checked")})).get()
					.filter(it => it.selected).map(it => it.choice);
			}

			// Accept or reject selection
			$dialog.dialog({
				dialogClass: "no-close",
				buttons: [
					{
						text: "Cancel",
						click: function () {
							$(this).dialog("close");
							$dialog.remove();
							reject(new Error(`User cancelled the prompt`));
						},
					},
					(random?{
						text: "Choose randomly",
						click: function () {
							const randomSelection=dataArray[Math.floor(Math.random()*dataArray.length)];
							const radio=document.querySelector("[data-choice=\""+randomSelection+"\"]");
							radio.checked=true;
						},
					}:null),
					{
						text: "OK",
						click: function () {
							const selected = getSelected();
							if (selected.length == 1) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else if (!useRange && (selected.length === count || count == null)) {
								$(this).dialog("close");
								$dialog.remove();
								resolve(selected);
							} else {
								alert(messageCountIncomplete ?? "Please an option!");
							}
						},
					},
				].filter(Boolean),
			})
		});
	};
}

SCRIPT_EXTENSIONS.push(baseUi);


/**
 * All the modified minified based on parts of Roll20's `app.js`
 */
function d20plusMod () {
	d20plus.mod = {};

	/* eslint-disable */

	// modified to allow players to use the FX tool, and to keep current colour selections when switching tool
	// BEGIN ROLL20 CODE
	d20plus.mod.setMode = function (e) {
		d20plus.ut.log("Setting mode " + e);
		// BEGIN MOD
		// "text" === e || "rect" === e || "ellipse" === e || "polygon" === e || "path" === e || "pan" === e || "select" === e || "targeting" === e || "measure" === e || window.is_gm || (e = "select"),
		// END MOD
		"text" == e ? $("#editor").addClass("texteditmode") : $("#editor").removeClass("texteditmode"),
			$("#floatingtoolbar li").removeClass("activebutton"),
			$("#" + e).addClass("activebutton"),
		"fog" == e.substring(0, 3) && $("#fogcontrols").addClass("activebutton");

		const drawingTools = ["rect", "ellipse", "text", "path", "polygon", "line_splitter"];
		if (drawingTools.includes(e)) {
			if ("ellipse" == e) $('#drawingtools span.subicon').addClass('fas fa-circle');
			else $('#drawingtools span.subicon').removeClass('fas fa-circle');
			$("#drawingtools").addClass("activebutton").removeClass("text rect ellipse path polygon line_splitter");
			"rect" == e && $("#drawingtools").addClass("rect");
			"ellipse" == e && $("#drawingtools").addClass("ellipse");
			"text" == e && $("#drawingtools").addClass("activebutton").removeClass("rect ellipse path polygon line_splitter").addClass("text");
			"path" == e && $("#drawingtools").addClass("path");
			"polygon" == e && $("#drawingtools").addClass("polygon");
			// BEGIN MOD (also line_splitter added to above removeClass calls
			"line_splitter" == e && $("#drawingtools").addClass("line_splitter");
			// END MOD
		}
		"polygon" != e && d20.engine.finishCurrentPolygon();

		"pan" !== e && "select" !== e && d20.engine.unselect(),
			"pan" == e ? ($("#select").addClass("pan").removeClass("select").addClass("activebutton"),
				d20.token_editor.removeRadialMenu(),
				$("#editor-wrapper").addClass("panning")) : $("#editor-wrapper").removeClass("panning"),
		"select" == e && $("#select").addClass("select").removeClass("pan").addClass("activebutton"),
			$("#floatingtoolbar .mode").hide(),
		("text" == e || "select" == e) && $("#floatingtoolbar ." + e).show(),
			"gridalign" == e ? $("#gridaligninstructions").show() : "gridalign" === d20.engine.mode && $("#gridaligninstructions").hide(),
			"targeting" === e ? ($("#targetinginstructions").show(),
				$("#finalcanvas").addClass("targeting"),
				d20.engine.canvas.hoverCursor = "crosshair") : "targeting" === d20.engine.mode && ($("#targetinginstructions").hide(),
				$("#finalcanvas").removeClass("targeting"),
			d20.engine.nextTargetCallback && _.defer(function () {
				d20.engine.nextTargetCallback && d20.engine.nextTargetCallback(!1)
			}),
				d20.engine.canvas.hoverCursor = "move"),
			// BEGIN MOD
			// console.log("Switch mode to " + e),
			d20.engine.mode = e,
		"measure" !== e && window.currentPlayer && d20.engine.measurements[window.currentPlayer.id] && !d20.engine.measurements[window.currentPlayer.id].sticky && (d20.engine.announceEndMeasure({
			player: window.currentPlayer.id
		}),
			d20.engine.endMeasure()),
			d20.engine.canvas.isDrawingMode = "path" == e ? !0 : !1;
		if ("text" == e || "path" == e || "rect" == e || "ellipse" == e || "polygon" == e || "fxtools" == e) {
			$("#secondary-toolbar").show();
			$("#secondary-toolbar .mode").hide();
			$("#secondary-toolbar ." + e).show();
			("path" == e || "rect" == e || "ellipse" == e || "polygon" == e) && ("" === $("#path_strokecolor").val() && ($("#path_strokecolor").val("#000000").trigger("change-silent"),
				$("#path_fillcolor").val("transparent").trigger("change-silent")),
				d20.engine.canvas.freeDrawingBrush.color = $("#path_strokecolor").val(),
				d20.engine.canvas.freeDrawingBrush.fill = $("#path_fillcolor").val() || "transparent",
				$("#path_width").trigger("change")),
			"fxtools" == e && "" === $("#fxtools_color").val() && $("#fxtools_color").val("#a61c00").trigger("change-silent"),
				$("#floatingtoolbar").trigger("blur")
		} else {
			$("#secondary-toolbar").hide();
			$("#floatingtoolbar").trigger("blur");
		}
		// END MOD
		'placelight' === e ? ($('#placelight').addClass('activebutton'), $('#finalcanvas').addClass('torch-cursor')) : $('#finalcanvas').removeClass('torch-cursor'),
		d20.engine.redrawScreenNextTick()
	};
	// END ROLL20 CODE

	d20plus.mod.overwriteStatusEffects = function () {
		d20.engine.canvasDirty = true;
		d20.engine.canvasTopDirty = true;
		d20.engine.canvas._objects.forEach(it => {
			// avoid adding it to any objects that wouldn't have it to begin with
			if (!it.model || !it.model.view || !it.model.view.updateBackdrops) return;

			// BEGIN ROLL20 CODE
			it.model.view.updateBackdrops = function (e) {
				if (!this.nohud && ("objects" == this.model.get("layer") || "gmlayer" == this.model.get("layer")) && "image" == this.model.get("type") && this.model && this.model.collection && this.graphic) {
					// BEGIN MOD
					const scaleFact = (d20plus.cfg.get("canvas", "scaleNamesStatuses") && d20.Campaign.activePage().get("snapping_increment"))
						? d20.Campaign.activePage().get("snapping_increment")
						: 1;
					// END MOD
					var t = this.model.collection.page
						, n = e || d20.engine.canvas.getContext();
					n.save(),
					(this.graphic.get("flipX") || this.graphic.get("flipY")) && n.scale(this.graphic.get("flipX") ? -1 : 1, this.graphic.get("flipY") ? -1 : 1);
					var i = this
						, r = Math.floor(this.graphic.get("width") / 2)
						, o = Math.floor(this.graphic.get("height") / 2)
						, a = (parseFloat(t.get("scale_number")),
						this.model.get("statusmarkers").split(","));
					-1 !== a.indexOf("dead") && (n.strokeStyle = "rgba(189,13,13,0.60)",
						n.lineWidth = 10,
						n.beginPath(),
						n.moveTo(-r + 7, -o + 15),
						n.lineTo(r - 7, o - 5),
						n.moveTo(r - 7, -o + 15),
						n.lineTo(-r + 7, o - 5),
						n.closePath(),
						n.stroke()),
						n.rotate(-this.graphic.get("angle") * Math.PI / 180),
						n.strokeStyle = "rgba(0,0,0,0.65)",
						n.lineWidth = 1;
					var s = 0
						, l = i.model.get("bar1_value")
						, c = i.model.get("bar1_max");
					if ("" != c && (window.is_gm || this.model.get("showplayers_bar1") || this.model.currentPlayerControls() && this.model.get("playersedit_bar1"))) {
						var u = parseInt(l, 10) / parseInt(c, 10)
							, d = -o - 20 + 0;
						n.fillStyle = "rgba(" + d20.Campaign.tokendisplay.bar1_rgb + ",0.75)",
							n.beginPath(),
							n.rect(-r + 3, d, Math.floor((2 * r - 6) * u), 8),
							n.closePath(),
							n.fill(),
							n.beginPath(),
							n.rect(-r + 3, d, 2 * r - 6, 8),
							n.closePath(),
							n.stroke(),
							s++
					}
					var l = i.model.get("bar2_value")
						, c = i.model.get("bar2_max");
					if ("" != c && (window.is_gm || this.model.get("showplayers_bar2") || this.model.currentPlayerControls() && this.model.get("playersedit_bar2"))) {
						var u = parseInt(l, 10) / parseInt(c, 10)
							, d = -o - 20 + 12;
						n.fillStyle = "rgba(" + d20.Campaign.tokendisplay.bar2_rgb + ",0.75)",
							n.beginPath(),
							n.rect(-r + 3, d, Math.floor((2 * r - 6) * u), 8),
							n.closePath(),
							n.fill(),
							n.beginPath(),
							n.rect(-r + 3, d, 2 * r - 6, 8),
							n.closePath(),
							n.stroke(),
							s++
					}
					var l = i.model.get("bar3_value")
						, c = i.model.get("bar3_max");
					if ("" != c && (window.is_gm || this.model.get("showplayers_bar3") || this.model.currentPlayerControls() && this.model.get("playersedit_bar3"))) {
						var u = parseInt(l, 10) / parseInt(c, 10)
							, d = -o - 20 + 24;
						n.fillStyle = "rgba(" + d20.Campaign.tokendisplay.bar3_rgb + ",0.75)",
							n.beginPath(),
							n.rect(-r + 3, d, Math.floor((2 * r - 6) * u), 8),
							n.closePath(),
							n.fill(),
							n.beginPath(),
							n.rect(-r + 3, d, 2 * r - 6, 8),
							n.closePath(),
							n.stroke()
					}
					var h, p, g = 1, f = !1;
					switch (d20.Campaign.get("markers_position")) {
						case "bottom":
							h = o - 10,
								p = r;
							break;
						case "left":
							h = -o - 10,
								p = -r,
								f = !0;
							break;
						case "right":
							h = -o - 10,
								p = r - 18,
								f = !0;
							break;
						default:
							h = -o + 10,
								p = r
					}
					// BEGIN MOD
					n.strokeStyle = "white";
					n.lineWidth = 3 * scaleFact;
					const scaledFont = 14 * scaleFact;
					n.font = "bold " + scaledFont + "px Arial";
					// END MOD
					_.each(a, function (e) {
						var t = d20.token_editor.statusmarkers[e.split("@")[0]];
						if (!t)
							return !0;
						if ("dead" === e)
							return !0;
						var i = 0;
						if (g--,
						"#" === t.substring(0, 1))
							n.fillStyle = t,
								n.beginPath(),
								f ? h += 16 : p -= 16,
								n.arc(p + 8, f ? h + 4 : h, 6, 0, 2 * Math.PI, !0),
								n.closePath(),
								n.stroke(),
								n.fill(),
								i = f ? 10 : 4;
						else {
							// BEGIN MOD
							if (!d20.token_editor.statussheet_ready) return;
							const scaledWH = 21 * scaleFact;
							const scaledOffset = 22 * scaleFact;
							f ? h += scaledOffset : p -= scaledOffset;

							if (d20.engine.canvasZoom <= 1) {
								n.drawImage(d20.token_editor.statussheet_small, parseInt(t, 10), 0, 21, 21, p, h - 9, scaledWH, scaledWH);
							} else {
								n.drawImage(d20.token_editor.statussheet, parseInt(t, 10), 0, 24, 24, p, h - 9, scaledWH, scaledWH)
							}

							i = f ? 14 : 12;
							i *= scaleFact;
							// END MOD
						}
						if (-1 !== e.indexOf("@")) {
							var r = e.split("@")[1];
							// BEGIN MOD
							// bing backtick to "clear counter"
							if (r === "`") return;
							n.fillStyle = "rgb(222,31,31)";
							var o = f ? 9 : 14;
							o *= scaleFact;
							o -= (14 - (scaleFact * 14));
							n.strokeText(r + "", p + i, h + o);
							n.fillText(r + "", p + i, h + o);
							// END MOD
						}
					});
					var m = i.model.get("name");
					if ("" != m && 1 == this.model.get("showname") && (window.is_gm || this.model.get("showplayers_name") || this.model.currentPlayerControls() && this.model.get("playersedit_name"))) {
						n.textAlign = "center";
						// BEGIN MOD
						const fontSize = 14;
						var scaledFontSize = fontSize * scaleFact;
						const scaledY = 22 * scaleFact;
						const scaled6 = 6 * scaleFact;
						const scaled8 = 8 * scaleFact;
						n.font = "bold " + scaledFontSize + "px Arial";
						var v = n.measureText(m).width;

						/*
							Note(stormy): compatibility with R20ES's ScaleTokenNamesBySize module.
						 */
						if(window.r20es && window.r20es.drawNameplate) {
							window.r20es.drawNameplate(this.model, n, v, o, fontSize, m);
						} else {
							n.fillStyle = "rgba(255,255,255,0.50)";
							n.fillRect(-1 * Math.floor((v + scaled6) / 2), o + scaled8, v + scaled6, scaledFontSize + scaled6);
							n.fillStyle = "rgb(0,0,0)";
							n.fillText(m + "", 0, o + scaledY, v);
						}
						// END MOD
					}
					n.restore()
				}
			}
			// END ROLL20 CODE
		});
	};

	d20plus.mod.mouseEnterMarkerMenu = function () {
		var e = this;
		$(this).on("mouseover.statusiconhover", ".statusicon", function () {
			a = $(this).attr("data-action-type").replace("toggle_status_", "")
		}),
			$(document).on("keypress.statusnum", function (t) {
				// BEGIN MOD // TODO see if this clashes with keyboard shortcuts
				let currentcontexttarget = d20.engine.selected()[0];
				if ("dead" !== a && currentcontexttarget) {
					// END MOD
					var n = String.fromCharCode(t.which)
						,
						i = "" == currentcontexttarget.model.get("statusmarkers") ? [] : currentcontexttarget.model.get("statusmarkers").split(",")
						, r = (_.map(i, function (e) {
							return e.split("@")[0]
						}),
							!1);
					i = _.map(i, function (e) {
						return e.split("@")[0] == a ? (r = !0,
						a + "@" + n) : e
					}),
					r || ($(e).find(".statusicon[data-action-type=toggle_status_" + a + "]").addClass("active"),
						i.push(a + "@" + n)),
						currentcontexttarget.model.save({
							statusmarkers: i.join(",")
						})
				}
			})
	};

	// BEGIN ROLL20 CODE
	d20plus.mod.handleURL = function(e) {
		if (!($(this).hasClass("lightly") || $(this).parents(".note-editable").length > 0)) {
			var t = $(this).attr("href");
			if (void 0 === t)
				return !1;
			if (-1 !== t.indexOf("journal.roll20.net") || -1 !== t.indexOf("wiki.roll20.net")) {
				var n = t.split("/")[3]
					, i = t.split("/")[4]
					, o = d20.Campaign[n + "s"].get(i);
				if (o) {
					var r = o.get("inplayerjournals").split(",");
					(window.is_gm || -1 !== _.indexOf(r, "all") || window.currentPlayer && -1 !== _.indexOf(r, window.currentPlayer.id)) && o.view.showDialog()
				}
				return $("#existing" + n + "s").find("tr[data-" + n + "id=" + i + "]").trigger("click"),
					!1
			}
			var a = /(?:(?:http(?:s?):\/\/(?:app\.)?roll20(?:staging)?\.(?:net|local:5000)\/|^\/?)compendium\/)([^\/]+)\/([^\/#?]+)/i
				, s = t.match(a);
			if (s)
				return d20.utils.openCompendiumPage(s[1], s[2]),
					e.stopPropagation(),
					void e.preventDefault();
			if (-1 !== t.indexOf("javascript:"))
				return !1;
			if ("`" === t.substring(0, 1))
				return d20.textchat.doChatInput(t.substring(1)),
					!1;
			if ("!" === t.substring(0, 1))
				return d20.textchat.doChatInput(t),
					!1;
			if ("~" === t.substring(0, 1))
				return d20.textchat.doChatInput("%{" + t.substring(1, t.length) + "}"),
					!1;
			if (t !== undefined && ("external" === $(this).attr("rel") || -1 === t.indexOf("javascript:") && -1 !== t.indexOf("://"))) {
				// BEGIN MOD
				e.stopPropagation();
				e.preventDefault();
				window.open(t);
				// END MOD
			}
		}
	};
	// END ROLL20 CODE

	d20plus.mod._renderAll_middleLayers = new Set(["objects", "background", "foreground"]);
	// BEGIN ROLL20 CODE
	d20plus.mod.renderAll = function (e) {
		const t = e && e.context || this.contextContainer
			, i = this.getActiveGroup()
			, n = [d20.engine.canvasWidth / d20.engine.canvasZoom, d20.engine.canvasHeight / d20.engine.canvasZoom]
			, o = new d20.math.Rectangle(...d20.math.add(d20.engine.currentCanvasOffset, d20.math.div(n, 2)),...n,0);
		i && !window.is_gm && (i.hideResizers = !0),
			this.clipTo ? fabric.util.clipContext(this, t) : t.save();
		const r = {
			map: [],
			// BEGIN MOD
			background: [],
			// END MOD
			walls: [],
			objects: [],
			// BEGIN MOD
			foreground: [],
			// END MOD
			gmlayer: []
			// BEGIN MOD
			, weather: [],
			// END MOD
			_save_map_layer: this._save_map_layer
		};
		r[Symbol.iterator] = this._layerIteratorGenerator.bind(r, e);
		const a = e && e.tokens_to_render || this._objects;
		for (let e of a)
			if (e.model) {
				const t = e.model.get("layer");
				if (!r[t])
					continue;
				r[t].push(e)
			} else
				r[window.currentEditingLayer].push(e);

		// BEGIN MOD
		// Here we get the layers and look if there's a foreground in the current map
		let layers = d20.engine.canvas._objects.map(it => it.model?.get("layer") || window.currentEditingLayer)
		const noForegroundLayer = !layers.some(it => it === 'foreground');
		// END MOD

		for (const [n,a] of r) {
			switch (a) {
				case "lighting and fog":
					d20.engine.drawHighlights(this.contextContainer), d20.dyn_fog.render({
						main_canvas: this.contextContainer.canvas
					});
					continue;
				case "grid":
					d20.canvas_overlay.drawGrid(t);
					continue;
				case "afow":
					d20.canvas_overlay.drawAFoW(d20.engine.advfowctx, d20.engine.work_canvases.floater.context);
					continue;
				case "gmlayer":
					t.globalAlpha = d20.engine.gm_layer_opacity;
					break;
				// BEGIN MOD
				case "background":
				case "foreground":
					if (d20plus.mod._renderAll_middleLayers.has(window.currentEditingLayer) && window.currentEditingLayer !== a && window.currentEditingLayer !== "objects") {
						t.globalAlpha = .45;
						break;
					}
				// END MOD
				case "objects":
					if ("map" === window.currentEditingLayer || "walls" === window.currentEditingLayer) {
						t.globalAlpha = .45;
						break
					}
				default:
					t.globalAlpha = 1
			}
			_.chain(n).filter(n=>{
					let r;
					return i && n && i.contains(n) ? (n.renderingInGroup = i,
						n.hasControls = !1) : (n.renderingInGroup = null,
						n.hasControls = !0,
						"text" !== n.type && window.is_gm ? n.hideResizers = !1 : n.hideResizers = !0),
						e && e.invalid_rects ? (r = n.intersects([o]) && (n.needsToBeDrawn || n.intersects(e.invalid_rects)),
						!e.skip_prerender && n.renderPre && n.renderPre(t)) : (r = n.needsRender(o),
						(!e || !e.skip_prerender) && r && n.renderPre && n.renderPre(t, {
							should_update: !0
						})),
						r
				}
			).each(i=> {
				// BEGIN MOD
				let toRender = false;
				// END MOD

				const n = "image" === i.type.toLowerCase() && i.model.controlledByPlayer(window.currentPlayer.id)

				// BEGIN MOD
				// If there is a foreground layer, do not give "owned tokens with sight" special treatment;
				//   render them during the normal render flow (rather than skipping them)
				 const o = noForegroundLayer ? e && e.owned_with_sight_auras_only : false;
				// END MOD

				let r = i._model;
				r && d20.dyn_fog.ready() ? r = i._model.get("has_bright_light_vision") || i._model.get("has_low_light_vision") || i._model.get("has_night_vision") : r && (r = i._model.get("light_hassight")),
				// BEGIN MOD
				// We don't draw immediately the token. Instead, we mark it as "to render"
				o && (!o || n && r) || (toRender = true);

				if (toRender) {
					// For the token checked "to render", we draw them if
					//  - we're in a "render everything" call (i.e. no specific `tokens_to_render`), rather than a "render own tokens" call
					//  - there isn't a foreground layer for the map or
					//  - is everything but an object
					if (!e.tokens_to_render || noForegroundLayer || a !== 'objects') {
						this._draw(t, i);
					}
					i.renderingInGroup = null;
				}
				// END MOD
			})
		}
		return t.restore(),
			this
	};
	// END ROLL20 CODE

	// shoutouts to Roll20 for making me learn how `yield` works
	// BEGIN ROLL20 CODE
	d20plus.mod.layerIteratorGenerator = function*(e) {
		yield [this.map, "map"],
		this._save_map_layer && (d20.dyn_fog.setMapTexture(d20.engine.canvas.contextContainer),
			this._save_map_layer = !1);
		if (window.is_gm && "walls" === window.currentEditingLayer) yield [this.walls, "walls"];

		const grid_before_afow = e && e.grid_before_afow;
		const adv_fow_disabled = !d20.Campaign.activePage().get("adv_fow_enabled") || e && e.disable_afow;
		const grid_hide = !d20.Campaign.activePage().get("showgrid") || e && e.disable_grid;

		if (grid_before_afow && !grid_hide) yield [null, "grid"];
		if (!adv_fow_disabled) yield [null, "afow"];
		if (!grid_before_afow && !grid_hide) yield [null, "grid"];

		// BEGIN MOD
		yield [this.background, "background"];
		// END MOD

		yield [this.objects, "objects"];

		// BEGIN MOD
		yield [this.foreground, "foreground"];
		// END MOD

		if (window.is_gm) yield [this.gmlayer, "gmlayer"];

		const enable_dynamic_fog = e && e.enable_dynamic_fog;
		if (d20.dyn_fog.ready() && enable_dynamic_fog) yield [null, "lighting and fog"];

		// BEGIN MOD
		if (window.is_gm && "weather" === window.currentEditingLayer) yield [this.weather, "weather"];
		// END MOD
	};
	// END ROLL20 CODE

	// BEGIN ROLL20 CODE
	d20plus.mod.editingLayerOnclick = () => {
		$("#editinglayer").off(clicktype).on(clicktype, "li", function() {
			var e = $(this);
			$("#editinglayer").removeClass(window.currentEditingLayer);
			$("#drawingtools .choosepath").show();
			"polygon" !== d20.engine.mode && $("#drawingtools").hasClass("polygon") && $("#drawingtools").removeClass("polygon").addClass("path");

			// BEGIN MOD
			if (e.hasClass("chooseweather")) {
				window.currentEditingLayer = "weather";
				$("#drawingtools .choosepath").hide();
				"path" !== d20.engine.mode && $("#drawingtools").removeClass("path").addClass("polygon")
			} else {
				e.hasClass("choosebackground") ? window.currentEditingLayer = "background" : e.hasClass("chooseforeground") ? window.currentEditingLayer = "foreground" : e.hasClass("chooseobjects") ? window.currentEditingLayer = "objects" : e.hasClass("choosemap") ? window.currentEditingLayer = "map" : e.hasClass("choosegmlayer") ? window.currentEditingLayer = "gmlayer" : e.hasClass("choosewalls") && (window.currentEditingLayer = "walls",
					$("#drawingtools .choosepath").hide(),
				"path" !== d20.engine.mode && $("#drawingtools").removeClass("path").addClass("polygon"));
			}
			// END MOD
			$("#editinglayer").addClass(window.currentEditingLayer);
			$(document).trigger("d20:editingLayerChanged");
		});
	};
	// END ROLL20 CODE

	// prevent prototype methods from breaking some poorly-written property loops
	d20plus.mod.fixHexMethods = () => {
		try {
			// BEGIN ROLL20 CODE
			HT.Grid.prototype.GetHexAt = function(e) {
				// BEGIN MOD
				for (const t of this.Hexes)
					if (t.Contains(e))
						return t;
				// END MOD
				return null
			};
			// END ROLL20 CODE
		} catch (ignored) {
			console.error(ignored)
		}

		try {
			// BEGIN ROLL20 CODE
			HT.Grid.prototype.GetHexById = function(e) {
				// BEGIN MOD
				for (const t of this.Hexes)
					if (t.Id == e)
						return t;
				// END MOD
				return null
			};
			// END ROLL20 CODE
		} catch (ignored) {
			console.error(ignored)
		}
	};

	// prevent prototype methods from breaking some poorly-written property loops
	d20plus.mod.fixVideoMethods = () => {
		const arr = [];
		for (const k in arr) {
			const v = arr[k];
			if (typeof v === "function") {
				v.getReceiver = v.getReceiver || (() => null);
				v.getSender = v.getSender || (() => null);
			}
		}
	};

	/* eslint-enable */
}

SCRIPT_EXTENSIONS.push(d20plusMod);


function initTemplates () {
	d20plus.templates = {};
}

SCRIPT_EXTENSIONS.push(initTemplates);


function initTemplateTokenEditor () {
	// no mods; just switched in to grant full features to non-pro
	const templateTokenEditor = `<script id='tmpl_tokeneditor' type='text/html'>
    <div class='dialog largedialog tokeneditor' style='display: block;'>
        <ul class='nav nav-tabs tokeneditor_navigation'>
            <li class='active'>
                <a data-tab='basic' href='javascript:void(0);'>
                    <h2>Details</h2>
                </a>
            </li>
            <li>
                <a data-tab='notes' href='javascript:void(0);'>
                    <h2>GM Notes</h2>
                </a>
            </li>
            <li class='nav-tabs--beta'>
                <span class='label label-info'>
                    Updated
                </span>
                <a data-tab='prototype' href='javascript:void(0);'>
                    <h2>Dynamic Lighting</h2>
                </a>
            </li>
            <li>
                <a data-tab='advanced' href='javascript:void(0);'>
                    <h2>Legacy Lighting</h2>
                </a>
            </li>
        </ul>
        <div class='tab-content'>
            <div class='basic tab-pane tokeneditor__details'>
                <div class='w-100 d-inline-flex flex-wrap'>
                    <!-- General -->
                    <div class='tokeneditor__col general'>
                        <div class='tokeneditor__row--general d-grid'>
                            <div class='tokeneditor__header'>
                                <h3 class='page_title text-capitalize'>general</h3>
                            </div>
                            <div class='tokeneditor__dropdown d-grid'>
                                <div class='dropdown keep-open'>
                                    <button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
                                        <span class='sr-only'>nameplate player permissions menu</span>
                                        <svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
                                            <path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
                                        </svg>
                                    </button>
                                    <ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right'>
                                        <h4>Player Permissions</h4>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='allow players to see name plate'>
                                                    <input class='showplayers_name' type='checkbox'>
                                                    See
                                                </label>
                                            </div>
                                        </li>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='allow players to edit name plate'>
                                                    <input class='playersedit_name' type='checkbox'>
                                                    Edit
                                                </label>
                                            </div>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <!-- Represents Character -->
                        <div class='tokeneditor__row'>
                            <div class='tokeneditor__subheader help-icon'>
                                <h4>Represents Character</h4>
                                <a class='showtip pictos' title='You can choose to have the token represent a Character from the Journal. If you do, the token&#39;s name, controlling players, and bar values will be based on the Character. Most times you&#39;ll just leave this set to None/Generic.'>?</a>
                            </div>
                            <div class='tokeneditor__container'>
                                <label title='select which token this character represents'>
                                    <span class='sr-only'>select which token this character represents</span>
                                    <select class='represents'>
                                        <option value=''>None/Generic Token</option>
                                        <$ _.each(window.Campaign.activeCharacters(), function(char) { $>
                                        <option value="<$!char.id$>"><$!char.get("name")$></option>
                                        <$ }); $>
                                    </select>
                                </label>
                            </div>
                        </div>
                        <!-- Name -->
                        <div class='tokeneditor__row'>
                            <div class='tokeneditor__subheader'>
                                <h4>Name</h4>
                            </div>
                            <div class='tokeneditor__container tokeneditor__container-name tokeneditor__border d-inline-grid'>
                                <div class='d-flex'>
                                    <label class='sr-only' for='token-general-character-name'>character name</label>
                                    <input class='name' id='token-general-character-name' type='text'>
                                </div>
                                <div class='tokeneditor__container-nameplate disable_box'>
                                    <div class='d-flex justify-content-center align-items-center'>
                                        <label class='sr-only' for='token-general-nameplate'>show nameplate on token</label>
                                        <input class='showname' id='token-general-nameplate' type='checkbox' value='1'>
                                    </div>
                                    <h4 class='text-capitalize'>nameplate</h4>
                                </div>
                            </div>
                        </div>
                        <!-- Controlled By -->
                        <div class='tokeneditor__row'>
                            <div class='tokeneditor__subheader'>
                                <h4>Controlled By</h4>
                            </div>
                            <div class='tokeneditor__container'>
                                <$ if(this.character) { $>
                                <p>(Determined by Character settings)</p>
                                <$ } else { $>
                                <select class='controlledby selectize' multiple='true'>
                                    <option value='all'>All Players</option>
                                    <$ window.Campaign.players.each(function(player) { $>
                                    <option value="<$!player.id$>"><$!player.get("displayname")$></option>
                                    <$ }); $>
                                </select>
                                <$ } $>
                            </div>
                        </div>
                        <!-- Tint Color -->
                        <div class='tokeneditor__row'>
                            <div class='tokeneditor__subheader'>
                                <h4>Tint Color</h4>
                            </div>
                            <div class='tokeneditor__container'>
                                <label class='sr-only' for='token-general-tint-color'>choose a tint color of the token</label>
                                <input class='tint_color colorpicker' id='token-general-tint-color' type='text'>
                            </div>
                        </div>
                    </div>
                    <!-- Token Settings -->
                    <div class='tokeneditor__col token-settings'>
                        <div class='tokeneditor__header'>
                            <h3 class='page_title text-capitalize'>token bars</h3>
                        </div>
                        <div class='tokeneditor__row tokeneditor__row--bar d-grid'>
                            <div class='col tokeneditor__bar-inputs d-grid'>
                                <div class='tokeneditor__subheader align-items-center d-grid'>
                                    <span class='bar_color_indicator' style='background-color: <$!window.Campaign.get('bar1_color')$>'></span>
                                    <h4>Bar 1</h4>
                                </div>
                                <div class='tokeneditor__container align-items-center d-grid'>
                                    <div class='tokeneditor__border'>
                                        <label title='enter bar 1 value'>
                                            <input class='bar1_value' placeholder='Value' type='text'>
                                        </label>
                                    </div>
                                    <span>/</span>
                                    <div class='tokeneditor__border'>
                                        <label title='enter bar 1 maximum value'>
                                            <input class='bar1_max' placeholder='Max' type='text'>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class='col tokeneditor__bar-select align-items-center'>
                                <div class='tokeneditor__subheader help-icon'>
                                    <h4 class='text-capitalize'>attribute</h4>
                                    <a class='pictos showtip' title='You can choose to have the token represent a Character from the Journal. If you do, the token&#39;s name, controlling players, and bar values will be based on the Character. Most times you&#39;ll just leave this set to None/Generic.'>?</a>
                                </div>
                                <div class='tokeneditor__container'>
                                    <label title='select a character sheet attribute to link to bar 1'>
                                        <span class='sr-only'>select a character sheet attribute to link to bar 1</span>
                                        <select class='bar1_link'>
                                            <option value=''>None</option>
                                            <$ _.each(this.tokensettingsview.availAttribs(), function(attrib) { $>
                                            <option value="<$!attrib.id$>"><$!attrib.name$>
                                                <$ }); $>
                                        </select>
                                    </label>
                                </div>
                            </div>
                            <div class='col tokeneditor__dropdown d-grid'>
                                <div class='dropdown keep-open'>
                                    <button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
                                        <span class='sr-only'>bar 1 player permissions menu</span>
                                        <svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
                                            <path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
                                        </svg>
                                    </button>
                                    <ul aria-labelledby='dLabel' class='bar1 dropdown-menu dropdown-menu--right permission_section' id='myDropdown'>
                                        <h4>Player Permissions</h4>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='show players bar 1'>
                                                    <input class='showplayers_bar1' type='checkbox' value=''>
                                                    See
                                                </label>
                                            </div>
                                        </li>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='allow players to edit bar 1'>
                                                    <input class='playersedit_bar1' type='checkbox' value=''>
                                                    Edit
                                                </label>
                                            </div>
                                        </li>
                                        <li class='dropdown-item'>
                                            <label class='bar_val_permission'>
                                                Text Overlay:
                                                <select class='bar1options'>
                                                    <option value='hidden'>
                                                        Hidden
                                                    </option>
                                                    <option selected value='editors'>
                                                        Visible to Editors
                                                    </option>
                                                    <option value='everyone'>
                                                        Visible to Everyone
                                                    </option>
                                                </select>
                                            </label>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class='tokeneditor__row tokeneditor__row--bar d-grid'>
                            <div class='col tokeneditor__bar-inputs d-grid'>
                                <div class='tokeneditor__subheader align-items-center d-grid'>
                                    <span class='bar_color_indicator' style='background-color: <$!window.Campaign.get('bar2_color')$>'></span>
                                    <h4>Bar 2</h4>
                                </div>
                                <div class='tokeneditor__container align-items-center d-grid'>
                                    <div class='tokeneditor__border'>
                                        <label title='enter bar 2 value'>
                                            <input class='bar2_value' placeholder='Value' type='text'>
                                        </label>
                                    </div>
                                    <span>/</span>
                                    <div class='tokeneditor__border'>
                                        <label title='enter bar 2 maximum value'>
                                            <input class='bar2_max' placeholder='Max' type='text'>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class='col tokeneditor__bar-select align-items-center'>
                                <div class='tokeneditor__subheader help-icon'>
                                    <h4 class='text-capitalize'>attribute</h4>
                                </div>
                                <div class='tokeneditor__container'>
                                    <label title='select a character sheet attribute to link to bar 2'>
                                        <span class='sr-only'>select a character sheet attribute to link to bar 2</span>
                                        <select class='bar2_link'>
                                            <option value=''>None</option>
                                            <$ _.each(this.tokensettingsview.availAttribs(), function(attrib) { $>
                                            <option value="<$!attrib.id$>"><$!attrib.name$>
                                                <$ }); $>
                                        </select>
                                    </label>
                                </div>
                            </div>
                            <div class='col tokeneditor__dropdown d-grid'>
                                <div class='dropdown keep-open'>
                                    <button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
                                        <span class='sr-only'>bar 2 player permissions menu</span>
                                        <svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
                                            <path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
                                        </svg>
                                    </button>
                                    <ul aria-labelledby='dLabel' class='bar2 dropdown-menu dropdown-menu--right permission_section' id='myDropdown'>
                                        <h4>Player Permissions</h4>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='show players bar 2'>
                                                    <input class='showplayers_bar2' type='checkbox' value=''>
                                                    See
                                                </label>
                                            </div>
                                        </li>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='allow players to edit bar 2'>
                                                    <input class='playersedit_bar2' type='checkbox' value=''>
                                                    Edit
                                                </label>
                                            </div>
                                        </li>
                                        <li class='dropdown-item'>
                                            <label class='bar_val_permission'>
                                                Text Overlay:
                                                <select class='bar2options'>
                                                    <option value='hidden'>
                                                        Hidden
                                                    </option>
                                                    <option selected value='editors'>
                                                        Visible to Editors
                                                    </option>
                                                    <option value='everyone'>
                                                        Visible to Everyone
                                                    </option>
                                                </select>
                                            </label>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class='tokeneditor__row tokeneditor__row--bar d-grid'>
                            <div class='col tokeneditor__bar-inputs d-grid'>
                                <div class='tokeneditor__subheader align-items-center d-grid'>
                                    <span class='bar_color_indicator' style='background-color: <$!window.Campaign.get('bar3_color')$>'></span>
                                    <h4>Bar 3</h4>
                                </div>
                                <div class='tokeneditor__container align-items-center d-grid'>
                                    <div class='tokeneditor__border'>
                                        <label title='enter bar 3 value'>
                                            <input class='bar3_value' placeholder='Value' type='text'>
                                        </label>
                                    </div>
                                    <span>/</span>
                                    <div class='tokeneditor__border'>
                                        <label title='enter bar 3 maximum value'>
                                            <input class='bar3_max' placeholder='Max' type='text'>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class='col tokeneditor__bar-select align-items-center'>
                                <div class='tokeneditor__subheader help-icon'>
                                    <h4 class='text-capitalize'>attribute</h4>
                                </div>
                                <div class='tokeneditor__container'>
                                    <label title='select a character sheet attribute to link to bar 3'>
                                        <span class='sr-only'>select a character sheet attribute to link to bar 3</span>
                                        <select class='bar3_link'>
                                            <option value=''>None</option>
                                            <$ _.each(this.tokensettingsview.availAttribs(), function(attrib) { $>
                                            <option value="<$!attrib.id$>"><$!attrib.name$>
                                                <$ }); $>
                                        </select>
                                    </label>
                                </div>
                            </div>
                            <div class='col tokeneditor__dropdown d-grid'>
                                <div class='dropdown keep-open'>
                                    <button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
                                        <span class='sr-only'>bar 3 player permissions menu</span>
                                        <svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
                                            <path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
                                        </svg>
                                    </button>
                                    <ul aria-labelledby='dLabel' class='bar3 dropdown-menu dropdown-menu--right permission_section' id='myDropdown'>
                                        <h4>Player Permissions</h4>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='show players bar 3'>
                                                    <input class='showplayers_bar3' type='checkbox' value=''>
                                                    See
                                                </label>
                                            </div>
                                        </li>
                                        <li class='dropdown-item'>
                                            <div class='checkbox'>
                                                <label title='allow players to edit bar 3'>
                                                    <input class='playersedit_bar3' type='checkbox' value=''>
                                                    Edit
                                                </label>
                                            </div>
                                        </li>
                                        <li class='dropdown-item'>
                                            <label class='bar_val_permission'>
                                                Text Overlay:
                                                <select class='bar3options'>
                                                    <option value='hidden'>
                                                        Hidden
                                                    </option>
                                                    <option selected value='editors'>
                                                        Visible to Editors
                                                    </option>
                                                    <option value='everyone'>
                                                        Visible to Everyone
                                                    </option>
                                                </select>
                                            </label>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <hr>
                <!-- Token Tooltip -->
                <div class='tokendescription w-100'>
                    <div class='w-100 d-inline-flex flex-wrap tokeneditor__container tokeneditor__tooltip-title'>
                        <div class='flex-col'>
                            <div class='tokeneditor__header w-100'>
                                <h3 class='page_title text-capitalize'>Tooltip</h3>
                            </div>
                        </div>
                        <div class='tokeneditor__container-tooltip tooltip_disable_box'>
                            <div class='d-flex justify-content-center align-items-center'>
                                <label class='sr-only' for='token-general-description-toggle'>show tooltip on token</label>
                                <input class='show_tooltip' id='token-general-tooltip-toggle' type='checkbox' value='1'>
                            </div>
                            <h4 class='text-capitalize'>Show</h4>
                        </div>
                    </div>
                </div>
                <div class='tokeneditor__row'>
                    <div class='tokeneditor__container'>
                        <div class='d-flex'>
                            <textarea class='token-tooltip' id='token-general-description' maxlength='150' type='text'></textarea>
                        </div>
                    </div>
                </div>
                <br>
                <small>
                <span class='tooltip-count'>0</span>
                /150
                </small>
                <hr>
                <!-- Token Bar Options -->
                <div class='tokenbaroptions w-100'>
                    <div class='tokeneditor__header w-100'>
                        <h3 class='page_title text-capitalize'>token bar options</h3>
                    </div>
                    <div class='w-100 d-inline-flex flex-wrap'>
                        <div class='tokeneditor__col'>
                            <div class='tokeneditor__subheader help-icon'>
                                <h4 class='text-capitalize'>location</h4>
                                <a class='showtip pictos' title='&lt;b&gt;Above:&lt;/b&gt; &lt;br&gt; All bars are above the token. (Default for new games) &lt;br&gt; &lt;b&gt;Top Overlapping:&lt;/b&gt; &lt;br&gt; The bottom-most bar overlaps the top of the token. Other bars float above it. &lt;br&gt; &lt;b&gt;Bottom Overlapping:&lt;/b&gt; &lt;br&gt; Bars fill the token from the bottom up. &lt;br&gt; &lt;b&gt;Below:&lt;/b&gt; &lt;br&gt; All bars are below the token.'>?</a>
                            </div>
                            <div class='tokeneditor__container player-permissions'>
                                <div class='permission_section barLocation'>
                                    <label class='movable_token_bar' title='select the token bar location'>
                                        <span class='sr-only'>select the token bar location</span>
                                        <select class='token_bar_location'>
                                            <option selected value='above'>
                                                Above
                                            </option>
                                            <option value='overlap_top'>
                                                Top Overlapping
                                            </option>
                                            <option value='overlap_bottom'>
                                                Bottom Overlapping
                                            </option>
                                            <option value='below'>
                                                Below
                                            </option>
                                        </select>
                                    </label>
                                </div>
                            </div>
                        </div>
                        <div class='tokeneditor__col'>
                            <div class='tokeneditor__subheader help-icon'>
                                <h4 class='text-capitalize'>style</h4>
                                <a class='showtip pictos' title='&lt;b&gt;Standard:&lt;/b&gt;&lt;br&gt; Full sized token bar, displays text overlays. &lt;br&gt; &lt;b&gt;Compact:&lt;/b&gt; &lt;br&gt;Narrow token bars. No text overlay.'>?</a>
                            </div>
                            <div class='tokeneditor__container player-permissions'>
                                <div class='permission_section barLocation tokenbaroptions__style d-grid'>
                                    <label class='compact_bar align-items-center' title='Standard token bar style'>
                                        <input checked name='barStyle' type='radio' value='standard'>
                                        <span class='sr-only'>choose token bar style</span>
                                        Standard
                                    </label>
                                    <label class='compact_bar align-items-center' title='Compact token bar style'>
                                        <span class='sr-only'>choose token bar style</span>
                                        <input name='barStyle' type='radio' value='compact'>
                                        Compact
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <hr>
                <!-- Token Aura -->
                <div class='tokenaura w-100'>
                    <div class='tokeneditor__header w-100'>
                        <h3 class='page_title text-capitalize'>token aura</h3>
                    </div>
                    <div class='w-100 d-inline-flex flex-wrap'>
                        <div class='tokeneditor__col'>
                            <div class='tokenaura__header d-grid'>
                                <div class='tokeneditor__subheader'>
                                    <h4 class='text-capitalize'>Aura 1</h4>
                                </div>
                                <div class='tokeneditor__dropdown d-grid'>
                                    <div class='dropdown keep-open dropup'>
                                        <button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
                                            <span class='sr-only'>aura 1 player permissions menu</span>
                                            <svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
                                                <path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
                                            </svg>
                                        </button>
                                        <ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right' id='myDropdown'>
                                            <h4>Player Permissions</h4>
                                            <li class='dropdown-item'>
                                                <div class='checkbox'>
                                                    <label title='show players aura 1'>
                                                        <input class='showplayers_aura1' type='checkbox' value=''>
                                                        See
                                                    </label>
                                                </div>
                                            </li>
                                            <li class='dropdown-item'>
                                                <div class='checkbox'>
                                                    <label title='allow players to edit aura 1'>
                                                        <input class='playersedit_aura1' type='checkbox' value=''>
                                                        Edit
                                                    </label>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class='tokenaura__container d-grid'>
                                <!-- Token Aura Diameter -->
                                <div class='tokenaura__diameter'>
                                    <div class='tokeneditor__subheader'>
                                        <h4 class='text-capitalize'>diameter</h4>
                                    </div>
                                    <div class='tokeneditor__container tokeneditor__border'>
                                        <label title='input aura 1 diameter'>
                                            <input class='aura1_radius' type='text'>
                                        </label>
                                        <div class='disable_box d-block'>
                                            <$!window.Campaign.activePage().get("scale_units")$>
                                        </div>
                                    </div>
                                </div>
                                <!-- Token Aura Shape -->
                                <div class='tokenaura__shape'>
                                    <div class='tokeneditor__subheader'>
                                        <h4 class='text-capitalize'>shape</h4>
                                    </div>
                                    <div class='tokeneditor__container'>
                                        <label title='select aura 1 shape'>
                                            <select class='aura1_options text-capitalize'>
                                                <option selected value='circle'>circle</option>
                                                <option value='square'>square</option>
                                            </select>
                                        </label>
                                    </div>
                                </div>
                                <!-- Token Aura Tint Color -->
                                <div class='tokeneditor__tint'>
                                    <div class='tokeneditor__subheader'>
                                        <h4 class='text-capitalize'>tint color</h4>
                                    </div>
                                    <div class='tokeneditor__container'>
                                        <input class='aura1_color colorpicker' type='text'>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='tokeneditor__col'>
                            <div class='tokenaura__header d-grid'>
                                <div class='tokeneditor__subheader'>
                                    <h4 class='text-capitalize'>Aura 2</h4>
                                </div>
                                <div class='tokeneditor__dropdown d-grid'>
                                    <div class='dropdown keep-open dropup'>
                                        <button aria-expanded='false' aria-haspopup='true' class='btn btn-default btn--circle' data-toggle='dropdown' type='button'>
                                            <span class='sr-only'>aura 2 player permissions menu</span>
                                            <svg aria-hidden='true' class='svg-inline--fa' data-icon='ellipsis-v' data-prefix='fas' height='12' viewBox='0 0 192 512' width='12' xmlns='http://www.w3.org/2000/svg'>
                                                <path d='M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z' fill='000000'></path>
                                            </svg>
                                        </button>
                                        <ul aria-labelledby='dLabel' class='dropdown-menu dropdown-menu--right' id='myDropdown'>
                                            <h4>Player Permissions</h4>
                                            <li class='dropdown-item'>
                                                <div class='checkbox'>
                                                    <label title='show players aura 2'>
                                                        <input class='showplayers_aura2' type='checkbox' value=''>
                                                        See
                                                    </label>
                                                </div>
                                            </li>
                                            <li class='dropdown-item'>
                                                <div class='checkbox'>
                                                    <label title='allow players to edit aura 2'>
                                                        <input class='playersedit_aura2' type='checkbox' value=''>
                                                        Edit
                                                    </label>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class='tokenaura__container d-grid'>
                                <!-- Token Aura Diameter -->
                                <div class='tokenaura__diameter'>
                                    <div class='tokeneditor__subheader'>
                                        <h4 class='text-capitalize'>diameter</h4>
                                    </div>
                                    <div class='tokeneditor__container tokeneditor__border'>
                                        <label title='input aura 2 diameter'>
                                            <input class='aura2_radius' type='text'>
                                        </label>
                                        <div class='disable_box d-block'>
                                            <$!window.Campaign.activePage().get("scale_units")$>
                                        </div>
                                    </div>
                                </div>
                                <!-- Token Aura Shape -->
                                <div class='tokenaura__shape'>
                                    <div class='tokeneditor__subheader'>
                                        <h4 class='text-capitalize'>shape</h4>
                                    </div>
                                    <div class='tokeneditor__container'>
                                        <label title='select aura 2 shape'>
                                            <select class='aura2_options text-capitalize'>
                                                <option selected value='circle'>circle</option>
                                                <option value='square'>square</option>
                                            </select>
                                        </label>
                                    </div>
                                </div>
                                <!-- Token Aura Tint Color -->
                                <div class='tokeneditor__tint'>
                                    <div class='tokeneditor__subheader'>
                                        <h4 class='text-capitalize'>tint color</h4>
                                    </div>
                                    <div class='tokeneditor__container'>
                                        <input class='aura2_color colorpicker' type='text'>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- GM Notes -->
            <div class='notes tab-pane'>
                <div class='tokeneditor__header'>
                    <h3 class='d-inline'>GM Notes</h3>
                    <span>(Only visible to GMs)</span>
                </div>
                <div>
                    <textarea class='gmnotes summernote'></textarea>
                </div>
            </div>
            <!-- Legacy Lighting -->
            <div class='advanced tab-pane'>
                <div class='row-fluid'>
                    <div class='emits-light'>
                        <h4>Emits Light</h4>
                        <div class='inlineinputs' style='margin-top: 5px; margin-bottom: 5px;'>
                            <input class='light_radius' type='text'>
                            <$!window.Campaign.activePage().get("scale_units")$>.
                            <input class='light_dimradius' type='text'>
                            <$!window.Campaign.activePage().get("scale_units")$>.
                            <input class='light_angle' placeholder='360' type='text'>
                            <span style='font-size: 2.0em;'>&deg;</span>
                        </div>
                        <span style='color: #888; padding-left: 5px;'>Light Radius / (optional) Start of Dim / Angle</span>
                        <div class='inlineinputs' style='margin-top: 5px;'>
                            <label style='margin-left: 7px;'>
                                <input class='light_otherplayers' type='checkbox'>
                                All Players See Light
                            </label>
                        </div>
                        <div class='inlineinputs' style='margin-top: 2px;'>
                            <label style='margin-left: 7px;'>
                                <input class='light_hassight' type='checkbox'>
                                Has Sight
                            </label>
                            <span style="margin-left: 9px; margin-right: 28px;">/</span>
                            Angle:
                            <input class='light_losangle' placeholder='360' type='text'>
                            <span style='font-size: 2.0em;'>&deg;</span>
                        </div>
                        <div class='inlineinputs' style='margin-left: 90px; margin-top: 5px;'>
                            <span style="margin-left: 8px; margin-right: 12px;">/</span>
                            Multiplier:
                            <input class='light_multiplier' placeholder='1.0' style='margin-right: 10px;' type='text'>x</input>
                        </div>
                        <h4>Advanced Fog of War</h4>
                        <div class='inlineinputs' style='margin-top: 5px; margin-bottom: 5px;'>
                            <input class='advfow_viewdistance' type='text'>
                            <$!window.Campaign.activePage().get("scale_units")$>.
                        </div>
                        <span style='color: #888; padding-left: 5px;'>Reveal Distance</span>
                    </div>
                </div>
                <div class='alert alert-info' role='alert' style='margin-top: 5%'>
                    <p><strong>Legacy</strong> - in the coming months, Advanced Fog of War and Dynamic Lighting will be replaced with Updated Dynamic Lighting.</p>
                </div>
            </div>
            <!-- Updated Dynamic Lighting -->
            <div class='prototype tab-pane'>
                <div class='alert alert-info' role='alert'>
                    <p>This feature is in Active Development: Turning on Updated Dynamic Lighting will turn off Legacy Dynamic Lighting for this page. If you want to go back, you’ll need to turn on Legacy back on for the Page. Revealed areas in one system will not be revealed in the other.  Consider testing the feature in a copy or new game. <a href="https://app.roll20.net/forum/permalink/8422745" target='_blank'>Read More…</a></p>
                </div>
                <div class='token_vision'>
                    <p class='token_vision_title'>Token Vision</p>
                    <div class='dyn_fog_vision' style='padding-top: 10px;'>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='vision_title'>Vision</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <label class='switch'>
                                    <input class='dyn_fog_emits_vision feature_toggle' type='checkbox'>
                                    <span class='slider round'></span>
                                    </input>
                                </label>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='description'>Gives the ability to see, if there is light or if Night Vision is enabled. Tokens with vision can see to the edge of the available light.</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='hidden'>
                                    <input class='dyn_fog_vision_range' type='number'>
                                    <input class='dyn_fog_dim_vision_range' type='number'>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class='dyn_fog_dark_vision' style='padding-top: 10px;'>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='vision_title'>Night Vision</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <label class='switch'>
                                    <input class='dyn_fog_emits_dark_vision feature_toggle' data-target='.dark_vision_input' data-toggle='toggle' type='checkbox'>
                                    <span class='slider round'></span>
                                    </input>
                                </label>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='span12'>
                                <p class='description'>Give this token the ability to see without any light.</p>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element dark_vision_input'>
                            <div class='span8'>
                                <label class='distance'>Night Vision Distance</label>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='dyn_fog_dark_vision_range' min='0' type='number'>
                                        <span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='alert alert-danger negative_number_alert_night_vision hidden' role='alert'>
                                <p>Please enter a positive number.</p>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element dark_vision_input'>
                            <div class='span8'>
                                <label class='vision-color'>Tint Color</label>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <input class='dyn_fog_dark_vision_color colorpicker' type='text'>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element dark_vision_input' style='padding-top: 10px'>
                            <div class='span8'>
                                <label>Night Vision Effect</label>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='form-group' style='float:right;'>
                                    <div class='input-group'>
                                        <label class='dyn_fog_dropdown'>
                                            <select class='dyn_fog_dark_vision_effect form-control'>
                                                <option value=''>None</option>
                                                <option value='Nocturnal'>Nocturnal</option>
                                                <option value='Dimming'>Dimming</option>
                                            </select>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element dark_vision_input dyn_fog_dark_fx_dimming_row hidden' style='padding-top: 10px'>
                            <div class='span8'>
                                <label class='dyn_fog_dark_vision_color'>Dimming Start</label>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='dyn_fog_dark_vision_effect_dimming' max='100' min='0' step='0.01' type='number' value='5'>
                                        <span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='alert alert-danger negative_number_alert_night_vision_dimming hidden' role='alert'>
                                <p>Please enter a positive number.</p>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class='limit_field_of_vision hidden' style='padding-top: 10px;'>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='vision_title'>Limit Field of Vision</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <label class='switch'>
                                    <input class='field_of_vision feature_toggle' data-target='.field_of_vision_inputs' data-toggle='toggle' type='checkbox'>
                                    <span class='slider round'></span>
                                    </input>
                                </label>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='span12'>
                                <p class='description'>Limit the field revealed for the token.</p>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element field_of_vision_inputs'>
                            <div class='span3'>
                                <label class='distance'>Total</label>
                            </div>
                            <div class='span3 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='field_of_vision_total' max='360' min='0' type='number'>
                                        <span class='input-group-addon'>&deg;</span>
                                    </div>
                                </div>
                            </div>
                            <div class='span3'>
                                <label class='distance'>Center</label>
                            </div>
                            <div class='span3 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='field_of_vision_center' max='360' min='0' type='number'>
                                        <span class='input-group-addon'>&deg;</span>
                                    </div>
                                </div>
                            </div>
                            <div class='row-fluid clearfix'></div>
                            <div class='row-fluid clearfix'>
                                <div class='alert alert-danger wrong_number_alert_vision hidden' role='alert'>
                                    <p>Please enter a number between 0-360.</p>
                                </div>
                            </div>
                            <div class='row-fluid clearfix'>
                                <div class='span6'>
                                    <p class='description'>Total size of the Field of Vision.</p>
                                </div>
                                <div class='span6'>
                                    <p class='description'>50% of Vision is before the Center, 50% is after.</p>
                                </div>
                            </div>
                        </div>
                        <hr>
                    </div>
                </div>
                <div class='token_light'>
                    <p class='token_light_title'>Token Emits Light</p>
                    <div class='dyn_fog_light' style='padding-top: 10px;'>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='light_title'>Bright Light</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <label class='switch'>
                                    <input class='dyn_fog_emits_light feature_toggle' data-target='.bright_light_input' data-toggle='toggle' type='checkbox'>
                                    <span class='slider round'></span>
                                    </input>
                                </label>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='description'>Makes the token emit Bright Light. Enable this to set its Distance.</p>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element bright_light_input'>
                            <div class='span8'>
                                <label class='distance'>Bright Light Distance</label>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='dyn_fog_light_range' min='0' type='number'>
                                        <span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='alert alert-danger negative_number_alert_bright_light hidden' role='alert'>
                                <p>Please enter a positive number.</p>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class='dyn_fog_dim_light' style='padding-top: 10px;'>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='light_title'>Low Light</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <label class='switch'>
                                    <input class='dyn_fog_emits_dim_light feature_toggle' data-target='.low_light_input' data-toggle='toggle' type='checkbox'>
                                    <span class='slider round'></span>
                                    </input>
                                </label>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='description'>Makes the token emit Low Light, in addition to any Bright Light set above. Enable this to set its Distance.</p>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element low_light_input'>
                            <div class='span8'>
                                <label class='distance'>Low Light Distance</label>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='dyn_fog_dim_light_range' min='0' type='number'>
                                        <span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element low_light_input'>
                            <div class='span8'>
                                <label class='distance'>Brightness</label>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group flex-group'>
                                        <img class='dyn_fog_img_left flex-item' src='/images/editor/lightbulb_low.svg'>
                                        <input class='dyn_fog_dim_light_opacity flex-item' max='1' min='0.2' step='0.05' type='range'>
                                        <img class='dyn_fog_img_right flex-item' src='/images/editor/lightbulb_high.svg'>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='alert alert-danger negative_number_alert_dim_light hidden' role='alert'>
                                <p>Please enter a positive number.</p>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class='directional_bright_light hidden' style='padding-top: 10px;'>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='light_title'>Directional Light</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <label class='switch'>
                                    <input class='directional_bright_light_toggle feature_toggle' data-target='.directional_bright_light_inputs' data-toggle='toggle' type='checkbox'>
                                    <span class='slider round'></span>
                                    </input>
                                </label>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='span12'>
                                <p class='description'>Set the direction of the Light emitting from this token.</p>
                            </div>
                        </div>
                        <div class='row-fluid clearfix toggle-element directional_bright_light_inputs'>
                            <div class='span3'>
                                <label class='distance'>Total</label>
                            </div>
                            <div class='span3 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='directional_bright_light_total' max='360' min='0' type='number'>
                                        <span class='input-group-addon'>&deg;</span>
                                    </div>
                                </div>
                            </div>
                            <div class='span3'>
                                <label class='distance'>Center</label>
                            </div>
                            <div class='span3 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='directional_bright_light_center' max='360' min='0' type='number'>
                                        <span class='input-group-addon'>&deg;</span>
                                    </div>
                                </div>
                            </div>
                            <div class='row-fluid clearfix'></div>
                            <div class='row-fluid clearfix'>
                                <div class='alert alert-danger wrong_number_alert_bright hidden' role='alert'>
                                    <p>Please enter a number between 0-360.</p>
                                </div>
                            </div>
                            <div class='row-fluid clearfix'>
                                <div class='span6'>
                                    <p class='description'>Total size of the Field of Light.</p>
                                </div>
                                <div class='span6'>
                                    <p class='description'>50% of Light is before the Center, 50% is after.</p>
                                </div>
                            </div>
                        </div>
                        <hr>
                        <div class="row-fluid clearfix">
                            <div class="span8">
                                <label class="light_title">Light Color</label>
                            </div>
                            <div class="span4 dyn_fog_switch">
                                <input class="dyn_fog_light_color colorpicker" type="text" value="transparent" style="display: none;">
                            </div>
                        </div>
                        <hr>
                    </div>
                    <div class='total_light'>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='light_title'>Total Light</p>
                            </div>
                            <div class='span4 dyn_fog_switch'>
                                <div class='form-group'>
                                    <div class='input-group'>
                                        <input class='total_light_input' disabled type='number' value='0'>
                                        <span class='input-group-addon'><$!window.Campaign.activePage().get("scale_units")$></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class='row-fluid clearfix'>
                            <div class='span8'>
                                <p class='description'>Amount of light emitting from this token.</p>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class='token_light'>
                        <div aria-expanded='false' class='span8' data-target='.collapse_dyn_fog_advance' data-toggle='collapse' style='display:flex'>
                            <p class='token_light_title' style='flex:1'>Advanced Settings</p>
                            <i aria-expanded='false' class='fa fa-chevron-up collapse_dyn_fog_advance' style='font-size:20px;cursor: pointer;'></i>
                            <i aria-expanded='false' class='fa fa-chevron-down collapse_dyn_fog_advance' style='font-size:20px;cursor: pointer;'></i>
                        </div>
                        <div class='dyn_fog_light' style='padding-top: 10px;'></div>
                        <div class='total_light collapse collapse_dyn_fog_advance'>
                            <div class='row-fluid clearfix'>
                                <div class='span8'>
                                    <p class='light_title'>Light Multiplier</p>
                                </div>
                                <div class='span4 dyn_fog_switch'>
                                    <div class='form-group'>
                                        <div class='input-group'>
                                            <input class='light_multi_input' min='1' type='number' value='100'>
                                            <span class='input-group-addon'>%</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class='row-fluid clearfix'>
                                <div class='span8'>
                                    <p class='description'>This changes the effective radius of light for this player. A setting of 200% will let this player see light from twice it’s set radius.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</script>`;

	d20plus.templates.templateTokenEditor = templateTokenEditor;
}

SCRIPT_EXTENSIONS.push(initTemplateTokenEditor);


function initTemplatePageSettings () {
	// no mods; just switched in to grant full features to non-pro
	const templatePageSettings = `<script id='tmpl_pagesettings' type='text/html'>
    <ul class='nav nav-tabs pagedetails_navigation'>
        <li class='active'>
            <a data-tab='pagedetails' href='javascript:void(0);'>
                <h2>Page Details</h2>
            </a>
        </li>
        <li class='nav-tabs--beta'>
<span class='label label-info'>
Updated
</span>
            <a data-tab='lighting' href='javascript:void(0);'>
                <h2>Dynamic Lighting</h2>
            </a>
        </li>
        <li class='nav-tabs'>
            <a data-tab='legacy-lighting' href='javascript:void(0);'>
                <h2>Legacy Lighting</h2>
            </a>
        </li>
    </ul>
    <div class='tab-content'>
        <div class='legacy-lighting tab-pane'>
			<!-- BEGIN MOD -->
			<strong style="display: block; margin-bottom: 10px;"><i>Requires a paid subscription or all players to use a betteR20 script</i></strong>
			<hr>
			<!-- END MOD -->
            <div class='lighting_feature showtip' data-feature_enabled='showdarkness' id='fog_settings' title='Enabling Fog of War will disable Updated Dynamic Lighting'>
                <label class='feature_name'>
                    <strong>Fog of War</strong>
                </label>
                <div class='feature_options'>
                    <input class='darknessenabled feature_enabled' type='checkbox' value='1'>
                    <label class='checkbox'>&nbsp; Enabled</label>
                </div>
            </div>
            <hr>
            <div class='lighting_feature' data-feature_enabled='adv_fow_enabled' id='afow_settings'>
                <label class='feature_name'>
                    <strong>Advanced Fog of War</strong>
                </label>
                <div class='feature_options'>
                    <input class='advancedfowenabled feature_enabled showtip' type='checkbox' value='1'>
                    <label class='checkbox'>&nbsp; Enabled</label>
                    <div class='subsettings'>
                        <div>
                            <input class='advancedfowshowgrid showtip' title='By default the Advanced Fog of War hides the map grid anywhere revealed but the player can no longer see because of Dynamic Lighting. This option makes the grid always visible.' type='checkbox' value='1'>
                            <label class='checkbox'>&nbsp; Show Grid</label>
                        </div>
                        <div>
                            <input class='dimlightreveals showtip' title='By default the Advanced Fog of War will not be permanently revealed by Dynamic Lighting that is not bright. This option allows dim lighting to also reveal the fog.' type='checkbox' value='1'>
                            <label class='checkbox'>&nbsp; Dim Light Reveals</label>
                        </div>
                        <div>
                            <input class='showtip' id='afow_gm_see_all' title='By default, Advanced Fog of War is only revealed by tokens with sight that are controlled by at least one player.&lt;br&gt;This option allows tokens with sight which are not controlled by anyone to reveal Advanced Fog of War for the GM only.' type='checkbox' value='0'>
                            <label class='checkbox'>&nbsp; All Tokens Reveal (GM)</label>
                        </div>
                        <div id='afow_grid_size' style='width: 180px; line-height: 30px;'>
                            <span id='cell_measurement'>Cell Width:</span>
                            <input type="number" class="advancedfowgridsize units" value="<$!this.model.get("adv_fow_grid_size")$>" />
                            <br>
                            <span>x 70 px =</span>
                            <input type="number" class="px_advancedfowgridsize pixels" value="<$!this.model.get("adv_fow_grid_size")*70$>" />
                            <span>px<sup>*</sup></span>
                        </div>
                    </div>
                </div>
            </div>
            <div class='lighting_feature' data-feature_enabled='showlighting' id='dynamic_lighting_settings'>
                <label class='feature_name'>
                    <strong>Dynamic Lighting</strong>
                </label>
                <div class='feature_options'>
                    <input class='lightingenabled feature_enabled showtip' type='checkbox' value='1'>
                    <label class='checkbox'>&nbsp; Enabled</label>
                    <div class='subsettings'>
                        <div>
                            <input class='lightenforcelos showtip' title='Player&#39;s line of sight set by what tokens they can control.' type='checkbox' value='1'>
                            <label class='checkbox'>&nbsp; Enforce Line of Sight</label>
                        </div>
                        <div>
                            <input class='lightingupdate' type='checkbox' value='1'>
                            <label class='checkbox'>&nbsp; Only Update on Drop</label>
                        </div>
                        <div>
                            <input class='lightglobalillum showtip' title='Instead of darkness show light in all places players can see.' type='checkbox' value='1'>
                            <label class='checkbox'>&nbsp; Global Illumination</label>
                        </div>
                    </div>
                </div>
            </div>
            <hr>
            <div class='alert alert-info' role='alert'>
                <p><strong>Legacy</strong> - in the coming months, Advanced Fog of War and Dynamic Lighting will be replaced with Updated Dynamic Lighting.</p>
            </div>
            <hr>
            <div id='gm_darkness_opacity'>
                <label class='feature_name'>
                    <strong>Darkness Opacity (GM)</strong>
                </label>
                <div class='fogopacity showtip' title='The GM can see through dark areas hidden from the players when using Fog of War, Advanced Fog of War, and/or Dynamic Lighting. This setting adjusts the opacity of those dark areas for the GM only.'></div>
            </div>
        </div>
        <div class='pagedetails tab-pane' style='display:block;'>
            <!-- * SIZE */ -->
            <div class='size_settings' id='size_settings'>
                <div class='pagedetails__header'>
                    <h3 class='page_title'>Size</h3>
                </div>
                <div class='pagedetails__subheader'>
                    <h4>Width</h4>
                </div>
                <div class='pagedetails__container grid_settings-input--list input-group'>
                    <div class='pagedetails-input size_settings-input'>
                        <div>
                            <label class='sr-only' for='page-size-width-input'>enter a custom page width in pixels</label>
                            <input id="page-size-width-input" type="number" class="width units page_setting_item" value="<$!this.model.get("width")$>" />
                        </div>
                        <div class='disable_box'>px</div>
                    </div>
                    <div class='col pagedetails-symbol'>
                        <span class='page_setting_item'>X</span>
                    </div>
                    <div class='pagedetails-input size_settings-input'>
                        <div>
                            <label class='sr-only' for='page-size-width-multiplier'>custom page width will be multiplied by 70</label>
                            <input id='page-size-width-multiplier' type="text" value="70" class="page_setting_item" disabled>
                        </div>
                        <div class='disable_box'>px</div>
                    </div>
                    <div class='col pagedetails-symbol'>
                        <span class='page_setting_item'>=</span>
                    </div>
                    <div class='pagedetails-input size_settings-input'>
                        <div>
                            <label class='sr-only' for='page-size-width-total'>total page width in pixels after being multiplied by 70</label>
                            <input id='page-size-width-total' type="number" class="px_width pixels page_setting_item" value="<$!this.model.get("width")*70$>" />
                        </div>
                        <div class='disable_box'>px</div>
                    </div>
                </div>
                <div class='pagedetails__subheader'>
                    <h4>Height</h4>
                </div>
                <div class='pagedetails__container grid_settings-input--list input-group'>
                    <div class='pagedetails-input size_settings-input'>
                        <div>
                            <label class='sr-only' for='page-size-height-input'>enter a custom page height in pixels</label>
                            <input id="page-size-height-input" type="number" class="height units page_setting_item" value="<$!this.model.get("height")$>" />
                        </div>
                        <div class='disable_box'>px</div>
                    </div>
                    <div class='col pagedetails-symbol'>
                        <span class='page_setting_item'>X</span>
                    </div>
                    <div class='pagedetails-input size_settings-input'>
                        <div>
                            <label class='sr-only' for='page-size-height-multiplier'>custom page height will be multiplied by 70</label>
                            <input id='page-size-height-multiplier' type="text" value="70" class="page_setting_item" disabled>
                        </div>
                        <div class='disable_box'>px</div>
                    </div>
                    <div class='col pagedetails-symbol'>
                        <span class='page_setting_item'>=</span>
                    </div>
                    <div class='pagedetails-input size_settings-input'>
                        <div>
                            <label class='sr-only' for='page-size-height-total'>total page height in pixels after being multiplied by 70</label>
                            <input id='page-size-height-total' type="number" class="px_height pixels page_setting_item" value="<$!this.model.get("height")*70$>" />
                        </div>
                        <div class='disable_box'>px</div>
                    </div>
                </div>
                <div class='fine-print text-muted'>
                    <p>The height and width are true to size when zoom is set to 100%.</p>
                </div>
            </div>
            <hr>
            <!-- * BACKGROUND */ -->
            <div class='background_settings'>
                <div class='pagedetails__header'>
                    <h3 class='page_title'>Background</h3>
                </div>
                <div class='pagedetails__subheader'>
                    <h4>Color</h4>
                </div>
                <input class='pagebackground' type='text'>
            </div>
            <hr>
            <!-- * SCALE */ -->
            <div class='scale_settings'>
                <div class='pagedetails__header'>
                    <h3 class='page_title'>Scale</h3>
                </div>
                <div class='pagedetails__subheader'>
                    <h4 class='text-capitalize'>grid cell distance</h4>
                </div>
                <div class='pagedetails__container'>
                    <div class='pagedetails-input scale_settings-input'>
                        <div>
                            <label class='sr-only' for='page-scale-grid-cell-distance'>enter a custom distance for each grid cell</label>
                            <input id='page-scale-grid-cell-distance' type="number" class="scale_number" value="<$!this.model.get("scale_number")$>" />
                        </div>
                        <div class='scale_settings-select'>
                            <label class='sr-only' for='page-scale-grid-cell-label-select'>choose a label for your grid cells</label>
                            <select class='scale_units' id='page-scale-grid-cell-label-select'>
                                <option value='ft'>ft.</option>
                                <option value='m'>m.</option>
                                <option value='km'>km.</option>
                                <option value='mi'>mi.</option>
                                <option value='in'>in.</option>
                                <option value='cm'>cm.</option>
                                <option value='un'>un.</option>
                                <option value='hex'>hex</option>
                                <option value='sq'>sq.</option>
                                <option value='custom'>Custom</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class='hidden' id='custom_scale_units'>
                    <div class='pagedetails__subheader'>
                        <h4>custom label</h4>
                    </div>
                    <div class='pagedetails__container'>
                        <div class='pagedetails-input custom_scale_units-input'>
                            <label class='sr-only' for='page-scale-grid-cell-custom-label'>enter a custom label for your grid cells</label>
                            <input id="page-scale-grid-cell-custom-label" type="text" value="<$!this.model.get("scale_units")$>" />
                        </div>
                    </div>
                </div>
            </div>
            <hr>
            <!-- * GRID */ -->
            <div class='grid_settings' data-feature_enabled='showgrid' id='grid_settings'>
                <div class='row'>
                    <div class='col-xs-7 pagedetails__header'>
                        <h3 class='page_title'>Grid</h3>
                    </div>
                    <div class='col-xs-3 grid_switch'>
                        <label class='switch'>
                            <label class='sr-only' for='page-grid-display-toggle'>toggle the page grid</label>
                            <input class='gridenabled feature_enabled' id='page-grid-display-toggle' type='checkbox' value='1'>
                            <span class='slider round'></span>
                            </input>
                        </label>
                    </div>
                </div>
                <div class='grid_subsettings' id='grid_subsettings'>
                    <div class='pagedetails__container'>
                        <div class='pagedetails__subheader'>
                            <h4>Type</h4>
                        </div>
                        <div class='grid_settings-select'>
                            <label class='sr-only' for='gridtype'>select the grid type</label>
                            <select id='gridtype'>
                                <option selected value='square'>Square</option>
                                <option value='hex'>Hex (V)</option>
                                <option value='hexr'>Hex (H)</option>
                            </select>
                        </div>
                    </div>
                    <div class='pagedetails__container grid_settings-row--hex flex-wrap align-items-center' id='hexlabels'>
                        <div class='col-xs-7 pagedetails__subheader'>
                            <h4>show hex labels</h4>
                        </div>
                        <div class='col-xs-3 grid_switch'>
                            <label class='switch'>
                                <label class='sr-only' for='page-grid-hex-label-toggle'>toggle display labels inside of hexes</label>
                                <input class='gridlabels' id='page-grid-hex-label-toggle' type='checkbox' value='1'>
                                <span class='slider round'></span>
                                </input>
                            </label>
                        </div>
                    </div>
                    <div class='pagedetails__subheader help-icon'>
                        <h4>Measurement</h4>
                        <a class='tipsy-w showtip pictos' href='https://roll20.zendesk.com/hc/en-us/articles/360039674913-Ruler' target='_blank' title='Controls how diagonal cells are measured.'>?</a>
                    </div>
                    <div class='pagedetails__container'>
                        <div class='grid_settings-select'>
                            <select id='diagonaltype'>
                                <option class='squareonly' selected value='foure'>D&D 5E/4E Compatible</option>
                                <option class='squareonly' value='threefive'>Pathfinder/3.5E Compatible</option>
                                <option class='squareonly' value='manhattan'>Manhattan</option>
                                <option class='hexonly' value='hex'>Hex Path</option>
                                <option value='pythagorean'>Euclidean</option>
                            </select>
                        </div>
                    </div>
                    <div class='pagedetails__subheader help-icon'>
                        <h4>Cell Width</h4>
                        <a class='tipsy-w showtip pictos' href='https://roll20.zendesk.com/hc/en-us/articles/360039675373-Page-Settings' target='_blank' title='The number of cells per 70 pixels in your grid. Ex .5 = 35 pixels per cell.'>?</a>
                    </div>
                    <div class='pagedetails__container grid_settings-input--list'>
                        <div class='pagedetails-input grid_settings-input'>
                            <label class='sr-only' for='page-grid-cell-width-input'>enter a custom cell width</label>
                            <input id="page-grid-cell-width-input" type="number" class="grid-cell-width snappingincrement units" value="<$!this.model.get("snapping_increment")$>" />
                        </div>
                        <div class='col pagedetails-symbol'>
                            <span class='page_setting_item'>X</span>
                        </div>
                        <div class='pagedetails-input grid_settings-input'>
                            <div>
                                <label class='sr-only' for='page-grid-cell-width-multiplier'>custom cell width will be multiplied by 70</label>
                                <input id='page-grid-cell-width-multiplier' type="text" value="70" class="page_setting_item" disabled>
                            </div>
                            <div class='disable_box'>px</div>
                        </div>
                        <div class='col pagedetails-symbol'>
                            <span class='page_setting_item'>=</span>
                        </div>
                        <div class='pagedetails-input grid_settings-input'>
                            <div>
                                <label class='sr-only' for='page-grid-cell-width-total'>total cell width in pixels after being multiplied by 70</label>
                                <input id="page-grid-cell-width-total" type="number" class="px_snappingincrement pixels" value="<$!this.model.get("snapping_increment")*70$>" />
                            </div>
                            <div class='disable_box'>px</div>
                        </div>
                    </div>
                    <div class='pagedetails__subheader'>
                        <h4>Color</h4>
                    </div>
                    <div class='pagedetails__container'>
                        <div>
                            <input class='gridcolor' type='text'>
                        </div>
                    </div>
                    <div class='pagedetails__subheader'>
                        <h4>Opacity</h4>
                    </div>
                    <div class='pagedetails__container'>
                        <div>
                            <div class='gridopacity'></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- * Movement */ -->
            <hr>
            <div class='restrict_movement lighting_feature' id='restict_movement'>
                <div class='pagedetails__header w-100'>
                    <h3 class='page_title text-capitalize'>movement</h3>
                </div>
                <div class='pagedetails__container d-flex'>
                    <div class='row'>
                        <div class='col-xs-7 pagedetails__subheader'>
                            <h4 class='text-capitalize'>dynamic lighting barriers restrict movement</h4>
                        </div>
                        <div class='col-xs-3 grid_switch'>
                            <label class='switch'>
                                <label class='sr-only' for='page-dynamic-lighting-line-restrict-movement-toggle'>dynamic lighting lines restrict movement toggle</label>
                                <input class='lightrestrictmove showtip' id='page-dynamic-lighting-line-restrict-movement-toggle' title='Don&#39;t allow player tokens to move through Dynamic Lighting walls. Can be enabled even if lighting is not used.' type='checkbox' value='1'>
                                <span class='slider round'></span>
                                </input>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <!-- * Audio */ -->
            <hr>
            <div class='audio_settings'>
                <div class='pagedetails__header'>
                    <h3 class='page_title'>Audio</h3>
                </div>
                <div class='pagedetails__subheader'>
                    <h4>Play on Load</h4>
                </div>
                <div class='pagedetails__container'>
                    <label class='sr-only' for='page-audio-play-on-load'>play an audio track on page load</label>
                    <select class='pagejukeboxtrigger' id='page-audio-play-on-load'></select>
                </div>
            </div>

            <!-- BEGIN MOD -->
            <hr>
             <div>
                <div class='pagedetails__header'>
                    <h3 class='page_title'>Weather</h3>
                </div>
                <button class='btn Ve-btn-weather'>
					Configure
				</button>
            </div>
			<!-- END MOD -->

            <!-- * Archive & Delete Buttons */ -->
            <hr>
            <div class='page-buttons d-flex flex-wrap justify-content-between'>
                <button class='archive btn'>Archive Page</button>
                <button class='delete btn btn-danger'>Delete Page</button>
            </div>
        </div>

        <div class='lighting tab-pane'>
            <div class='border_box lighting_feature' data-feature_enabled='dyn_fog_prototype_enabled' id='dyn_fog_prototype_settings'>
				<!-- BEGIN MOD -->
				<strong style="display: block; margin-bottom: 10px;"><i>Requires a paid subscription or all players to use a betteR20 script</i></strong>
				<hr>
				<!-- END MOD -->
                <div class='alert alert-info' role='alert'>
                    <p>This feature is in Active Development: Turning on Updated Dynamic Lighting will turn off Legacy Dynamic Lighting for this page. If you want to go back, you’ll need to turn on Legacy back on for the Page. Revealed areas in one system will not be revealed in the other.  Consider testing the feature in a copy or new game. <a href="https://app.roll20.net/forum/permalink/8422745" target='_blank'>Read More…</a></p>
                </div>
                <div class='dyn_fog_settings'>
                    <div class='row'>
                        <div class='col-xs-6'>
                            <p class='dynamic_lighting_title'>Dynamic Lighting</p>
                        </div>
                        <div class='col-xs-3 dyn_fog_switch'>
                            <label class='switch'>
                                <input class='dyn_fog_enabled feature_enabled' type='checkbox'>
                                <span class='slider round'></span>
                                </input>
                            </label>
                        </div>
                    </div>
                </div>
                <hr>
                <div class='explorer_mode'>
                    <div class='row'>
                        <div class='col-xs-6'>
                            <p class='explorer_mode_title'>Explorer Mode</p>
                        </div>
                        <div class='col-xs-3 dyn_fog_switch'>
                            <label class='switch'>
                                <input class='dyn_fog_autofog_mode' type='checkbox'>
                                <span class='slider round'></span>
                                </input>
                            </label>
                        </div>
                    </div>
                    <div class='row'>
                        <div class='col-xs-11'>
                            <p class='description'>Reveals areas of the Map Layer that Players have already explored. Does not reveal areas that were revealed when Explorer Mode is disabled. Previously called "Advanced Fog of War".</p>
                        </div>
                    </div>
                </div>
                <hr>
                <div class='daylight_mode'>
                    <div class='row'>
                        <div class='col-xs-6'>
                            <p class='explorer_mode_title'>Daylight Mode</p>
                        </div>
                        <div class='col-xs-3 dyn_fog_switch'>
                            <label class='switch'>
                                <input class='dyn_fog_global_illum' type='checkbox'>
                                <span class='slider round'></span>
                                </input>
                            </label>
                        </div>
                    </div>
                    <div class='row'>
                        <div class='col-xs-11'>
                            <p class='description'>Adds Light to the whole Page, good for a sunny day or well lit room or GMs who don't want to place a bunch of torches. Previously called "Global Illumination".</p>
                        </div>
                    </div>
                    <div class='row-fluid clearfix daylight_slider_row' style='display: none;'>
                        <div class='span2' style='float:left'>
                            <label class='distance'>Brightness</label>
                        </div>
                        <div class='span8 dyn_fog_switch' style='float:right'>
                            <div class='form-group'>
                                <div class='input-group flex-group'>
                                    <img class='dyn_fog_img_left flex-item' src='/images/editor/lightbulb_low.svg'>
                                    <input class='dyn_fog_daylight_slider flex-item' max='1' min='0.05' step='0.05' type='range' value='1'>
                                    <img class='dyn_fog_img_right flex-item' src='/images/editor/lightbulb_high.svg'>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <hr>
                <div class='update_on_drop_mode'>
                    <div class='row'>
                        <div class='col-xs-6'>
                            <p class='update_on_drop_title'>Update when Token Drop</p>
                        </div>
                        <div class='col-xs-3 dyn_fog_switch'>
                            <label class='switch'>
                                <input class='dyn_fog_update_on_drop' type='checkbox'>
                                <span class='slider round'></span>
                                </input>
                            </label>
                        </div>
                    </div>
                    <div class='row'>
                        <div class='col-xs-11'>
                            <p class='description'>When dragging and dropping a token, the lighting will only change after a player has dropped, not while dragging.</p>
                        </div>
                    </div>
                </div>
                <hr>
                <div class='gm_darkness_opacity'>
                    <div class='row'>
                        <div class='col-xs-12'>
                            <p class='opacity_title'>GM Darkness Opacity</p>
                        </div>
                    </div>
                    <div class='row'>
                        <div class='col-xs-11'>
                            <p class='description'>The GM can see through dark areas hidden from the Players when using Dynamic Lighting. This setting adjusts the opacity of those dark areas for the GM only.</p>
                        </div>
                    </div>
                    <div class='row'>
                        <div class='col-xs-8'>
                            <div class='fogopacity'></div>
                        </div>
                        <div class='col-xs-1'>
                            <input class='opacity_percentage' disabled type='text'>
                        </div>
                    </div>
                </div>
                <hr>
            </div>
        </div>
    </div>
</script>`;

	d20plus.templates.templatePageSettings = templatePageSettings;
}

SCRIPT_EXTENSIONS.push(initTemplatePageSettings);


const baseTemplate = function () {
	d20plus.template = {};

	d20plus.template.swapTemplates = () => {
		d20plus.ut.log("Swapping templates...");
		$("#tmpl_charactereditor").html($(d20plus.template_charactereditor).html());
		$("#tmpl_handouteditor").html($(d20plus.template_handouteditor).html());
		$("#tmpl_deckeditor").html($(d20plus.template.deckeditor).html());
		$("#tmpl_cardeditor").html($(d20plus.template.cardeditor).html());
	};

	d20plus.settingsHtmlPtFooter = `<p>
			<a class="btn " href="#" id="button-edit-config" style="margin-top: 3px; width: calc(100% - 22px);">Edit Config</a>
			</p>
      <p>
			<a class="btn btn player-hidden" href="#" id="button-view-tools" style="margin-top: 3px; width: calc(100% - 22px);">Open Tools List</a>
			</p>
			<p>
			For help, advice, and updates, <a href="https://discord.gg/nGvRCDs" target="_blank" style="color: #08c;">join our Discord!</a>
			</p>
			<style id="dynamicStyle"></style>
		`;

	d20plus.artTabHtml = `
	<div>
		<h3 style="margin-bottom: 4px;">BetteR20</h3>
		<p style="display: flex; width: 100%; justify-content: space-between;">
			<button class="btn" id="button-add-external-art" style="margin-right: 5px; width: 100%;">Manage External Art</button>
			<button class="btn" id="button-browse-external-art" style="width: 100%;">Browse Repo</button>
		</p>
	</div>
	`;

	d20plus.addArtHTML = `
	<div id="d20plus-artfolder" title="BetteR20 - External Art" style="position: relative">
	<p>Add external images by URL. Any direct link to an image should work.</p>
	<p>
	<input placeholder="Name*" id="art-list-add-name">
	<input placeholder="URL*" id="art-list-add-url">
	<a class="btn" href="#" id="art-list-add-btn">Add URL</a>
	<a class="btn" href="#" id="art-list-multi-add-btn">Add Multiple URLs...</a>
	<a class="btn btn-danger" href="#" id="art-list-delete-all-btn" style="margin-left: 12px;">Delete All</a>
	<p/>
	<hr>
	<div id="art-list-container">
	<input class="search" autocomplete="off" placeholder="Search list..." style="width: 100%;">
	<br>
	<p>
		<span style="display: inline-block; width: 40%; font-weight: bold;">Name</span>
		<span style="display: inline-block; font-weight: bold;">URL</span>
	</p>
	<ul class="list artlist" style="max-height: 600px; overflow-y: scroll; display: block; margin: 0; transform: translateZ(0);"></ul>
	</div>
	</div>`;

	d20plus.addArtMassAdderHTML = `
	<div id="d20plus-artmassadd" title="Mass Add Art URLs">
	<p>One entry per line; entry format: <b>[name]---[URL (direct link to image)]</b> <button class="btn" id="art-list-multi-add-btn-submit">Add URLs</button></p>
	<p><textarea id="art-list-multi-add-area" style="width: 100%; height: 100%; min-height: 500px;" placeholder="My Image---http://example.com/img1.png"></textarea></p>
	</div>`;

	d20plus.artListHTML = `
	<div id="Vetoolsresults">
	<ol class="dd-list" id="image-search-none"><div class="alert white">No results found in 5etools for those keywords.</div></ol>

	<ol class="dd-list" id="image-search-has-results">
		<li class="dd-item dd-folder Vetoolsresult">
			<div class="dd-content">
				<div class="folder-title">From 5etools</div>
			</div>

			<ol class="dd-list Vetoolsresultfolder" id="custom-art-results"></ol>
		</li>
	</ol>
	</div>`;

	d20plus.configEditorHTML = `
	<div id="d20plus-configeditor" title="Better20 - Config Editor" style="position: relative">
	<!-- populate with js -->
	</div>`;

	d20plus.configEditorButtonBarHTML = `
	<div class="ui-dialog-buttonpane ui-widget-content ui-helper-clearfix">
	<div class="ui-dialog-buttonset">
		<button type="button" id="configsave" alt="Save" title="Save Config" class="btn" role="button" aria-disabled="false">
			<span>Save</span>
		</button>
	</div>
	</div>
	`;

	d20plus.tool.toolsListHtml = `
		<div id="d20-tools-list" title="BetteR20 - Tools List" style="position: relative">
		<div class="tools-list">
		<!-- populate with js -->
		</div>
		</div>
		`;

	d20plus.template_actionsMenu = `
		<script id='tmpl_actions_menu' type='text/html'>
			<div class='actions_menu d20contextmenu'>
				<ul>
					<$ if (Object.keys(this).length === 0) { $>
						<li data-action-type='unlock-tokens'>Unlock...</li>
					<$ } $>
					<$ if(this.view && this.view.graphic.type == "image" && this.get("cardid") !== "") { $>
						<li class='head hasSub' data-action-type='takecard'>Take Card</li>
						<li class='head hasSub' data-action-type='flipcard'>Flip Card</li>
					<$ } $>
					<$ if(window.is_gm) { $>
						<$ if(this.view && this.get("isdrawing") === false && window.currentEditingLayer != "map") { $>
							<!-- BEGIN MOD -->
							<li class='head hasSub' data-menuname='massroll'>
								Mass Roll &raquo;
								<ul class='submenu' data-menuname='massroll'>
									<li class='head hasSub' data-action-type='rollinit'>Initiative</li>
									<li class='head hasSub' data-action-type='rollsaves'>Save</li>
									<li class='head hasSub' data-action-type='rollskills'>Skill</li>
								</ul>
							</li>
							<!-- END MOD -->
							<li class='head hasSub' data-action-type='addturn'>Add Turn</li>
						<$ } $>
						<!-- BEGIN MOD -->
						<!-- <li class='head'>Edit</li> -->
						<!-- END MOD -->
						<$ if(this.view) { $>
							<li data-action-type='delete'>Delete</li>
							<li data-action-type='copy'>Copy</li>
						<$ } $>
						<li data-action-type='paste'>Paste</li>
						<!-- BEGIN MOD -->
						<$ if(!this.view) { $>
							<li data-action-type='undo'>Undo</li>
						<$ } $>
						<!-- END MOD -->

						<!-- BEGIN MOD -->
						<$ if(this.view) { $>
							<li class='head hasSub' data-menuname='move'>
							Move &raquo;
								<ul class='submenu' data-menuname='move'>
									<li data-action-type='tofront'>To Front</li>
									<li data-action-type='forward-one'>Forward One<!-- (B-F)--></li>
									<li data-action-type='back-one'>Back One<!-- (B-B)--></li>
									<li data-action-type='toback'>To Back</li>
								</ul>
							</li>
						<$ } $>

						<li class='head hasSub' data-menuname='VeUtil'>
							Utilities &raquo;
							<ul class='submenu' data-menuname='VeUtil'>
								<li data-action-type='util-scenes'>Start Scene</li>
								<$ if(this.get && this.get("type") == "image") { $>
									<div class="ctx__divider"></div>
									<li data-action-type='token-animate'>Animate</li>
									<li data-action-type='token-fly'>Set&nbsp;Flight&nbsp;Height</li>
									<li data-action-type='token-light'>Set&nbsp;Light</li>
								<$ } $>
							</ul>
						</li>
						<!-- END MOD -->

						<li class='head hasSub' data-menuname='advanced'>
							Advanced &raquo;
							<ul class='submenu' data-menuname='advanced'>
								<li data-action-type='group'>Group</li>
								<li data-action-type='ungroup'>Ungroup</li>
								<$ if(this.get && this.get("type") == "image") { $>
									<li class="<$ if (this && this.get("isdrawing")) { $>active<$ } $>" data-action-type="toggledrawing">Is Drawing</li>
									<li class="<$ if (this && this.get("fliph")) { $>active<$ } $>" data-action-type="togglefliph">Flip Horizontal</li>
									<li class="<$ if (this && this.get("flipv")) { $>active<$ } $>" data-action-type="toggleflipv">Flip Vertical</li>
									<li data-action-type='setdimensions'>Set Dimensions</li>
									<$ if(window.currentEditingLayer == "map") { $>
										<li data-action-type='aligntogrid'>Align to Grid</li>
									<$ } $>
								<$ } $>

								<$ if(this.view) { $>
									<li data-action-type='lock-token'>Lock/Unlock Position</li>
								<$ } $>

								<$ if(this.get && this.get("type") == "image") { $>
									<li data-action-type='copy-tokenid'>View Token ID</li>
								<$ } $>
								<$ if(this.get && this.get("type") == "path") { $>
									<li data-action-type='copy-pathid'>View Path ID</li>
								<$ } $>
							</ul>
						</li>

						<li class='head hasSub' data-menuname='positioning'>
							Layer &raquo;
							<ul class='submenu' data-menuname='positioning'>
								<li data-action-type="tolayer_map" class='<$ if(this && this.get && this.get("layer") == "map") { $>active<$ } $>'><span class="pictos ctx__layer-icon">@</span> Map Layer</li>
								<!-- BEGIN MOD -->
								<li data-action-type="tolayer_background" class='<$ if(this && this.get && this.get("layer") == "background") { $>active<$ } $>'><span class="pictos ctx__layer-icon">a</span> Background Layer</li>
								<!-- END MOD -->
								<li data-action-type="tolayer_objects" class='<$ if(this && this.get && this.get("layer") == "objects") { $>active<$ } $>'><span class="pictos ctx__layer-icon">b</span> Token Layer</li>
								<!-- BEGIN MOD -->
								<li data-action-type="tolayer_foreground" class='<$ if(this && this.get && this.get("layer") == "foreground") { $>active<$ } $>'><span class="pictos ctx__layer-icon">B</span> Foreground Layer</li>
								<!-- END MOD -->
								<li data-action-type="tolayer_gmlayer" class='<$ if(this && this.get && this.get("layer") == "gmlayer") { $>active<$ } $>'><span class="pictos ctx__layer-icon">E</span> GM Layer</li>
								<li data-action-type="tolayer_walls" class='<$ if(this && this.get && this.get("layer") == "walls") { $>active<$ } $>'><span class="pictostwo ctx__layer-icon">r</span> Lighting Layer</li>
								<!-- BEGIN MOD -->
								<li data-action-type="tolayer_weather" class='<$ if(this && this.get && this.get("layer") == "weather") { $>active<$ } $>'><span class="pictos ctx__layer-icon">C</span> Weather Layer</li>
								<!-- END MOD -->
							</ul>
						</li>
					<$ } $>

					<$ if(this.view && this.get && this.get("sides") !== "" && this.get("cardid") === "") { $>
						<li class='head hasSub' data-menuname='mutliside'>
							Multi-Sided &raquo;
							<ul class='submenu' data-menuname='multiside'>
								<li data-action-type='side_random'>Random Side</li>
								<li data-action-type='side_choose'>Choose Side</li>
								<li data-action-type='rollertokenresize'>Set Side Size</li>
							</ul>
						</li>
					<$ } $>
				</ul>
			</div>
		</script>
		`;

	d20plus.template_charactereditor = `<script id='tmpl_charactereditor' type='text/html'>
  <div class='dialog largedialog charactereditor' style='display: block;'>
    <div class='tab-content'>
      <div class='bioinfo tab-pane'>
        <div class='row-fluid'>
          <div class='span5'>
            <label>
              <strong>Avatar</strong>
            </label>
            <$ if(true) { $>
            <div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>" style="width: 95%;">
            <div class="status"></div>
            <div class="inner">
              <$ if(this.get("avatar") == "") { $>
              <h4 style="padding-bottom: 0px; marigin-bottom: 0px; color: #777;">Drop a file from your <br>Art Library or computer<small>(JPG, GIF, PNG, WEBM, WP4)</small></h4>
              <br /> or
              <button class="btn">Click to Upload</button>
              <input class="manual" type="file" />
              <$ } else { $>
              <$ if(/.+\\.webm(\\?.*)?$/i.test(this.get("avatar"))) { $>
              <video src="<$!this.get("avatar")$>" draggable="false" muted autoplay loop />
              <$ } else { $>
              <img src="<$!this.get("avatar")$>" draggable="false" />
              <$ } $>
              <div class='remove'><a href='#'>Remove</a></div>
              <$ } $>
            </div>
          </div>
          <$ } else { $>
          <div class='avatar'>
            <$ if(this.get("avatar") != "") { $>
            <img src="<$!this.get("avatar")$>" draggable="false" />
            <$ } $>
          </div>
          <$ } $>
          <div class='clear'></div>
          <!-- BEGIN MOD -->
          <button class="btn character-image-by-url">Set Image from URL</button>
          <div class='clear'></div>
          <!-- END MOD -->
          <$ if (window.is_gm) { $>
          <label>
            <strong>Default Token (Optional)</strong>
          </label>
          <div class="defaulttoken tokenslot <$! this.get("defaulttoken") !== "" ? "filled" : "" $> style="width: 95%;">
          <$ if(this.get("defaulttoken") !== "") { $>
          <img src="" draggable="false" />
          <div class="remove"><a href="#">Remove</a></div>
          <$ } else { $>
          <button class="btn">Use Selected Token</button>
          <small>Select a token on the tabletop to use as the Default Token</small>
          <$ } $>
        </div>
        <!-- BEGIN MOD -->
        <button class="btn token-image-by-url">Set Token Image from URL</button>
        <small style="text-align: left;">(Update will only be visible upon re-opening the sheet)</small>
        <div class='clear'></div>
        <!-- END MOD -->
        <$ } $>
      </div>
      <div class='span7'>
        <label>
          <strong>Name</strong>
        </label>
        <input class='name' type='text'>
        <div class='clear'></div>
        <$ if(window.is_gm) { $>
        <label>
          <strong>In Player's Journals</strong>
        </label>
        <select class='inplayerjournals selectize' multiple='true' style='width: 100%;'>
          <option value="all">All Players</option>
          <$ window.Campaign.players.each(function(player) { $>
          <option value="<$!player.id$>"><$!player.get("displayname")$></option>
          <$ }); $>
        </select>
        <div class='clear'></div>
        <label>
          <strong>Can Be Edited &amp; Controlled By</strong>
        </label>
        <select class='controlledby selectize' multiple='true' style='width: 100%;'>
          <option value="all">All Players</option>
          <$ window.Campaign.players.each(function(player) { $>
          <option value="<$!player.id$>"><$!player.get("displayname")$></option>
          <$ }); $>
        </select>
        <div class='clear'></div>
        <label>
          <strong>Tags</strong>
        </label>
        <input class='tags'>
        <div class='clear'></div>
        <hr>
        <button class='delete btn btn-danger' style='float: right;'>
          Delete
        </button>
        <button class='duplicate btn' style='margin-right: 10px;'>
          Duplicate
        </button>
        <button class='archive btn'>
          <$ if(this.get("archived")) { $>Restore from Archive<$ } else { $>Archive<$ } $>
        </button>
        <div class='clear'></div>
        <$ } $>
        <div class='clear'></div>
      </div>
    </div>
    <div class='row-fluid'>
      <div class='span12'>
        <hr>
        <label>
          <strong>Bio & Info</strong>
        </label>
        <textarea class='bio'></textarea>
        <div class='clear'></div>
        <$ if(window.is_gm) { $>
        <label>
          <strong>GM Notes (Only visible to GM)</strong>
        </label>
        <textarea class='gmnotes'></textarea>
        <div class='clear'></div>
        <$ } $>
      </div>
    </div>
  </div>
  </div>
  </div>
</script>
		`;

	d20plus.template_handouteditor = `<script id='tmpl_handouteditor' type='text/html'>
  <div class='dialog largedialog handouteditor' style='display: block;'>
    <div class='row-fluid'>
      <div class='span12'>
        <label>
          <strong>Name</strong>
        </label>
        <input class='name' type='text'>
        <div class='clear'></div>
        <$ if (window.is_gm) { $>
        <label>
          <strong>In Player's Journals</strong>
        </label>
        <select class='inplayerjournals chosen' multiple='true' style='width: 100%;'>
          <option value="all">All Players</option>
          <$ window.Campaign.players.each(function(player) { $>
          <option value="<$!player.id$>"><$!player.get("displayname")$></option>
          <$ }); $>
        </select>
        <div class='clear'></div>
        <label>
          <strong>Can Be Edited By</strong>
        </label>
        <select class='controlledby chosen' multiple='true' style='width: 100%;'>
          <option value="all">All Players</option>
          <$ window.Campaign.players.each(function(player) { $>
          <option value="<$!player.id$>"><$!player.get("displayname")$></option>
          <$ }); $>
        </select>
        <div class='clear'></div>
        <label>
          <strong>Tags</strong>
        </label>
        <input class='tags'>
        <div class='clear'></div>
        <$ } $>
      </div>
    </div>
    <div class='row-fluid'>
      <div class='span12'>
        <div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>">
        <div class="status"></div>
        <div class="inner">
          <$ if(this.get("avatar") == "") { $>
          <h4 style="padding-bottom: 0px; marigin-bottom: 0px; color: #777;">Drop a file</h4>
          <br /> or
          <button class="btn">Choose a file...</button>
          <input class="manual" type="file" />
          <$ } else { $>
          <$ if(/.+\\.webm(\\?.*)?$/i.test(this.get("avatar"))) { $>
          <video src="<$!this.get("avatar")$>" draggable="false" muted autoplay loop />
          <$ } else { $>
          <img src="<$!this.get("avatar")$>" />
          <$ } $>
          <div class='remove'><a href='#'>Remove</a></div>
          <$ } $>
        </div>
      </div>
      <div class='clear'></div>
    </div>
  </div>
  <!-- BEGIN MOD -->
  <div class='row-fluid'>
  <button class="btn handout-image-by-url">Set Image from URL</button>
  <div class='clear'></div>
  </div>
  <!-- END MOD -->
  <div class='row-fluid'>
    <div class='span12'>
      <label>
        <strong>Description & Notes</strong>
      </label>
      <textarea class='notes'></textarea>
      <div class='clear'></div>
      <$ if(window.is_gm) { $>
      <label>
        <strong>GM Notes (Only visible to GM)</strong>
      </label>
      <textarea class='gmnotes'></textarea>
      <div class='clear'></div>
      <hr>
      <button class='delete btn btn-danger' style='float: right;'>
        Delete Handout
      </button>
      <button class='duplicate btn' style='margin-right: 10px;'>
        Duplicate
      </button>
      <button class='archive btn'>
        <$ if(this.get("archived")) { $>Restore Handout from Archive<$ } else { $>Archive<$ } $>
      </button>
      <div class='clear'></div>
      <$ } $>
    </div>
  </div>
  </div>
</script>
<script id='tmpl_handoutviewer' type='text/html'>
  <div class='dialog largedialog handoutviewer' style='display: block;'>
    <div style='padding: 10px;'>
      <$ if(this.get("avatar") != "") { $>
      <div class='row-fluid'>
        <div class='span12'>
          <div class='avatar'>
            <a class="lightly" target="_blank" href="<$!(this.get("avatar").indexOf("d20.io/") !== -1 ? this.get("avatar").replace(/\\/med\\.(?!webm)/, "/max.") : this.get("avatar"))$>">
            <$ if(/.+\\.webm(\\?.*)?$/i.test(this.get("avatar"))) { $>
            <video src="<$!this.get("avatar")$>" draggable="false" loop muted autoplay />
            <$ } else { $>
            <img src="<$!this.get("avatar")$>" draggable="false" />
            <$ } $>
            <div class='mag-glass pictos'>s</div></a>
            </a>
          </div>
          <div class='clear'></div>
        </div>
      </div>
      <$ } $>
      <div class='row-fluid'>
        <div class='span12'>
          <div class='content note-editor notes'></div>
          <div class='clear'></div>
        </div>
      </div>
      <$ if(window.is_gm) { $>
      <div class='row-fluid'>
        <div class='span12'>
          <hr>
          <label>
            <strong>GM Notes (Only visible to GM)</strong>
          </label>
          <div class='content note-editor gmnotes'></div>
          <div class='clear'></div>
        </div>
      </div>
      <$ } $>
    </div>
  </div>
</script>
	`;

	d20plus.template.deckeditor = `
	<script id='tmpl_deckeditor' type='text/html'>
      <div class='dialog largedialog deckeditor' style='display: block;'>
        <label>Name</label>
        <input class='name' type='text'>
        <div class='clear' style='height: 14px;'></div>
        <label>
          <input class='showplayers' type='checkbox'>
          Show deck to players?
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          <input class='playerscandraw' type='checkbox'>
          Players can draw cards?
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          <input class='infinitecards' type='checkbox'>
          Cards in deck are infinite?
        </label>
        <p class='infinitecardstype'>
          <label>
            <input name='infinitecardstype' type='radio' value='random'>
            Always a random card
          </label>
          <label>
            <input name='infinitecardstype' type='radio' value='cycle'>
            Draw through deck, shuffle, repeat
          </label>
        </p>
        <div class='clear' style='height: 7px;'></div>
        <label>
          Allow choosing specific cards from deck:
          <select class='deckpilemode'>
            <option value='none'>Disabled</option>
            <option value='choosebacks_gm'>GM Choose: Show Backs</option>
            <option value='choosefronts_gm'>GM Choose: Show Fronts</option>
            <option value='choosebacks'>GM + Players Choose: Show Backs</option>
            <option value='choosefronts'>GM + Players Choose: Show Fronts</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          Discard Pile:
          <select class='discardpilemode'>
            <option value='none'>No discard pile</option>
            <option value='choosebacks'>Choose: Show Backs</option>
            <option value='choosefronts'>Choose: Show Fronts</option>
            <option value='drawtop'>Draw most recent/top card</option>
            <option value='drawbottom'>Draw oldest/bottom card</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <hr>
        <strong>When played to the tabletop...</strong>
        <div class='clear' style='height: 5px;'></div>
        <label>
          Played Facing:
          <select class='cardsplayed' style='display: inline-block; width: auto; position: relative; top: 3px;'>
            <option value='facedown'>Face Down</option>
            <option value='faceup'>Face Up</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <label>
          Considered:
          <select class='treatasdrawing' style='display: inline-block; width: auto; position: relative; top: 3px;'>
            <option value='true'>Drawings (No Bubbles/Stats)</option>
            <option value='false'>Tokens (Including Bubbles and Stats)</option>
          </select>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <div class='inlineinputs'>
          Card Size:
          <input class='defaultwidth' type='text'>
          x
          <input class='defaultheight' type='text'>
          px
        </div>
        <small style='text-align: left; padding-left: 135px; width: auto;'>Leave blank for default auto-sizing</small>
        <div class='clear' style='height: 7px;'></div>
        <!-- %label -->
        <!-- %input.showalldrawn(type="checkbox") -->
        <!-- Everyone sees what card is drawn onto top of deck? -->
        <!-- .clear(style="height: 7px;") -->
        <hr>
        <strong>In other's hands...</strong>
        <div class='clear' style='height: 5px;'></div>
        <div class='inlineinputs'>
          <label style='width: 75px;'>Players see:</label>
          <label>
            <input class='players_seenumcards' type='checkbox'>
            Number of Cards
          </label>
          <label>
            <input class='players_seefrontofcards' type='checkbox'>
            Front of Cards
          </label>
        </div>
        <div class='clear' style='height: 5px;'></div>
        <div class='inlineinputs'>
          <label style='width: 75px;'>GM sees:</label>
          <label>
            <input class='gm_seenumcards' type='checkbox'>
            Number of Cards
          </label>
          <label>
            <input class='gm_seefrontofcards' type='checkbox'>
            Front of Cards
          </label>
        </div>
        <div class='clear' style='height: 5px;'></div>
        <hr>
        <!-- BEGIN MOD -->
        <button class='btn deck-mass-cards-by-url' style='float: right; margin-left: 5px;' data-deck-id="<$!this.id$>">
          Add Cards from URLs
        </button>
        <!-- END MOD -->
        <button class='addcard btn' style='float: right;'>
          <span class='pictos'>&</span>
          Add Card
        </button>
        <h3>Cards</h3>
        <div class='clear' style='height: 7px;'></div>
        <table class='table table-striped'>
          <tbody></tbody>
        </table>
        <div class='clear' style='height: 15px;'></div>
        <label>
          <strong>Card Backing (Required)</strong>
        </label>
        <div class='clear' style='height: 7px;'></div>
        <!-- BEGIN MOD -->
        <button class='btn deck-image-by-url' style="margin-bottom: 10px" data-deck-id="<$!this.id$>">Set image from URL...</button>
        <!-- END MOD -->
        <div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>">
        <div class='status'></div>
        <div class='inner'></div>
        <$ if(this.get("avatar") == "") { $>
        <h4 style='padding-bottom: 0px; marigin-bottom: 0px; color: #777;'>Drop a file</h4>
        <br>or</br>
        <button class='btn'>Choose a file...</button>
        <input class='manual' type='file'>
        <$ } else { $>
        <img src="<$!this.get("avatar")$>" />
        <div class='remove'>
          <a href='javascript:void(0);'>Remove</a>
        </div>
        <$ } $>
        </div>
        </div>
        <div class='clear' style='height: 20px;'></div>
        <p style='float: left;'>
          <button class='btn dupedeck'>Duplicate Deck</button>
        </p>
        <$ if(this.id != "A778E120-672D-49D0-BAF8-8646DA3D3FAC") { $>
        <p style='text-align: right;'>
          <button class='btn btn-danger deletedeck'>Delete Deck</button>
        </p>
        <$ } $>
      </div>
    </script>
	`;
	d20plus.template.cardeditor = `
    <script id='tmpl_cardeditor' type='text/html'>
      <div class='dialog largedialog cardeditor' style='display: block;'>
        <label>Name</label>
        <input class='name' type='text'>
        <div class='clear'></div>
        <!-- BEGIN MOD -->
        <button class='btn card-image-by-url' style="margin-bottom: 10px" data-card-id="<$!this.id$>">Set image from URL...</button>
        <!-- END MOD -->
        <div class="avatar dropbox <$! this.get("avatar") != "" ? "filled" : "" $>">
        <div class="status"></div>
        <div class="inner">
        <$ if(this.get("avatar") == "") { $>
        <h4 style='padding-bottom: 0px; marigin-bottom: 0px; color: #777;'>Drop a file</h4>
        <br>or</br>
        <button class='btn'>Choose a file...</button>
        <input class='manual' type='file'>
        <$ } else { $>
        <img src="<$!this.get("avatar")$>" />
        <div class='remove'>
          <a href='javascript:void(0);'>Remove</a>
        </div>
        <$ } $>
        </div>
        </div>
        <div class='clear'></div>
        <label>&nbsp;</label>
        <button class='deletecard btn btn-danger'>Delete Card</button>
      </div>
    </script>
	`
};

SCRIPT_EXTENSIONS.push(baseTemplate);


const betteR20Emoji = function () {
	d20plus.chat = {};

	/* eslint-disable */

	// to dump the keys as one-per-line colon-fotmatted: `JSON.stringify(Object.keys(d20plus.chat.emojiIndex).sort(SortUtil.ascSortLower), null, 1).replace(/",/g, ":").replace(/"/g, ":").replace(/[ \[\]]/g, "").trim()`
	d20plus.chat.emojiIndex = {
		joy: !0,
		heart: !0,
		heart_eyes: !0,
		sob: !0,
		blush: !0,
		unamused: !0,
		kissing_heart: !0,
		two_hearts: !0,
		weary: !0,
		ok_hand: !0,
		pensive: !0,
		smirk: !0,
		grin: !0,
		recycle: !0,
		wink: !0,
		thumbsup: !0,
		pray: !0,
		relieved: !0,
		notes: !0,
		flushed: !0,
		raised_hands: !0,
		see_no_evil: !0,
		cry: !0,
		sunglasses: !0,
		v: !0,
		eyes: !0,
		sweat_smile: !0,
		sparkles: !0,
		sleeping: !0,
		smile: !0,
		purple_heart: !0,
		broken_heart: !0,
		expressionless: !0,
		sparkling_heart: !0,
		blue_heart: !0,
		confused: !0,
		information_desk_person: !0,
		stuck_out_tongue_winking_eye: !0,
		disappointed: !0,
		yum: !0,
		neutral_face: !0,
		sleepy: !0,
		clap: !0,
		cupid: !0,
		heartpulse: !0,
		revolving_hearts: !0,
		arrow_left: !0,
		speak_no_evil: !0,
		kiss: !0,
		point_right: !0,
		cherry_blossom: !0,
		scream: !0,
		fire: !0,
		rage: !0,
		smiley: !0,
		tada: !0,
		tired_face: !0,
		camera: !0,
		rose: !0,
		stuck_out_tongue_closed_eyes: !0,
		muscle: !0,
		skull: !0,
		sunny: !0,
		yellow_heart: !0,
		triumph: !0,
		new_moon_with_face: !0,
		laughing: !0,
		sweat: !0,
		point_left: !0,
		heavy_check_mark: !0,
		heart_eyes_cat: !0,
		grinning: !0,
		mask: !0,
		green_heart: !0,
		wave: !0,
		persevere: !0,
		heartbeat: !0,
		arrow_forward: !0,
		arrow_backward: !0,
		arrow_right_hook: !0,
		leftwards_arrow_with_hook: !0,
		crown: !0,
		kissing_closed_eyes: !0,
		stuck_out_tongue: !0,
		disappointed_relieved: !0,
		innocent: !0,
		headphones: !0,
		white_check_mark: !0,
		confounded: !0,
		arrow_right: !0,
		angry: !0,
		grimacing: !0,
		star2: !0,
		gun: !0,
		raising_hand: !0,
		thumbsdown: !0,
		dancer: !0,
		musical_note: !0,
		no_mouth: !0,
		dizzy: !0,
		fist: !0,
		point_down: !0,
		red_circle: !0,
		no_good: !0,
		boom: !0,
		thought_balloon: !0,
		tongue: !0,
		poop: !0,
		cold_sweat: !0,
		gem: !0,
		ok_woman: !0,
		pizza: !0,
		joy_cat: !0,
		sun_with_face: !0,
		leaves: !0,
		sweat_drops: !0,
		penguin: !0,
		zzz: !0,
		walking: !0,
		airplane: !0,
		balloon: !0,
		star: !0,
		ribbon: !0,
		ballot_box_with_check: !0,
		worried: !0,
		underage: !0,
		fearful: !0,
		four_leaf_clover: !0,
		hibiscus: !0,
		microphone: !0,
		open_hands: !0,
		ghost: !0,
		palm_tree: !0,
		bangbang: !0,
		nail_care: !0,
		x: !0,
		alien: !0,
		bow: !0,
		cloud: !0,
		soccer: !0,
		angel: !0,
		dancers: !0,
		exclamation: !0,
		snowflake: !0,
		point_up: !0,
		kissing_smiling_eyes: !0,
		rainbow: !0,
		crescent_moon: !0,
		heart_decoration: !0,
		gift_heart: !0,
		gift: !0,
		beers: !0,
		anguished: !0,
		earth_africa: !0,
		movie_camera: !0,
		anchor: !0,
		zap: !0,
		heavy_multiplication_x: !0,
		runner: !0,
		sunflower: !0,
		earth_americas: !0,
		bouquet: !0,
		dog: !0,
		moneybag: !0,
		herb: !0,
		couple: !0,
		fallen_leaf: !0,
		tulip: !0,
		birthday: !0,
		cat: !0,
		coffee: !0,
		dizzy_face: !0,
		point_up_2: !0,
		open_mouth: !0,
		hushed: !0,
		basketball: !0,
		christmas_tree: !0,
		ring: !0,
		full_moon_with_face: !0,
		astonished: !0,
		two_women_holding_hands: !0,
		money_with_wings: !0,
		crying_cat_face: !0,
		hear_no_evil: !0,
		dash: !0,
		cactus: !0,
		hotsprings: !0,
		telephone: !0,
		maple_leaf: !0,
		princess: !0,
		massage: !0,
		love_letter: !0,
		trophy: !0,
		person_frowning: !0,
		us: !0,
		confetti_ball: !0,
		blossom: !0,
		lips: !0,
		fries: !0,
		doughnut: !0,
		frowning: !0,
		ocean: !0,
		bomb: !0,
		ok: !0,
		cyclone: !0,
		rocket: !0,
		umbrella: !0,
		couplekiss: !0,
		couple_with_heart: !0,
		lollipop: !0,
		clapper: !0,
		pig: !0,
		smiling_imp: !0,
		imp: !0,
		bee: !0,
		kissing_cat: !0,
		anger: !0,
		musical_score: !0,
		santa: !0,
		earth_asia: !0,
		football: !0,
		guitar: !0,
		panda_face: !0,
		speech_balloon: !0,
		strawberry: !0,
		smirk_cat: !0,
		banana: !0,
		watermelon: !0,
		snowman: !0,
		smile_cat: !0,
		top: !0,
		eggplant: !0,
		crystal_ball: !0,
		fork_and_knife: !0,
		calling: !0,
		iphone: !0,
		partly_sunny: !0,
		warning: !0,
		scream_cat: !0,
		small_orange_diamond: !0,
		baby: !0,
		feet: !0,
		footprints: !0,
		beer: !0,
		wine_glass: !0,
		o: !0,
		video_camera: !0,
		rabbit: !0,
		tropical_drink: !0,
		smoking: !0,
		space_invader: !0,
		peach: !0,
		snake: !0,
		turtle: !0,
		cherries: !0,
		kissing: !0,
		frog: !0,
		milky_way: !0,
		rotating_light: !0,
		hatching_chick: !0,
		closed_book: !0,
		candy: !0,
		hamburger: !0,
		bear: !0,
		tiger: !0,
		fast_forward: !0,
		icecream: !0,
		pineapple: !0,
		ear_of_rice: !0,
		syringe: !0,
		put_litter_in_its_place: !0,
		chocolate_bar: !0,
		black_small_square: !0,
		tv: !0,
		pill: !0,
		octopus: !0,
		jack_o_lantern: !0,
		grapes: !0,
		smiley_cat: !0,
		cd: !0,
		cocktail: !0,
		cake: !0,
		video_game: !0,
		arrow_down: !0,
		no_entry_sign: !0,
		lipstick: !0,
		whale: !0,
		cookie: !0,
		dolphin: !0,
		loud_sound: !0,
		man: !0,
		hatched_chick: !0,
		monkey: !0,
		books: !0,
		japanese_ogre: !0,
		guardsman: !0,
		loudspeaker: !0,
		scissors: !0,
		girl: !0,
		mortar_board: !0,
		fr: !0,
		baseball: !0,
		vertical_traffic_light: !0,
		woman: !0,
		fireworks: !0,
		stars: !0,
		sos: !0,
		mushroom: !0,
		pouting_cat: !0,
		left_luggage: !0,
		high_heel: !0,
		dart: !0,
		swimmer: !0,
		key: !0,
		bikini: !0,
		family: !0,
		pencil2: !0,
		elephant: !0,
		droplet: !0,
		seedling: !0,
		apple: !0,
		cool: !0,
		telephone_receiver: !0,
		dollar: !0,
		house_with_garden: !0,
		book: !0,
		haircut: !0,
		computer: !0,
		bulb: !0,
		question: !0,
		back: !0,
		boy: !0,
		closed_lock_with_key: !0,
		person_with_pouting_face: !0,
		tangerine: !0,
		sunrise: !0,
		poultry_leg: !0,
		blue_circle: !0,
		oncoming_automobile: !0,
		shaved_ice: !0,
		bird: !0,
		first_quarter_moon_with_face: !0,
		eyeglasses: !0,
		goat: !0,
		night_with_stars: !0,
		older_woman: !0,
		black_circle: !0,
		new_moon: !0,
		two_men_holding_hands: !0,
		white_circle: !0,
		customs: !0,
		tropical_fish: !0,
		house: !0,
		arrows_clockwise: !0,
		last_quarter_moon_with_face: !0,
		round_pushpin: !0,
		full_moon: !0,
		athletic_shoe: !0,
		lemon: !0,
		baby_bottle: !0,
		spaghetti: !0,
		wind_chime: !0,
		fish_cake: !0,
		evergreen_tree: !0,
		up: !0,
		arrow_up: !0,
		arrow_upper_right: !0,
		arrow_lower_right: !0,
		arrow_lower_left: !0,
		performing_arts: !0,
		nose: !0,
		pig_nose: !0,
		fish: !0,
		man_with_turban: !0,
		koala: !0,
		ear: !0,
		eight_spoked_asterisk: !0,
		small_blue_diamond: !0,
		shower: !0,
		bug: !0,
		ramen: !0,
		tophat: !0,
		bride_with_veil: !0,
		fuelpump: !0,
		checkered_flag: !0,
		horse: !0,
		watch: !0,
		monkey_face: !0,
		baby_symbol: !0,
		new: !0,
		free: !0,
		sparkler: !0,
		corn: !0,
		tennis: !0,
		alarm_clock: !0,
		battery: !0,
		grey_exclamation: !0,
		wolf: !0,
		moyai: !0,
		cow: !0,
		mega: !0,
		older_man: !0,
		dress: !0,
		link: !0,
		chicken: !0,
		whale2: !0,
		arrow_upper_left: !0,
		deciduous_tree: !0,
		bento: !0,
		pushpin: !0,
		soon: !0,
		repeat: !0,
		dragon: !0,
		hamster: !0,
		golf: !0,
		surfer: !0,
		mouse: !0,
		waxing_crescent_moon: !0,
		blue_car: !0,
		a: !0,
		interrobang: !0,
		u5272: !0,
		electric_plug: !0,
		first_quarter_moon: !0,
		cancer: !0,
		trident: !0,
		bread: !0,
		cop: !0,
		tea: !0,
		fishing_pole_and_fish: !0,
		bike: !0,
		rice: !0,
		radio: !0,
		baby_chick: !0,
		arrow_heading_down: !0,
		waning_crescent_moon: !0,
		arrow_up_down: !0,
		last_quarter_moon: !0,
		radio_button: !0,
		sheep: !0,
		person_with_blond_hair: !0,
		waning_gibbous_moon: !0,
		lock: !0,
		green_apple: !0,
		japanese_goblin: !0,
		curly_loop: !0,
		triangular_flag_on_post: !0,
		arrows_counterclockwise: !0,
		racehorse: !0,
		fried_shrimp: !0,
		sunrise_over_mountains: !0,
		volcano: !0,
		rooster: !0,
		inbox_tray: !0,
		wedding: !0,
		sushi: !0,
		wavy_dash: !0,
		ice_cream: !0,
		rewind: !0,
		tomato: !0,
		rabbit2: !0,
		eight_pointed_black_star: !0,
		small_red_triangle: !0,
		high_brightness: !0,
		heavy_plus_sign: !0,
		man_with_gua_pi_mao: !0,
		convenience_store: !0,
		busts_in_silhouette: !0,
		beetle: !0,
		small_red_triangle_down: !0,
		arrow_heading_up: !0,
		name_badge: !0,
		bath: !0,
		no_entry: !0,
		crocodile: !0,
		dog2: !0,
		cat2: !0,
		hammer: !0,
		meat_on_bone: !0,
		shell: !0,
		sparkle: !0,
		b: !0,
		m: !0,
		poodle: !0,
		aquarius: !0,
		stew: !0,
		jeans: !0,
		honey_pot: !0,
		musical_keyboard: !0,
		unlock: !0,
		black_nib: !0,
		statue_of_liberty: !0,
		heavy_dollar_sign: !0,
		snowboarder: !0,
		white_flower: !0,
		necktie: !0,
		diamond_shape_with_a_dot_inside: !0,
		aries: !0,
		womens: !0,
		ant: !0,
		scorpius: !0,
		city_sunset: !0,
		hourglass_flowing_sand: !0,
		o2: !0,
		dragon_face: !0,
		snail: !0,
		dvd: !0,
		shirt: !0,
		game_die: !0,
		heavy_minus_sign: !0,
		dolls: !0,
		sagittarius: !0,
		"8ball": !0,
		bus: !0,
		custard: !0,
		crossed_flags: !0,
		part_alternation_mark: !0,
		camel: !0,
		curry: !0,
		steam_locomotive: !0,
		hospital: !0,
		large_blue_diamond: !0,
		tanabata_tree: !0,
		bell: !0,
		leo: !0,
		gemini: !0,
		pear: !0,
		large_orange_diamond: !0,
		taurus: !0,
		globe_with_meridians: !0,
		door: !0,
		clock6: !0,
		oncoming_police_car: !0,
		envelope_with_arrow: !0,
		closed_umbrella: !0,
		saxophone: !0,
		church: !0,
		bicyclist: !0,
		pisces: !0,
		dango: !0,
		capricorn: !0,
		office: !0,
		rowboat: !0,
		womans_hat: !0,
		mans_shoe: !0,
		love_hotel: !0,
		mount_fuji: !0,
		dromedary_camel: !0,
		handbag: !0,
		hourglass: !0,
		negative_squared_cross_mark: !0,
		trumpet: !0,
		school: !0,
		cow2: !0,
		construction_worker: !0,
		toilet: !0,
		pig2: !0,
		grey_question: !0,
		beginner: !0,
		violin: !0,
		on: !0,
		credit_card: !0,
		id: !0,
		secret: !0,
		ferris_wheel: !0,
		bowling: !0,
		libra: !0,
		virgo: !0,
		barber: !0,
		purse: !0,
		roller_coaster: !0,
		rat: !0,
		date: !0,
		rugby_football: !0,
		ram: !0,
		arrow_up_small: !0,
		black_square_button: !0,
		mobile_phone_off: !0,
		tokyo_tower: !0,
		congratulations: !0,
		kimono: !0,
		ship: !0,
		mag_right: !0,
		mag: !0,
		fire_engine: !0,
		clock1130: !0,
		police_car: !0,
		black_joker: !0,
		bridge_at_night: !0,
		package: !0,
		oncoming_taxi: !0,
		calendar: !0,
		horse_racing: !0,
		tiger2: !0,
		boot: !0,
		ambulance: !0,
		white_square_button: !0,
		boar: !0,
		school_satchel: !0,
		loop: !0,
		pound: !0,
		information_source: !0,
		ox: !0,
		rice_ball: !0,
		vs: !0,
		end: !0,
		parking: !0,
		sandal: !0,
		tent: !0,
		seat: !0,
		taxi: !0,
		black_medium_small_square: !0,
		briefcase: !0,
		newspaper: !0,
		circus_tent: !0,
		six_pointed_star: !0,
		mens: !0,
		european_castle: !0,
		flashlight: !0,
		foggy: !0,
		arrow_double_up: !0,
		bamboo: !0,
		ticket: !0,
		helicopter: !0,
		minidisc: !0,
		oncoming_bus: !0,
		melon: !0,
		white_small_square: !0,
		european_post_office: !0,
		keycap_ten: !0,
		notebook: !0,
		no_bell: !0,
		oden: !0,
		flags: !0,
		carousel_horse: !0,
		blowfish: !0,
		chart_with_upwards_trend: !0,
		sweet_potato: !0,
		ski: !0,
		clock12: !0,
		signal_strength: !0,
		construction: !0,
		black_medium_square: !0,
		satellite: !0,
		euro: !0,
		womans_clothes: !0,
		ledger: !0,
		leopard: !0,
		low_brightness: !0,
		clock3: !0,
		department_store: !0,
		truck: !0,
		sake: !0,
		railway_car: !0,
		speedboat: !0,
		vhs: !0,
		clock1: !0,
		arrow_double_down: !0,
		water_buffalo: !0,
		arrow_down_small: !0,
		yen: !0,
		mute: !0,
		running_shirt_with_sash: !0,
		white_large_square: !0,
		wheelchair: !0,
		clock2: !0,
		paperclip: !0,
		atm: !0,
		cinema: !0,
		telescope: !0,
		rice_scene: !0,
		blue_book: !0,
		white_medium_square: !0,
		postbox: !0,
		"e-mail": !0,
		mouse2: !0,
		bullettrain_side: !0,
		ideograph_advantage: !0,
		nut_and_bolt: !0,
		ng: !0,
		hotel: !0,
		wc: !0,
		izakaya_lantern: !0,
		repeat_one: !0,
		mailbox_with_mail: !0,
		chart_with_downwards_trend: !0,
		green_book: !0,
		tractor: !0,
		fountain: !0,
		metro: !0,
		clipboard: !0,
		no_mobile_phones: !0,
		clock4: !0,
		no_smoking: !0,
		black_large_square: !0,
		slot_machine: !0,
		clock5: !0,
		bathtub: !0,
		scroll: !0,
		station: !0,
		rice_cracker: !0,
		bank: !0,
		wrench: !0,
		u6307: !0,
		articulated_lorry: !0,
		page_facing_up: !0,
		ophiuchus: !0,
		bar_chart: !0,
		no_pedestrians: !0,
		vibration_mode: !0,
		clock10: !0,
		clock9: !0,
		bullettrain_front: !0,
		minibus: !0,
		tram: !0,
		clock8: !0,
		u7a7a: !0,
		traffic_light: !0,
		mountain_bicyclist: !0,
		microscope: !0,
		japanese_castle: !0,
		bookmark: !0,
		bookmark_tabs: !0,
		pouch: !0,
		ab: !0,
		page_with_curl: !0,
		flower_playing_cards: !0,
		clock11: !0,
		fax: !0,
		clock7: !0,
		white_medium_small_square: !0,
		currency_exchange: !0,
		sound: !0,
		chart: !0,
		cl: !0,
		floppy_disk: !0,
		post_office: !0,
		speaker: !0,
		japan: !0,
		u55b6: !0,
		mahjong: !0,
		incoming_envelope: !0,
		orange_book: !0,
		restroom: !0,
		u7121: !0,
		u6709: !0,
		triangular_ruler: !0,
		train: !0,
		u7533: !0,
		trolleybus: !0,
		u6708: !0,
		notebook_with_decorative_cover: !0,
		u7981: !0,
		u6e80: !0,
		postal_horn: !0,
		factory: !0,
		children_crossing: !0,
		train2: !0,
		straight_ruler: !0,
		pager: !0,
		accept: !0,
		u5408: !0,
		lock_with_ink_pen: !0,
		clock130: !0,
		sa: !0,
		outbox_tray: !0,
		twisted_rightwards_arrows: !0,
		mailbox: !0,
		light_rail: !0,
		clock930: !0,
		busstop: !0,
		open_file_folder: !0,
		file_folder: !0,
		potable_water: !0,
		card_index: !0,
		clock230: !0,
		monorail: !0,
		clock1230: !0,
		clock1030: !0,
		abc: !0,
		mailbox_closed: !0,
		clock430: !0,
		mountain_railway: !0,
		do_not_litter: !0,
		clock330: !0,
		heavy_division_sign: !0,
		clock730: !0,
		clock530: !0,
		capital_abcd: !0,
		mailbox_with_no_mail: !0,
		symbols: !0,
		aerial_tramway: !0,
		clock830: !0,
		clock630: !0,
		abcd: !0,
		mountain_cableway: !0,
		koko: !0,
		passport_control: !0,
		"non-potable_water": !0,
		suspension_railway: !0,
		baggage_claim: !0,
		no_bicycles: !0,
		skull_crossbones: !0,
		hugging: !0,
		thinking: !0,
		nerd: !0,
		zipper_mouth: !0,
		rolling_eyes: !0,
		upside_down: !0,
		slight_smile: !0,
		middle_finger: !0,
		writing_hand: !0,
		dark_sunglasses: !0,
		eye: !0,
		man_in_suit: !0,
		golfer: !0,
		heart_exclamation: !0,
		star_of_david: !0,
		cross: !0,
		"fleur-de-lis": !0,
		atom: !0,
		wheel_of_dharma: !0,
		yin_yang: !0,
		peace: !0,
		star_and_crescent: !0,
		orthodox_cross: !0,
		biohazard: !0,
		radioactive: !0,
		place_of_worship: !0,
		anger_right: !0,
		menorah: !0,
		om_symbol: !0,
		coffin: !0,
		gear: !0,
		alembic: !0,
		scales: !0,
		crossed_swords: !0,
		keyboard: !0,
		shield: !0,
		bed: !0,
		shopping_bags: !0,
		sleeping_accommodation: !0,
		ballot_box: !0,
		compression: !0,
		wastebasket: !0,
		file_cabinet: !0,
		trackball: !0,
		printer: !0,
		joystick: !0,
		hole: !0,
		candle: !0,
		prayer_beads: !0,
		camera_with_flash: !0,
		amphora: !0,
		label: !0,
		flag_black: !0,
		flag_white: !0,
		film_frames: !0,
		control_knobs: !0,
		level_slider: !0,
		thermometer: !0,
		airplane_arriving: !0,
		airplane_departure: !0,
		railway_track: !0,
		motorway: !0,
		synagogue: !0,
		mosque: !0,
		kaaba: !0,
		stadium: !0,
		desert: !0,
		classical_building: !0,
		cityscape: !0,
		camping: !0,
		bow_and_arrow: !0,
		rosette: !0,
		volleyball: !0,
		medal: !0,
		reminder_ribbon: !0,
		popcorn: !0,
		champagne: !0,
		hot_pepper: !0,
		burrito: !0,
		taco: !0,
		hotdog: !0,
		shamrock: !0,
		comet: !0,
		turkey: !0,
		scorpion: !0,
		lion_face: !0,
		crab: !0,
		spider_web: !0,
		spider: !0,
		chipmunk: !0,
		wind_blowing_face: !0,
		fog: !0,
		play_pause: !0,
		track_previous: !0,
		track_next: !0,
		beach_umbrella: !0,
		chains: !0,
		pick: !0,
		stopwatch: !0,
		ferry: !0,
		mountain: !0,
		shinto_shrine: !0,
		ice_skate: !0,
		skier: !0,
		flag_ac: !0,
		flag_ad: !0,
		flag_ae: !0,
		flag_af: !0,
		flag_ag: !0,
		flag_ai: !0,
		flag_al: !0,
		flag_am: !0,
		"flag-ao": !0,
		"flag-aq": !0,
		"flag-ar": !0,
		"flag-as": !0,
		"flag-at": !0,
		"flag-au": !0,
		"flag-aw": !0,
		"flag-ax": !0,
		"flag-az": !0,
		"flag-ba": !0,
		"flag-bb": !0,
		"flag-bd": !0,
		"flag-be": !0,
		"flag-bf": !0,
		"flag-bg": !0,
		"flag-bh": !0,
		"flag-bi": !0,
		"flag-bj": !0,
		"flag-bl": !0,
		"flag-bm": !0,
		"flag-bn": !0,
		"flag-bo": !0,
		"flag-bq": !0,
		"flag-br": !0,
		"flag-bs": !0,
		"flag-bt": !0,
		"flag-bv": !0,
		"flag-bw": !0,
		"flag-by": !0,
		"flag-bz": !0,
		"flag-ca": !0,
		"flag-cc": !0,
		"flag-cd": !0,
		"flag-cf": !0,
		"flag-cg": !0,
		"flag-ch": !0,
		"flag-ci": !0,
		"flag-ck": !0,
		"flag-cl": !0,
		"flag-cm": !0,
		"flag-cn": !0,
		"flag-co": !0,
		"flag-cp": !0,
		"flag-cr": !0,
		"flag-cu": !0,
		"flag-cv": !0,
		"flag-cw": !0,
		"flag-cx": !0,
		"flag-cy": !0,
		"flag-cz": !0,
		"flag-de": !0,
		"flag-dg": !0,
		"flag-dj": !0,
		"flag-dk": !0,
		"flag-dm": !0,
		"flag-do": !0,
		"flag-dz": !0,
		"flag-ea": !0,
		"flag-ec": !0,
		"flag-ee": !0,
		"flag-eg": !0,
		"flag-eh": !0,
		"flag-er": !0,
		"flag-es": !0,
		"flag-et": !0,
		"flag-eu": !0,
		"flag-fi": !0,
		"flag-fj": !0,
		"flag-fk": !0,
		"flag-fm": !0,
		"flag-fo": !0,
		"flag-fr": !0,
		"flag-ga": !0,
		"flag-gb": !0,
		"flag-gd": !0,
		"flag-ge": !0,
		"flag-gf": !0,
		"flag-gg": !0,
		"flag-gh": !0,
		"flag-gi": !0,
		"flag-gl": !0,
		"flag-gm": !0,
		"flag-gn": !0,
		"flag-gp": !0,
		"flag-gq": !0,
		"flag-gr": !0,
		"flag-gs": !0,
		"flag-gt": !0,
		"flag-gu": !0,
		"flag-gw": !0,
		"flag-gy": !0,
		"flag-hk": !0,
		"flag-hm": !0,
		"flag-hn": !0,
		"flag-hr": !0,
		"flag-ht": !0,
		"flag-hu": !0,
		"flag-ic": !0,
		"flag-id": !0,
		"flag-ie": !0,
		"flag-il": !0,
		"flag-im": !0,
		"flag-in": !0,
		"flag-io": !0,
		"flag-iq": !0,
		"flag-ir": !0,
		"flag-is": !0,
		"flag-it": !0,
		"flag-je": !0,
		"flag-jm": !0,
		"flag-jo": !0,
		"flag-jp": !0,
		"flag-ke": !0,
		"flag-kg": !0,
		"flag-kh": !0,
		"flag-ki": !0,
		"flag-km": !0,
		"flag-kn": !0,
		"flag-kp": !0,
		"flag-kr": !0,
		"flag-kw": !0,
		"flag-ky": !0,
		"flag-kz": !0,
		"flag-la": !0,
		"flag-lb": !0,
		"flag-lc": !0,
		"flag-li": !0,
		"flag-lk": !0,
		"flag-lr": !0,
		"flag-ls": !0,
		"flag-lt": !0,
		"flag-lu": !0,
		"flag-lv": !0,
		"flag-ly": !0,
		"flag-ma": !0,
		"flag-mc": !0,
		"flag-md": !0,
		"flag-me": !0,
		"flag-mf": !0,
		"flag-mg": !0,
		"flag-mh": !0,
		"flag-mk": !0,
		"flag-ml": !0,
		"flag-mm": !0,
		"flag-mn": !0,
		"flag-mo": !0,
		"flag-mp": !0,
		"flag-mq": !0,
		"flag-mr": !0,
		"flag-ms": !0,
		"flag-mt": !0,
		"flag-mu": !0,
		"flag-mv": !0,
		"flag-mw": !0,
		"flag-mx": !0,
		"flag-my": !0,
		"flag-mz": !0,
		"flag-na": !0,
		"flag-nc": !0,
		"flag-ne": !0,
		"flag-nf": !0,
		"flag-ng": !0,
		"flag-ni": !0,
		"flag-nl": !0,
		"flag-no": !0,
		"flag-np": !0,
		"flag-nr": !0,
		"flag-nu": !0,
		"flag-nz": !0,
		"flag-om": !0,
		"flag-pa": !0,
		"flag-pe": !0,
		"flag-pf": !0,
		"flag-pg": !0,
		"flag-ph": !0,
		"flag-pk": !0,
		"flag-pl": !0,
		"flag-pm": !0,
		"flag-pn": !0,
		"flag-pr": !0,
		"flag-ps": !0,
		"flag-pt": !0,
		"flag-pw": !0,
		"flag-py": !0,
		"flag-qa": !0,
		"flag-re": !0,
		"flag-ro": !0,
		"flag-rs": !0,
		"flag-ru": !0,
		"flag-rw": !0,
		"flag-sa": !0,
		"flag-sb": !0,
		"flag-sc": !0,
		"flag-sd": !0,
		"flag-se": !0,
		"flag-sg": !0,
		"flag-sh": !0,
		"flag-si": !0,
		"flag-sj": !0,
		"flag-sk": !0,
		"flag-sl": !0,
		"flag-sm": !0,
		"flag-sn": !0,
		"flag-so": !0,
		"flag-sr": !0,
		"flag-ss": !0,
		"flag-st": !0,
		"flag-sv": !0,
		"flag-sx": !0,
		"flag-sy": !0,
		"flag-sz": !0,
		"flag-ta": !0,
		"flag-tc": !0,
		"flag-td": !0,
		"flag-tf": !0,
		"flag-tg": !0,
		"flag-th": !0,
		"flag-tj": !0,
		"flag-tk": !0,
		"flag-tl": !0,
		"flag-tm": !0,
		"flag-tn": !0,
		"flag-to": !0,
		"flag-tr": !0,
		"flag-tt": !0,
		"flag-tv": !0,
		"flag-tw": !0,
		"flag-tz": !0,
		"flag-ua": !0,
		"flag-ug": !0,
		"flag-um": !0,
		"flag-us": !0,
		"flag-uy": !0,
		"flag-uz": !0,
		"flag-va": !0,
		"flag-vc": !0,
		"flag-ve": !0,
		"flag-vg": !0,
		"flag-vi": !0,
		"flag-vn": !0,
		flag_vu: !0,
		flag_wf: !0,
		flag_ws: !0,
		flag_xk: !0,
		flag_ye: !0,
		flag_yt: !0,
		flag_za: !0,
		flag_zm: !0,
		flag_zw: !0,
		black_heart: !0,
		speech_left: !0,
		egg: !0,
		octagonal_sign: !0,
		spades: !0,
		hearts: !0,
		diamonds: !0,
		clubs: !0,
		drum: !0,
		left_right_arrow: !0,
		tm: !0,
		"100": !0
	};

	/* eslint-enable */

	addConfigOptions(
		"interface", {
			_name: "Interface",
			emoji: {
				name: "Add Emoji Replacement to Chat",
				default: true,
				_type: "boolean",
				_player: true,
			},
		},
	);

	d20plus.chat.enhanceChat = () => {
		d20plus.ut.log("Enhancing chat");
		const tc = d20.textchat.$textarea;
		$("#textchat-input").off("click", "button")
		$("#textchat-input").on("click", "button", function () {
			if (d20plus.cfg.getOrDefault("interface", "emoji")) {
				tc.val(tc.val().replace(/(:\w*?:)/g, (m0, m1) => {
					const clean = m1.replace(/:/g, "");
					return d20plus.chat.emojiIndex && d20plus.chat.emojiIndex[clean] ? `[${clean}](https://github.com/TheGiddyLimit/emoji-dump/raw/master/out/${clean}.png)` : m1;
				}));
			}

			// add custom commands
			tc.val(tc.val().replace(/^\/ttms( |$)/, "/talktomyself$1"));

			const toSend = $.trim(tc.val());
			d20.textchat.doChatInput(toSend);
			tc.val("").focus();
		});
	};
};

SCRIPT_EXTENSIONS.push(betteR20Emoji);


function remoteLibre () {
	d20plus.remoteLibre = {
		getRemotePlaylists () {
			return fetch("https://api.github.com/repos/DMsGuild201/Roll20_resources/contents/playlist")
				.then(response => response.json())
				.then(data => {
					const promises = data.filter(file => file.download_url.toLowerCase().endsWith(".json"))
						.map(file => d20plus.remoteLibre.downloadPlaylist(file.download_url));
					return Promise.all(promises).then(res => d20plus.remoteLibre.processRemotePlaylists(res));
				})
				// eslint-disable-next-line no-console
				.catch(error => console.error(error));
		},

		downloadPlaylist (url) {
			return fetch(url)
				.then(response => response.json())
				// eslint-disable-next-line no-console
				.catch(error => console.error("Error when fetching", url, error));
		},

		processRemotePlaylists (imports) {
			return $.map(imports.filter(p => !!p), entry => {
				return $.map(entry.playlists, playlist => playlist.songs);
			}).filter(track => track.source === "My Audio");
		},

		drawRemoteLibreResults (tracks) {
			return tracks.map((t, i) => `
                <p style="margin-top:15px">${t.title}</p>
                <div class="br20-result" style="display: flex">
                    <audio class="audio" controls preload="none" style="flex: 35" src="${t.track_id}"></audio>

                    <button class="remote-track btn" data-id=${i} style="margin-top:auto;margin-bottom:auto;flex:1;font-size:15px;margin-left:10px;">
                        <span class="pictos">&amp;</span>
                    </button>
                </div>
            `);
		},

		drawJukeBoxTab (tracks) {
			const trackHtml = d20plus.remoteLibre.drawRemoteLibreResults(tracks);
			return `
            <div class="betteR20 tab-pane" style="display: none;">
                <div class="row-fluid">
                    <div class="span12">
                        <h3 style="margin-top: 6px; margin-bottom: 10px; text-align:initial;">Search for:</h3>
                        <input id="remoteLibreSearch" type="text" placeholder="Begin typing to choose tracks by title..." style="width: 100%;">
                        <div id="remoteLibreResults">
                            ${trackHtml.join("")}
                        </div>
                    </div>
                </div>
            </div>`;
		},

		wireTrackButtons () {
			$(".remote-track.btn").click((e) => {
				const id = $(e.currentTarget).data().id;
				d20plus.jukebox.createTrack(d20plus.remoteLibre.filteredResults[id]);
			});
		},

		init () {
			d20plus.remoteLibre.jukeboxInjected = false;
			d20plus.remoteLibre.remoteLibreTracks = {};
			d20plus.remoteLibre.filteredResults = {};

			d20plus.remoteLibre.getRemotePlaylists().then((tracks) => {
				d20plus.remoteLibre.remoteLibreTracks = tracks;
				d20plus.remoteLibre.filteredResults = tracks;
			});

			$("#addjukebox").click(() => {
				if (!d20plus.remoteLibre.jukeboxInjected) {
					setTimeout(() => {
						const html = d20plus.remoteLibre.drawJukeBoxTab(d20plus.remoteLibre.filteredResults);
						$(".nav.nav-tabs").append(`<li><a data-tab="betteR20" href="javascript:void(0);">BetteR20</a></li>`);
						$(".tab-content").append(html);
						d20plus.remoteLibre.wireTrackButtons();
						$("#remoteLibreSearch").bind("paste keyup", function () {
							if ($(this).val()) {
								d20plus.remoteLibre.filteredResults = d20plus.remoteLibre.remoteLibreTracks.filter(t => t.title.toLowerCase().indexOf($(this).val()) >= 0);
							} else {
								d20plus.remoteLibre.filteredResults = d20plus.remoteLibre.remoteLibreTracks;
							}
							const results = d20plus.remoteLibre.drawRemoteLibreResults(d20plus.remoteLibre.filteredResults);
							$("#remoteLibreResults").html(results);
							d20plus.remoteLibre.wireTrackButtons();
						});
						// this needs to be moved
						d20plus.remoteLibre.jukeboxInjected = true;
					}, 100);
				}
			});
		},

	};
}

SCRIPT_EXTENSIONS.push(remoteLibre);


function jukeboxWidget () {
	d20plus.jukeboxWidget = {
		getPlaylistButtonsHtml () {
			const buttons = d20plus.jukebox.getJukeboxFileStructure()
				.map((playlist, i) => {
					const hotkey = i + 1 < 10 ? i + 1 : false;
					let baseName, id;
					if (typeof playlist === "object") {
						baseName = playlist.n;
						id = playlist.id;
					} else {
						baseName = d20plus.jukebox.getTrackById(playlist).attributes.title;
						id = playlist;
					}
					const title = `${hotkey ? `[ALT+${hotkey}] ` : ""}${baseName}`;

					return `
						<div
							class="btn btn-xs jukebox-widget-button m-1"
							title="${title}"
							data-id=${id}
						>
							<span>${hotkey ? `[${i + 1}] ` : ""}${baseName}</span>
						</div>
					`;
				})
				.filter(p => !!p);

			return buttons.join("");
		},

		init () {
			const changeTrackVolume = (trackId, value) => {
				const track = d20plus.jukebox.getTrackById(trackId);
				if (track && value) {
					track.changeVolume(value);
				}
			};

			$(`<div id="masterVolume" style="margin:10px;display:inline-block;width:80%;"></div>`)
				.insertAfter("#jukeboxwhatsplaying").slider({
					slide: (e, ui) => {
						if ($("#masterVolumeEnabled").prop("checked")) {
							window.d20.jukebox.lastFolderStructure.forEach(playlist => {
							// The track is outside a playlist
								if (!playlist.i) {
									changeTrackVolume(playlist, ui.value);
								} else {
									playlist.i.forEach(trackId => changeTrackVolume(trackId, ui.value))
								}
							});
						}
						$("#jbwMasterVolume").slider("value", ui.value);
					},
					value: 50,
				});
			$("<h4>Master Volume</h4>").insertAfter("#jukeboxwhatsplaying").css("margin-left", "10px");
			$(`<input type="checkbox" id="masterVolumeEnabled" style="position:relative;top:-11px;" title="Enable this to change the volume of all the tracks at the same time"/>`).insertAfter("#masterVolume").tooltip();

			// TODO: Make the slider a separate component at some point
			const slider = $(`<div id="jbwMasterVolume" class="jukebox-widget-slider"></div>`)
				.slider({
					slide: (e, ui) => {
						if ($("#masterVolumeEnabled").prop("checked")) {
							window.d20.jukebox.lastFolderStructure.forEach(playlist => {
								// The track is outside a playlist
								if (!playlist.i) {
									changeTrackVolume(playlist, ui.value);
								} else {
									playlist.i.forEach(trackId => changeTrackVolume(trackId, ui.value));
								}
							});
						}
						$("#masterVolume").slider("value", ui.value);
					},
					value: 50,
				});

			// Stop and skip buttons
			const controls = $(`
			<div class="flex mb-2">
				<div id="jbwStop" title="ALT+S" class="btn btn-inverse flex-1 mr-2"><span class="pictos">6</span></div>
				<div id="jbwSkip" title="ALT+D" class="btn btn-inverse flex-1 mr-2"><span class="pictos">7</span></div>
			</div>
			`).append(slider);

			// Jukebox widget layout
			const dialog = $(`<div id="jukeboxWidget" title="Jukebox Player" style="margin-top:10px"></div>`)
				.dialog({
					autoOpen: false,
					resizable: true,
					width: 350,
				})
				.append("body")
				.css("padding-top", "0")
				.html(`<div id="jbwButtons" style="display:flex;flex-wrap:wrap">${d20plus.jukeboxWidget.getPlaylistButtonsHtml()}</div>`)
				.prepend(controls)
				.prepend(`<div id="widgeNowPlaying"></div>`);

			dialog.parent().find(".ui-dialog-title").css("margin", "0").css("padding", "0");
			$("#jbwStop").click(d20plus.jukebox.stopAll);
			$("#jbwSkip").click(d20plus.jukebox.skip);

			// Start listening to jukebox state changes
			d20plus.jukebox.addJukeboxChangeHandler(() => {
				$("#jbwButtons").html(d20plus.jukeboxWidget.getPlaylistButtonsHtml());
				$(".jukebox-widget-button")
					.removeClass("active")
					.click((e) => {
						const id = e.currentTarget.dataset.id;
						if (d20plus.jukebox.getCurrentPlayingPlaylist() === id || d20plus.jukebox.getCurrentPlayingTracks().find(t => t.id === id)) {
							d20plus.jukebox.stop(e.currentTarget.dataset.id);
						} else {
							d20plus.jukebox.play(e.currentTarget.dataset.id);
						}
					});
				$(`.jukebox-widget-button[data-id=${d20plus.jukebox.getCurrentPlayingPlaylist()}]`).addClass("active");
				d20plus.jukebox.getCurrentPlayingTracks().forEach(t => {
					$(`.jukebox-widget-button[data-id=${t.id}]`).addClass("active");
				});
			});

			// Add widget button in the Jukebox tab
			$(`<button class="btn" style="margin-right:10px;"><span class="pictos">|</span>Widget</button>`)
				.click(() => {
					dialog.dialog("open");
				})
				.insertAfter("[href=#superjukeboxadd]");

			// Add keyboard shortcuts
			$(document).keyup((e) => {
				if (e.altKey) {
					if (e.keyCode > 48 && e.keyCode < 58) {
						const numberKey = e.keyCode - 48;
						const playElement = d20plus.jukebox.getJukeboxFileStructure()[numberKey - 1];
						if (typeof playElement === "object") {
							if (d20plus.jukebox.getCurrentPlayingPlaylist() === playElement.id) {
								d20plus.jukebox.stopPlaylist(playElement.id);
							} else {
								d20plus.jukebox.playPlaylist(playElement.id);
							}
						} else {
							if (d20plus.jukebox.getCurrentPlayingTracks().find(t => t.id === playElement)) {
								d20plus.jukebox.stopTrack(playElement);
							} else {
								d20plus.jukebox.playTrack(playElement);
							}
						}
					} else if (e.keyCode === 83) {
						d20plus.jukebox.stopAll();
					} else if (e.keyCode === 68) {
						d20plus.jukebox.skip();
					}
				}
			});
		},
	};
}

SCRIPT_EXTENSIONS.push(jukeboxWidget);


const betteR20Core = function () {
	d20plus.Init = async () => {
		const scriptName = `betteR20-core v${d20plus.version}`;
		try {
			d20plus.ut.log(`Init (v${d20plus.version})`);
			d20plus.ut.showLoadingMessage(scriptName);
			d20plus.ut.checkVersion();
			d20plus.settingsHtmlHeader = `<hr><h3>betteR20-core v${d20plus.version}</h3>`;

			d20plus.template.swapTemplates();

			d20plus.ut.addAllCss();
			if (window.is_gm) d20plus.engine.enhancePageSelector();
			await d20plus.js.pAddScripts();
			await d20plus.qpi.pInitMockApi();
			await d20plus.js.pAddApiScripts();

			JqueryUtil.initEnhancements();

			if (window.is_gm) await d20plus.cfg.pLoadConfig();
			else await d20plus.cfg.pLoadPlayerConfig();

			if (window.is_gm) await d20plus.art.pLoadArt();

			d20plus.engine.enhanceMarkdown();
			d20plus.engine.addProFeatures();
			d20plus.engine.enhanceMouseDown();
			d20plus.engine.enhanceMouseMove();
			d20plus.engine.enhanceStatusEffects();
			d20plus.engine.addLineCutterTool();
			d20plus.ui.addHtmlHeader();
			d20plus.ui.addHtmlFooter();
			d20plus.art.initArtFromUrlButtons();
			if (window.is_gm) {
				d20plus.journal.addJournalCommands();
				d20plus.engine.addSelectedTokenCommands();
				d20plus.art.addCustomArtSearch();
				d20plus.engine.addTokenHover();
				d20plus.engine.enhanceTransmogrifier();
				d20plus.engine.removeLinkConfirmation();
				d20plus.artBrowse.initRepoBrowser();
				d20plus.ui.addQuickUiGm();
				d20plus.anim.animatorTool.init();
				// Better20 jukebox tab
				d20plus.remoteLibre.init();
				d20plus.jukeboxWidget.init();
			}
			d20plus.engine.enhancePathWidths();
			d20plus.ut.fix3dDice();
			d20plus.engine.addLayers();
			d20plus.weather.addWeather();
			d20plus.engine.repairPrototypeMethods();
			d20plus.engine.disableFrameRecorder();
			// d20plus.ut.fixSidebarLayout();
			d20plus.chat.enhanceChat();

			// apply config
			if (window.is_gm) {
				d20plus.cfg.baseHandleConfigChange();
			} else {
				d20plus.cfg.startPlayerConfigHandler();
			}

			d20plus.ut.log("All systems operational");
			d20plus.ut.chatTag(`betteR20-core v${d20plus.version}`);
		} catch (e) {
			// eslint-disable-next-line no-console
			console.error(e);
			alert(`${scriptName} failed to initialise! See the logs (CTRL-SHIFT-J) for more information.`)
		}
	};
};

SCRIPT_EXTENSIONS.push(betteR20Core);


if (unsafeWindow.d20plus) {
	unsafeWindow.eval(`alert("An instance of betteR20 is already running! You may have two versions of betteR20 installed (e.g core and 5etools). Please only use one.");`);
	unsafeWindow.eval(`alert("Your game may not launch. Please only run one instance of betteR20.");`);
	throw new Error("");
}

unsafeWindow.d20plus = {};

const betteR20Base = function () {
	/* eslint-disable */
	CONSOLE_LOG = console.log;
	console.log = (...args) => {
		if (args.length === 1 && typeof args[0] === "string" && args[0].startsWith("Switch mode to ")) {
			const mode = args[0].replace("Switch mode to ", "");
			if (typeof d20plus !== "undefined" && d20plus.setMode) d20plus.setMode(mode);
		}
		CONSOLE_LOG(...args);
	};
	/* eslint-enable */

	addConfigOptions("token", {
		"_name": "Tokens",
		"massRollWhisperName": {
			"name": "Whisper Token Name to Mass-Rolls",
			"default": false,
			"_type": "boolean",
		},
	},
	);
	addConfigOptions("canvas", {
		"_name": "Canvas",
		"_player": true,
		"gridSnap": {
			"name": "Grid Snap",
			"default": "1",
			"_type": "_enum",
			"__values": ["0.25", "0.5", "1"],
			"_player": true,
		},
		"scaleNamesStatuses": {
			"name": "Scaled Names and Status Icons",
			"default": true,
			"_type": "boolean",
			"_player": true,
		},
	},
	);
	addConfigOptions("import", {
		"_name": "Import",
		"importIntervalMap": {
			"name": "Rest Time between Each Map (msec)",
			"default": 2500,
			"_type": "integer",
		},
	});
	addConfigOptions("interface", {
		"_name": "Interface",
		"toolbarOpacity": {
			"name": "Horizontal Toolbar Opacity",
			"default": 100,
			"_type": "_slider",
			"__sliderMin": 1,
			"__sliderMax": 100,
			"__sliderStep": 1,
		},
		"quickLayerButtons": {
			"name": "Add Quick Layer Buttons",
			"default": true,
			"_type": "boolean",
		},
		"quickInitButtons": {
			"name": "Add Quick Initiative Sort Button",
			"default": true,
			"_type": "boolean",
		},
		"streamerChatTag": {
			"name": "Streamer-Friendly Chat Tags",
			"default": false,
			"_type": "boolean",
		},
		"hideDefaultJournalSearch": {
			"name": "Hide Default Journal Search Bar",
			"default": false,
			"_type": "boolean",
		},
	});
};

const D20plus = function (version) {
	d20plus.version = version;

	// Window loaded
	function doBootstrap () {
		d20plus.ut.log("Waiting for enhancement suite...");

		let timeWaitedForEnhancementSuiteMs = 0;

		(function waitForEnhancementSuite () {
			let hasRunInit = false;
			if (window.d20 || window.enhancementSuiteEnabled) {
				d20plus.ut.log("Bootstrapping...");

				// r20es will expose the d20 variable if we wait
				// this should always trigger after window.onload has fired, but track init state just in case
				(function waitForD20 () {
					if (typeof window.d20 !== "undefined" && !$("#loading-overlay").is(":visible") && !hasRunInit) {
						hasRunInit = true;
						d20plus.Init();
					} else {
						setTimeout(waitForD20, 50);
					}
				})();

				window.d20plus = d20plus;
				d20plus.ut.log("Injected");
			} else {
				if (timeWaitedForEnhancementSuiteMs > 2 * 5000) {
					alert("betteR20 requires the VTTES (R20ES) extension to be installed!\nPlease install it from https://ssstormy.github.io/roll20-enhancement-suite/\nClicking ok will take you there.");
					window.open("https://ssstormy.github.io/roll20-enhancement-suite/", "_blank");
				} else {
					timeWaitedForEnhancementSuiteMs += 100;
					setTimeout(waitForEnhancementSuite, 100);
				}
			}
		})();
	}

	(function doCheckDepsLoaded () {
		if (typeof $ !== "undefined") {
			doBootstrap();
		} else {
			setTimeout(doCheckDepsLoaded, 50);
		}
	})();
};

// if we are the topmost frame, inject
if (window.top === window.self) {
	const strip = (str) => {
		return `${str.replace(/use strict/, "").substring(str.indexOf("\n") + 1, str.lastIndexOf("\n"))}\n`;
	};

	let stack = "function (version) {\n";
	stack += strip(betteR20Base.toString());

	for (let i = 0; i < SCRIPT_EXTENSIONS.length; ++i) {
		stack += strip(SCRIPT_EXTENSIONS[i].toString())
	}
	stack += strip(D20plus.toString());

	stack += "\n}";
	unsafeWindow.eval(`(${stack})('${GM_info.script.version}')`);
}



EXT_LIB_SCRIPTS.push((function lib_script_0 () {
/*! List.js v1.5.0 (http://listjs.com) by Jonny Strömberg (http://javve.com) */
var List=function(t){function e(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var r={};return e.m=t,e.c=r,e.i=function(t){return t},e.d=function(t,r,n){e.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:n})},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=11)}([function(t,e,r){function n(t){if(!t||!t.nodeType)throw new Error("A DOM element reference is required");this.el=t,this.list=t.classList}var i=r(4),s=/\s+/;Object.prototype.toString;t.exports=function(t){return new n(t)},n.prototype.add=function(t){if(this.list)return this.list.add(t),this;var e=this.array(),r=i(e,t);return~r||e.push(t),this.el.className=e.join(" "),this},n.prototype.remove=function(t){if(this.list)return this.list.remove(t),this;var e=this.array(),r=i(e,t);return~r&&e.splice(r,1),this.el.className=e.join(" "),this},n.prototype.toggle=function(t,e){return this.list?("undefined"!=typeof e?e!==this.list.toggle(t,e)&&this.list.toggle(t):this.list.toggle(t),this):("undefined"!=typeof e?e?this.add(t):this.remove(t):this.has(t)?this.remove(t):this.add(t),this)},n.prototype.array=function(){var t=this.el.getAttribute("class")||"",e=t.replace(/^\s+|\s+$/g,""),r=e.split(s);return""===r[0]&&r.shift(),r},n.prototype.has=n.prototype.contains=function(t){return this.list?this.list.contains(t):!!~i(this.array(),t)}},function(t,e,r){var n=window.addEventListener?"addEventListener":"attachEvent",i=window.removeEventListener?"removeEventListener":"detachEvent",s="addEventListener"!==n?"on":"",a=r(5);e.bind=function(t,e,r,i){t=a(t);for(var o=0;o<t.length;o++)t[o][n](s+e,r,i||!1)},e.unbind=function(t,e,r,n){t=a(t);for(var o=0;o<t.length;o++)t[o][i](s+e,r,n||!1)}},function(t,e){t.exports=function(t){return function(e,r,n){var i=this;this._values={},this.found=!1,this.filtered=!1;var s=function(e,r,n){if(void 0===r)n?i.values(e,n):i.values(e);else{i.elm=r;var s=t.templater.get(i,e);i.values(s)}};this.values=function(e,r){if(void 0===e)return i._values;for(var n in e)i._values[n]=e[n];r!==!0&&t.templater.set(i,i.values())},this.show=function(){t.templater.show(i)},this.hide=function(){t.templater.hide(i)},this.matching=function(){return t.filtered&&t.searched&&i.found&&i.filtered||t.filtered&&!t.searched&&i.filtered||!t.filtered&&t.searched&&i.found||!t.filtered&&!t.searched},this.visible=function(){return!(!i.elm||i.elm.parentNode!=t.list)},s(e,r,n)}}},function(t,e){var r=function(t,e,r){return r?t.getElementsByClassName(e)[0]:t.getElementsByClassName(e)},n=function(t,e,r){return e="."+e,r?t.querySelector(e):t.querySelectorAll(e)},i=function(t,e,r){for(var n=[],i="*",s=t.getElementsByTagName(i),a=s.length,o=new RegExp("(^|\\s)"+e+"(\\s|$)"),l=0,u=0;l<a;l++)if(o.test(s[l].className)){if(r)return s[l];n[u]=s[l],u++}return n};t.exports=function(){return function(t,e,s,a){return a=a||{},a.test&&a.getElementsByClassName||!a.test&&document.getElementsByClassName?r(t,e,s):a.test&&a.querySelector||!a.test&&document.querySelector?n(t,e,s):i(t,e,s)}}()},function(t,e){var r=[].indexOf;t.exports=function(t,e){if(r)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1}},function(t,e){function r(t){return"[object Array]"===Object.prototype.toString.call(t)}t.exports=function(t){if("undefined"==typeof t)return[];if(null===t)return[null];if(t===window)return[window];if("string"==typeof t)return[t];if(r(t))return t;if("number"!=typeof t.length)return[t];if("function"==typeof t&&t instanceof Function)return[t];for(var e=[],n=0;n<t.length;n++)(Object.prototype.hasOwnProperty.call(t,n)||n in t)&&e.push(t[n]);return e.length?e:[]}},function(t,e){t.exports=function(t){return t=void 0===t?"":t,t=null===t?"":t,t=t.toString()}},function(t,e){t.exports=function(t){for(var e,r=Array.prototype.slice.call(arguments,1),n=0;e=r[n];n++)if(e)for(var i in e)t[i]=e[i];return t}},function(t,e){t.exports=function(t){var e=function(r,n,i){var s=r.splice(0,50);i=i||[],i=i.concat(t.add(s)),r.length>0?setTimeout(function(){e(r,n,i)},1):(t.update(),n(i))};return e}},function(t,e){t.exports=function(t){return t.handlers.filterStart=t.handlers.filterStart||[],t.handlers.filterComplete=t.handlers.filterComplete||[],function(e){if(t.trigger("filterStart"),t.i=1,t.reset.filter(),void 0===e)t.filtered=!1;else{t.filtered=!0;for(var r=t.items,n=0,i=r.length;n<i;n++){var s=r[n];e(s)?s.filtered=!0:s.filtered=!1}}return t.update(),t.trigger("filterComplete"),t.visibleItems}}},function(t,e,r){var n=(r(0),r(1)),i=r(7),s=r(6),a=r(3),o=r(19);t.exports=function(t,e){e=e||{},e=i({location:0,distance:100,threshold:.4,multiSearch:!0,searchClass:"fuzzy-search"},e);var r={search:function(n,i){for(var s=e.multiSearch?n.replace(/ +$/,"").split(/ +/):[n],a=0,o=t.items.length;a<o;a++)r.item(t.items[a],i,s)},item:function(t,e,n){for(var i=!0,s=0;s<n.length;s++){for(var a=!1,o=0,l=e.length;o<l;o++)r.values(t.values(),e[o],n[s])&&(a=!0);a||(i=!1)}t.found=i},values:function(t,r,n){if(t.hasOwnProperty(r)){var i=s(t[r]).toLowerCase();if(o(i,n,e))return!0}return!1}};return n.bind(a(t.listContainer,e.searchClass),"keyup",function(e){var n=e.target||e.srcElement;t.search(n.value,r.search)}),function(e,n){t.search(e,n,r.search)}}},function(t,e,r){var n=r(18),i=r(3),s=r(7),a=r(4),o=r(1),l=r(6),u=r(0),c=r(17),f=r(5);t.exports=function(t,e,h){var d,v=this,m=r(2)(v),g=r(8)(v),p=r(12)(v);d={start:function(){v.listClass="list",v.searchClass="search",v.sortClass="sort",v.page=1e4,v.i=1,v.items=[],v.visibleItems=[],v.matchingItems=[],v.searched=!1,v.filtered=!1,v.searchColumns=void 0,v.handlers={updated:[]},v.valueNames=[],v.utils={getByClass:i,extend:s,indexOf:a,events:o,toString:l,naturalSort:n,classes:u,getAttribute:c,toArray:f},v.utils.extend(v,e),v.listContainer="string"==typeof t?document.getElementById(t):t,v.listContainer&&(v.list=i(v.listContainer,v.listClass,!0),v.parse=r(13)(v),v.templater=r(16)(v),v.search=r(14)(v),v.filter=r(9)(v),v.sort=r(15)(v),v.fuzzySearch=r(10)(v,e.fuzzySearch),this.handlers(),this.items(),this.pagination(),v.update())},handlers:function(){for(var t in v.handlers)v[t]&&v.on(t,v[t])},items:function(){v.parse(v.list),void 0!==h&&v.add(h)},pagination:function(){if(void 0!==e.pagination){e.pagination===!0&&(e.pagination=[{}]),void 0===e.pagination[0]&&(e.pagination=[e.pagination]);for(var t=0,r=e.pagination.length;t<r;t++)p(e.pagination[t])}}},this.reIndex=function(){v.items=[],v.visibleItems=[],v.matchingItems=[],v.searched=!1,v.filtered=!1,v.parse(v.list)},this.toJSON=function(){for(var t=[],e=0,r=v.items.length;e<r;e++)t.push(v.items[e].values());return t},this.add=function(t,e){if(0!==t.length){if(e)return void g(t,e);var r=[],n=!1;void 0===t[0]&&(t=[t]);for(var i=0,s=t.length;i<s;i++){var a=null;n=v.items.length>v.page,a=new m(t[i],void 0,n),v.items.push(a),r.push(a)}return v.update(),r}},this.show=function(t,e){return this.i=t,this.page=e,v.update(),v},this.remove=function(t,e,r){for(var n=0,i=0,s=v.items.length;i<s;i++)v.items[i].values()[t]==e&&(v.templater.remove(v.items[i],r),v.items.splice(i,1),s--,i--,n++);return v.update(),n},this.get=function(t,e){for(var r=[],n=0,i=v.items.length;n<i;n++){var s=v.items[n];s.values()[t]==e&&r.push(s)}return r},this.size=function(){return v.items.length},this.clear=function(){return v.templater.clear(),v.items=[],v},this.on=function(t,e){return v.handlers[t].push(e),v},this.off=function(t,e){var r=v.handlers[t],n=a(r,e);return n>-1&&r.splice(n,1),v},this.trigger=function(t){for(var e=v.handlers[t].length;e--;)v.handlers[t][e](v);return v},this.reset={filter:function(){for(var t=v.items,e=t.length;e--;)t[e].filtered=!1;return v},search:function(){for(var t=v.items,e=t.length;e--;)t[e].found=!1;return v}},this.update=function(){var t=v.items,e=t.length;v.visibleItems=[],v.matchingItems=[],v.templater.clear();for(var r=0;r<e;r++)t[r].matching()&&v.matchingItems.length+1>=v.i&&v.visibleItems.length<v.page?(t[r].show(),v.visibleItems.push(t[r]),v.matchingItems.push(t[r])):t[r].matching()?(v.matchingItems.push(t[r]),t[r].hide()):t[r].hide();return v.trigger("updated"),v},d.start()}},function(t,e,r){var n=r(0),i=r(1),s=r(11);t.exports=function(t){var e=function(e,i){var s,o=t.matchingItems.length,l=t.i,u=t.page,c=Math.ceil(o/u),f=Math.ceil(l/u),h=i.innerWindow||2,d=i.left||i.outerWindow||0,v=i.right||i.outerWindow||0;v=c-v,e.clear();for(var m=1;m<=c;m++){var g=f===m?"active":"";r.number(m,d,v,f,h)?(s=e.add({page:m,dotted:!1})[0],g&&n(s.elm).add(g),a(s.elm,m,u)):r.dotted(e,m,d,v,f,h,e.size())&&(s=e.add({page:"...",dotted:!0})[0],n(s.elm).add("disabled"))}},r={number:function(t,e,r,n,i){return this.left(t,e)||this.right(t,r)||this.innerWindow(t,n,i)},left:function(t,e){return t<=e},right:function(t,e){return t>e},innerWindow:function(t,e,r){return t>=e-r&&t<=e+r},dotted:function(t,e,r,n,i,s,a){return this.dottedLeft(t,e,r,n,i,s)||this.dottedRight(t,e,r,n,i,s,a)},dottedLeft:function(t,e,r,n,i,s){return e==r+1&&!this.innerWindow(e,i,s)&&!this.right(e,n)},dottedRight:function(t,e,r,n,i,s,a){return!t.items[a-1].values().dotted&&(e==n&&!this.innerWindow(e,i,s)&&!this.right(e,n))}},a=function(e,r,n){i.bind(e,"click",function(){t.show((r-1)*n+1,n)})};return function(r){var n=new s(t.listContainer.id,{listClass:r.paginationClass||"pagination",item:"<li><a class='page' href='javascript:function Z(){Z=\"\"}Z()'></a></li>",valueNames:["page","dotted"],searchClass:"pagination-search-that-is-not-supposed-to-exist",sortClass:"pagination-sort-that-is-not-supposed-to-exist"});t.on("updated",function(){e(n,r)}),e(n,r)}}},function(t,e,r){t.exports=function(t){var e=r(2)(t),n=function(t){for(var e=t.childNodes,r=[],n=0,i=e.length;n<i;n++)void 0===e[n].data&&r.push(e[n]);return r},i=function(r,n){for(var i=0,s=r.length;i<s;i++)t.items.push(new e(n,r[i]))},s=function(e,r){var n=e.splice(0,50);i(n,r),e.length>0?setTimeout(function(){s(e,r)},1):(t.update(),t.trigger("parseComplete"))};return t.handlers.parseComplete=t.handlers.parseComplete||[],function(){var e=n(t.list),r=t.valueNames;t.indexAsync?s(e,r):i(e,r)}}},function(t,e){t.exports=function(t){var e,r,n,i,s={resetList:function(){t.i=1,t.templater.clear(),i=void 0},setOptions:function(t){2==t.length&&t[1]instanceof Array?r=t[1]:2==t.length&&"function"==typeof t[1]?(r=void 0,i=t[1]):3==t.length?(r=t[1],i=t[2]):r=void 0},setColumns:function(){0!==t.items.length&&void 0===r&&(r=void 0===t.searchColumns?s.toArray(t.items[0].values()):t.searchColumns)},setSearchString:function(e){e=t.utils.toString(e).toLowerCase(),e=e.replace(/[-[\]{}()*+?.,\\^$|#]/g,"\\$&"),n=e},toArray:function(t){var e=[];for(var r in t)e.push(r);return e}},a={list:function(){for(var e=0,r=t.items.length;e<r;e++)a.item(t.items[e])},item:function(t){t.found=!1;for(var e=0,n=r.length;e<n;e++)if(a.values(t.values(),r[e]))return void(t.found=!0)},values:function(r,i){return!!(r.hasOwnProperty(i)&&(e=t.utils.toString(r[i]).toLowerCase(),""!==n&&e.search(n)>-1))},reset:function(){t.reset.search(),t.searched=!1}},o=function(e){return t.trigger("searchStart"),s.resetList(),s.setSearchString(e),s.setOptions(arguments),s.setColumns(),""===n?a.reset():(t.searched=!0,i?i(n,r):a.list()),t.update(),t.trigger("searchComplete"),t.visibleItems};return t.handlers.searchStart=t.handlers.searchStart||[],t.handlers.searchComplete=t.handlers.searchComplete||[],t.utils.events.bind(t.utils.getByClass(t.listContainer,t.searchClass),"keyup",function(e){var r=e.target||e.srcElement,n=""===r.value&&!t.searched;n||o(r.value)}),t.utils.events.bind(t.utils.getByClass(t.listContainer,t.searchClass),"input",function(t){var e=t.target||t.srcElement;""===e.value&&o("")}),o}},function(t,e){t.exports=function(t){var e={els:void 0,clear:function(){for(var r=0,n=e.els.length;r<n;r++)t.utils.classes(e.els[r]).remove("asc"),t.utils.classes(e.els[r]).remove("desc")},getOrder:function(e){var r=t.utils.getAttribute(e,"data-order");return"asc"==r||"desc"==r?r:t.utils.classes(e).has("desc")?"asc":t.utils.classes(e).has("asc")?"desc":"asc"},getInSensitive:function(e,r){var n=t.utils.getAttribute(e,"data-insensitive");"false"===n?r.insensitive=!1:r.insensitive=!0},setOrder:function(r){for(var n=0,i=e.els.length;n<i;n++){var s=e.els[n];if(t.utils.getAttribute(s,"data-sort")===r.valueName){var a=t.utils.getAttribute(s,"data-order");"asc"==a||"desc"==a?a==r.order&&t.utils.classes(s).add(r.order):t.utils.classes(s).add(r.order)}}}},r=function(){t.trigger("sortStart");var r={},n=arguments[0].currentTarget||arguments[0].srcElement||void 0;n?(r.valueName=t.utils.getAttribute(n,"data-sort"),e.getInSensitive(n,r),r.order=e.getOrder(n)):(r=arguments[1]||r,r.valueName=arguments[0],r.order=r.order||"asc",r.insensitive="undefined"==typeof r.insensitive||r.insensitive),e.clear(),e.setOrder(r);var i,s=r.sortFunction||t.sortFunction||null,a="desc"===r.order?-1:1;i=s?function(t,e){return s(t,e,r)*a}:function(e,n){var i=t.utils.naturalSort;return i.alphabet=t.alphabet||r.alphabet||void 0,!i.alphabet&&r.insensitive&&(i=t.utils.naturalSort.caseInsensitive),i(e.values()[r.valueName],n.values()[r.valueName])*a},t.items.sort(i),t.update(),t.trigger("sortComplete")};return t.handlers.sortStart=t.handlers.sortStart||[],t.handlers.sortComplete=t.handlers.sortComplete||[],e.els=t.utils.getByClass(t.listContainer,t.sortClass),t.utils.events.bind(e.els,"click",r),t.on("searchStart",e.clear),t.on("filterStart",e.clear),r}},function(t,e){var r=function(t){var e,r=this,n=function(){e=r.getItemSource(t.item),e&&(e=r.clearSourceItem(e,t.valueNames))};this.clearSourceItem=function(e,r){for(var n=0,i=r.length;n<i;n++){var s;if(r[n].data)for(var a=0,o=r[n].data.length;a<o;a++)e.setAttribute("data-"+r[n].data[a],"");else r[n].attr&&r[n].name?(s=t.utils.getByClass(e,r[n].name,!0),s&&s.setAttribute(r[n].attr,"")):(s=t.utils.getByClass(e,r[n],!0),s&&(s.innerHTML=""));s=void 0}return e},this.getItemSource=function(e){if(void 0===e){for(var r=t.list.childNodes,n=0,i=r.length;n<i;n++)if(void 0===r[n].data)return r[n].cloneNode(!0)}else{if(/<tr[\s>]/g.exec(e)){var s=document.createElement("tbody");return s.innerHTML=e,s.firstChild}if(e.indexOf("<")!==-1){var a=document.createElement("div");return a.innerHTML=e,a.firstChild}var o=document.getElementById(t.item);if(o)return o}},this.get=function(e,n){r.create(e);for(var i={},s=0,a=n.length;s<a;s++){var o;if(n[s].data)for(var l=0,u=n[s].data.length;l<u;l++)i[n[s].data[l]]=t.utils.getAttribute(e.elm,"data-"+n[s].data[l]);else n[s].attr&&n[s].name?(o=t.utils.getByClass(e.elm,n[s].name,!0),i[n[s].name]=o?t.utils.getAttribute(o,n[s].attr):""):(o=t.utils.getByClass(e.elm,n[s],!0),i[n[s]]=o?o.innerHTML:"");o=void 0}return i},this.set=function(e,n){var i=function(e){for(var r=0,n=t.valueNames.length;r<n;r++)if(t.valueNames[r].data){for(var i=t.valueNames[r].data,s=0,a=i.length;s<a;s++)if(i[s]===e)return{data:e}}else{if(t.valueNames[r].attr&&t.valueNames[r].name&&t.valueNames[r].name==e)return t.valueNames[r];if(t.valueNames[r]===e)return e}},s=function(r,n){var s,a=i(r);a&&(a.data?e.elm.setAttribute("data-"+a.data,n):a.attr&&a.name?(s=t.utils.getByClass(e.elm,a.name,!0),s&&s.setAttribute(a.attr,n)):(s=t.utils.getByClass(e.elm,a,!0),s&&(s.innerHTML=n)),s=void 0)};if(!r.create(e))for(var a in n)n.hasOwnProperty(a)&&s(a,n[a])},this.create=function(t){if(void 0!==t.elm)return!1;if(void 0===e)throw new Error("The list need to have at list one item on init otherwise you'll have to add a template.");var n=e.cloneNode(!0);return n.removeAttribute("id"),t.elm=n,r.set(t,t.values()),!0},this.remove=function(e){e.elm.parentNode===t.list&&t.list.removeChild(e.elm)},this.show=function(e){r.create(e),t.list.appendChild(e.elm)},this.hide=function(e){void 0!==e.elm&&e.elm.parentNode===t.list&&t.list.removeChild(e.elm)},this.clear=function(){if(t.list.hasChildNodes())for(;t.list.childNodes.length>=1;)t.list.removeChild(t.list.firstChild)},n()};t.exports=function(t){return new r(t)}},function(t,e){t.exports=function(t,e){var r=t.getAttribute&&t.getAttribute(e)||null;if(!r)for(var n=t.attributes,i=n.length,s=0;s<i;s++)void 0!==e[s]&&e[s].nodeName===e&&(r=e[s].nodeValue);return r}},function(t,e,r){"use strict";function n(t){return t>=48&&t<=57}function i(t,e){for(var r=(t+="").length,i=(e+="").length,s=0,l=0;s<r&&l<i;){var u=t.charCodeAt(s),c=e.charCodeAt(l);if(n(u)){if(!n(c))return u-c;for(var f=s,h=l;48===u&&++f<r;)u=t.charCodeAt(f);for(;48===c&&++h<i;)c=e.charCodeAt(h);for(var d=f,v=h;d<r&&n(t.charCodeAt(d));)++d;for(;v<i&&n(e.charCodeAt(v));)++v;var m=d-f-v+h;if(m)return m;for(;f<d;)if(m=t.charCodeAt(f++)-e.charCodeAt(h++))return m;s=d,l=v}else{if(u!==c)return u<o&&c<o&&a[u]!==-1&&a[c]!==-1?a[u]-a[c]:u-c;++s,++l}}return r-i}var s,a,o=0;i.caseInsensitive=i.i=function(t,e){return i((""+t).toLowerCase(),(""+e).toLowerCase())},Object.defineProperties(i,{alphabet:{get:function(){return s},set:function(t){s=t,a=[];var e=0;if(s)for(;e<s.length;e++)a[s.charCodeAt(e)]=e;for(o=a.length,e=0;e<o;e++)void 0===a[e]&&(a[e]=-1)}}}),t.exports=i},function(t,e){t.exports=function(t,e,r){function n(t,r){var n=t/e.length,i=Math.abs(o-r);return s?n+i/s:i?1:n}var i=r.location||0,s=r.distance||100,a=r.threshold||.4;if(e===t)return!0;if(e.length>32)return!1;var o=i,l=function(){var t,r={};for(t=0;t<e.length;t++)r[e.charAt(t)]=0;for(t=0;t<e.length;t++)r[e.charAt(t)]|=1<<e.length-t-1;return r}(),u=a,c=t.indexOf(e,o);c!=-1&&(u=Math.min(n(0,c),u),c=t.lastIndexOf(e,o+e.length),c!=-1&&(u=Math.min(n(0,c),u)));var f=1<<e.length-1;c=-1;for(var h,d,v,m=e.length+t.length,g=0;g<e.length;g++){for(h=0,d=m;h<d;)n(g,o+d)<=u?h=d:m=d,d=Math.floor((m-h)/2+h);m=d;var p=Math.max(1,o-d+1),C=Math.min(o+d,t.length)+e.length,y=Array(C+2);y[C+1]=(1<<g)-1;for(var b=C;b>=p;b--){var w=l[t.charAt(b-1)];if(0===g?y[b]=(y[b+1]<<1|1)&w:y[b]=(y[b+1]<<1|1)&w|((v[b+1]|v[b])<<1|1)|v[b+1],y[b]&f){var x=n(g,b-1);if(x<=u){if(u=x,c=b-1,!(c>o))break;p=Math.max(1,2*o-c)}}}if(n(g+1,o)>u)break;v=y}return!(c<0)}}]);
}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_1 () {
/*!

JSZip v3.3.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).JSZip=t()}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e="function"==typeof require&&require;if(!t&&e)return e(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l="function"==typeof require&&require,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/DataLengthProbe"),a=t("./stream/Crc32Probe");s=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new s("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new a).pipe(new s("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new s("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.4.0",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=(i=t("./utils"),t("./zipEntries")),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)this.files.hasOwnProperty(e)&&(i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i))},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i}},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});
}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_2 () {
/*!
    localForage -- Offline Storage, Improved
    Version 1.7.3
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.localforage=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c||a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(a){c.status="error",c.value=a}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){g(c,this.state===r?a:b,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2))}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!ua)return!1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return!1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c="undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder,d=new c,e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c)}function j(a){return"string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(){if(arguments.length&&"function"==typeof arguments[arguments.length-1])return arguments[arguments.length-1]}function l(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function m(a){return new va(function(b){var c=a.transaction(wa,Ba),d=g([""]);c.objectStore(wa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1)},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43)}}).catch(function(){return!1})}function n(a){return"boolean"==typeof xa?va.resolve(xa):m(a).then(function(a){return xa=a})}function o(a){var b=ya[a.name],c={};c.promise=new va(function(a,b){c.resolve=a,c.reject=b}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise}function p(a){var b=ya[a.name],c=b.deferredOperations.pop();if(c)return c.resolve(),c.promise}function q(a,b){var c=ya[a.name],d=c.deferredOperations.pop();if(d)return d.reject(b),d.promise}function r(a,b){return new va(function(c,d){if(ya[a.name]=ya[a.name]||B(),a.db){if(!b)return c(a.db);o(a),a.db.close()}var e=[a.name];b&&e.push(a.version);var f=ua.open.apply(ua,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(wa)}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.')}}),f.onerror=function(a){a.preventDefault(),d(f.error)},f.onsuccess=function(){c(f.result),p(a)}})}function s(a){return r(a,!1)}function t(a){return r(a,!0)}function u(a,b){if(!a.db)return!0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f)}return!0}return!1}function v(a){return new va(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type})},d.readAsBinaryString(a)})}function w(a){return g([l(atob(a.data))],{type:a.type})}function x(a){return a&&a.__local_forage_encoded_blob}function y(a){var b=this,c=b._initReady().then(function(){var a=ya[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function z(a){o(a);for(var b=ya[a.name],c=b.forages,d=0;d<c.length;d++){var e=c[d];e._dbInfo.db&&(e._dbInfo.db.close(),e._dbInfo.db=null)}return a.db=null,s(a).then(function(b){return a.db=b,u(a)?t(a):b}).then(function(d){a.db=b.db=d;for(var e=0;e<c.length;e++)c[e]._dbInfo.db=d}).catch(function(b){throw q(a,b),b})}function A(a,b,c,d){void 0===d&&(d=1);try{var e=a.db.transaction(a.storeName,b);c(null,e)}catch(e){if(d>0&&(!a.db||"InvalidStateError"===e.name||"NotFoundError"===e.name))return va.resolve().then(function(){if(!a.db||"NotFoundError"===e.name&&!a.db.objectStoreNames.contains(a.storeName)&&a.version<=a.db.version)return a.db&&(a.version=a.db.version+1),t(a)}).then(function(){return z(a).then(function(){A(a,b,c,d-1)})}).catch(c);c(e)}}function B(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function C(a){function b(){return va.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];var f=ya[d.name];f||(f=B(),ya[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=y);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b))}var j=f.forages.slice(0);return va.all(g).then(function(){return d.db=f.db,s(d)}).then(function(a){return d.db=a,u(d,c._defaultConfig.version)?t(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version)}})}function D(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),x(a)&&(a=w(a)),b(a)},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function E(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;x(d)&&(d=w(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue()}else b()},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function F(a,b,c){var d=this;a=j(a);var e=new va(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===za.call(b)?n(f.db).then(function(a){return a?b:v(b)}):b}).then(function(b){A(d._dbInfo,Ba,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a)}}catch(a){e(a)}})}).catch(e)});return h(e,c),e}function G(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Ba,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=g.delete(a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function H(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Ba,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function I(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.count();g.onsuccess=function(){a(g.result)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function J(a,b){var c=this,d=new va(function(b,d){if(a<0)return void b(null);c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openCursor();i.onsuccess=function(){var c=i.result;if(!c)return void b(null);0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a))},i.onerror=function(){d(i.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function K(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f=e.objectStore(b._dbInfo.storeName),g=f.openCursor(),h=[];g.onsuccess=function(){var b=g.result;if(!b)return void a(h);h.push(b.key),b.continue()},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function L(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;if(a.name){var f=a.name===c.name&&e._dbInfo.db,g=f?va.resolve(e._dbInfo.db):s(a).then(function(b){var c=ya[a.name],d=c.forages;c.db=b;for(var e=0;e<d.length;e++)d[e]._dbInfo.db=b;return b});d=a.storeName?g.then(function(b){if(b.objectStoreNames.contains(a.storeName)){var c=b.version+1;o(a);var d=ya[a.name],e=d.forages;b.close();for(var f=0;f<e.length;f++){var g=e[f];g._dbInfo.db=null,g._dbInfo.version=c}return new va(function(b,d){var e=ua.open(a.name,c);e.onerror=function(a){e.result.close(),d(a)},e.onupgradeneeded=function(){e.result.deleteObjectStore(a.storeName)},e.onsuccess=function(){var a=e.result;a.close(),b(a)}}).then(function(a){d.db=a;for(var b=0;b<e.length;b++){var c=e[b];c._dbInfo.db=a,p(c._dbInfo)}}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})}}):g.then(function(b){o(a);var c=ya[a.name],d=c.forages;b.close();for(var e=0;e<d.length;e++){d[e]._dbInfo.db=null}return new va(function(b,c){var d=ua.deleteDatabase(a.name);d.onerror=d.onblocked=function(a){var b=d.result;b&&b.close(),c(a)},d.onsuccess=function(){var a=d.result;a&&a.close(),b(a)}}).then(function(a){c.db=a;for(var b=0;b<d.length;b++)p(d[b]._dbInfo)}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})})}else d=va.reject("Invalid arguments");return h(d,b),d}function M(){return"function"==typeof openDatabase}function N(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=Da.indexOf(a[b]),d=Da.indexOf(a[b+1]),e=Da.indexOf(a[b+2]),f=Da.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function O(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=Da[c[b]>>2],d+=Da[(3&c[b])<<4|c[b+1]>>4],d+=Da[(15&c[b+1])<<2|c[b+2]>>6],d+=Da[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function P(a,b){var c="";if(a&&(c=Ua.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===Ua.call(a.buffer))){var d,e=Ga;a instanceof ArrayBuffer?(d=a,e+=Ia):(d=a.buffer,"[object Int8Array]"===c?e+=Ka:"[object Uint8Array]"===c?e+=La:"[object Uint8ClampedArray]"===c?e+=Ma:"[object Int16Array]"===c?e+=Na:"[object Uint16Array]"===c?e+=Pa:"[object Int32Array]"===c?e+=Oa:"[object Uint32Array]"===c?e+=Qa:"[object Float32Array]"===c?e+=Ra:"[object Float64Array]"===c?e+=Sa:b(new Error("Failed to get type for BinaryArray"))),b(e+O(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=Ea+a.type+"~"+O(this.result);b(Ga+Ja+c)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c)}}function Q(a){if(a.substring(0,Ha)!==Ga)return JSON.parse(a);var b,c=a.substring(Ta),d=a.substring(Ha,Ta);if(d===Ja&&Fa.test(c)){var e=c.match(Fa);b=e[1],c=c.substring(e[0].length)}var f=N(c);switch(d){case Ia:return f;case Ja:return g([f],{type:b});case Ka:return new Int8Array(f);case La:return new Uint8Array(f);case Ma:return new Uint8ClampedArray(f);case Na:return new Int16Array(f);case Pa:return new Uint16Array(f);case Oa:return new Int32Array(f);case Qa:return new Uint32Array(f);case Ra:return new Float32Array(f);case Sa:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function R(a,b,c,d){a.executeSql("CREATE TABLE IF NOT EXISTS "+b.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],c,d)}function S(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new va(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size)}catch(a){return d(a)}c.db.transaction(function(e){R(e,c,function(){b._dbInfo=c,a()},function(a,b){d(b)})},d)});return c.serializer=Va,e}function T(a,b,c,d,e,f){a.executeSql(c,d,e,function(a,g){g.code===g.SYNTAX_ERR?a.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?",[b.storeName],function(a,h){h.rows.length?f(a,g):R(a,b,function(){a.executeSql(c,d,e,f)},f)},f):f(a,g)},f)}function U(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function V(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function W(a,b,c,d){var e=this;a=j(a);var f=new va(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){T(c,i,"INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h)},function(a,b){g(b)})},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(W.apply(e,[a,h,c,d-1]));g(b)}})})}).catch(g)});return h(f,c),f}function X(a,b,c){return W.apply(this,[a,b,c,1])}function Y(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function Z(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function $(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function _(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function aa(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function ba(a){return new va(function(b,c){a.transaction(function(d){d.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",[],function(c,d){for(var e=[],f=0;f<d.rows.length;f++)e.push(d.rows.item(f).name);b({db:a,storeNames:e})},function(a,b){c(b)})},function(a){c(a)})})}function ca(a,b){b=k.apply(this,arguments);var c=this.config();a="function"!=typeof a&&a||{},a.name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;return d=a.name?new va(function(b){var d;d=a.name===c.name?e._dbInfo.db:openDatabase(a.name,"","",0),b(a.storeName?{db:d,storeNames:[a.storeName]}:ba(d))}).then(function(a){return new va(function(b,c){a.db.transaction(function(d){function e(a){return new va(function(b,c){d.executeSql("DROP TABLE IF EXISTS "+a,[],function(){b()},function(a,b){c(b)})})}for(var f=[],g=0,h=a.storeNames.length;g<h;g++)f.push(e(a.storeNames[g]));va.all(f).then(function(){b()}).catch(function(a){c(a)})},function(a){c(a)})})}):va.reject("Invalid arguments"),h(d,b),d}function da(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&!!localStorage.setItem}catch(a){return!1}}function ea(a,b){var c=a.name+"/";return a.storeName!==b.storeName&&(c+=a.storeName+"/"),c}function fa(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return!0}}function ga(){return!fa()||localStorage.length>0}function ha(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=ea(a,b._defaultConfig),ga()?(b._dbInfo=c,c.serializer=Va,va.resolve()):va.reject()}function ia(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d)}});return h(c,a),c}function ja(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ka(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function la(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a)}catch(a){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ma(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length))}return d});return h(c,a),c}function na(a){var b=this,c=b.keys().then(function(a){return a.length});return h(c,a),c}function oa(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a)});return h(d,b),d}function pa(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new va(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c)}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a)}})})});return h(e,c),e}function qa(a,b){if(b=k.apply(this,arguments),a="function"!=typeof a&&a||{},!a.name){var c=this.config();a.name=a.name||c.name,a.storeName=a.storeName||c.storeName}var d,e=this;return d=a.name?new va(function(b){b(a.storeName?ea(a,e._defaultConfig):a.name+"/")}).then(function(a){for(var b=localStorage.length-1;b>=0;b--){var c=localStorage.key(b);0===c.indexOf(a)&&localStorage.removeItem(c)}}):va.reject("Invalid arguments"),h(d,b),d}function ra(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function sa(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&($a(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c])}return arguments[0]}var ta="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},ua=e();"undefined"==typeof Promise&&a(3);var va=Promise,wa="local-forage-detect-blob-support",xa=void 0,ya={},za=Object.prototype.toString,Aa="readonly",Ba="readwrite",Ca={_driver:"asyncStorage",_initStorage:C,_support:f(),iterate:E,getItem:D,setItem:F,removeItem:G,clear:H,length:I,key:J,keys:K,dropInstance:L},Da="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Ea="~~local_forage_type~",Fa=/^~~local_forage_type~([^~]+)~/,Ga="__lfsc__:",Ha=Ga.length,Ia="arbf",Ja="blob",Ka="si08",La="ui08",Ma="uic8",Na="si16",Oa="si32",Pa="ur16",Qa="ui32",Ra="fl32",Sa="fl64",Ta=Ha+Ia.length,Ua=Object.prototype.toString,Va={serialize:P,deserialize:Q,stringToBuffer:N,bufferToString:O},Wa={_driver:"webSQLStorage",_initStorage:S,_support:M(),iterate:V,getItem:U,setItem:X,removeItem:Y,clear:Z,length:$,key:_,keys:aa,dropInstance:ca},Xa={_driver:"localStorageWrapper",_initStorage:ha,_support:da(),iterate:ka,getItem:ja,setItem:pa,removeItem:oa,clear:ia,length:na,key:la,keys:ma,dropInstance:qa},Ya=function(a,b){return a===b||"number"==typeof a&&"number"==typeof b&&isNaN(a)&&isNaN(b)},Za=function(a,b){for(var c=a.length,d=0;d<c;){if(Ya(a[d],b))return!0;d++}return!1},$a=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},_a={},ab={},bb={INDEXEDDB:Ca,WEBSQL:Wa,LOCALSTORAGE:Xa},cb=[bb.INDEXEDDB._driver,bb.WEBSQL._driver,bb.LOCALSTORAGE._driver],db=["dropInstance"],eb=["clear","getItem","iterate","key","keys","length","removeItem","setItem"].concat(db),fb={description:"",driver:cb.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},gb=function(){function a(b){d(this,a);for(var c in bb)if(bb.hasOwnProperty(c)){var e=bb[c],f=e._driver;this[c]=f,_a[f]||this.defineDriver(e)}this._defaultConfig=sa({},fb),this._config=sa({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ta(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b]}return!("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return"string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new va(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=eb.concat("_initStorage"),g=0,i=f.length;g<i;g++){var j=f[g];if((!Za(db,j)||a[j])&&"function"!=typeof a[j])return void c(e)}(function(){for(var b=function(a){return function(){var b=new Error("Method "+a+" is not implemented by the current driver"),c=va.reject(b);return h(c,arguments[arguments.length-1]),c}},c=0,d=db.length;c<d;c++){var e=db[c];a[e]||(a[e]=b(e))}})();var k=function(c){_a[d]&&console.info("Redefining LocalForage driver: "+d),_a[d]=a,ab[d]=c,b()};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(k,c):k(!!a._support):k(!0)}catch(a){c(a)}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=_a[a]?va.resolve(_a[a]):va.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=va.resolve(Va);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver()}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=va.reject(h),g._driverSet}var c=0;return b()}}var g=this;$a(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return va.resolve()}):va.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h)})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=va.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return!!ab[a]},a.prototype._extend=function(a){sa(this,a)},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e)}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=eb.length;a<b;a++)ra(this,eb[a])},a.prototype.createInstance=function(b){return new a(b)},a}(),hb=new gb;b.exports=hb},{3:3}]},{},[4])(4)});
}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_3 () {
// PARSING =============================================================================================================
Parser = {};
Parser._parse_aToB = function (abMap, a, fallback) {
	if (a === undefined || a === null) throw new TypeError("undefined or null object passed to parser");
	if (typeof a === "string") a = a.trim();
	if (abMap[a] !== undefined) return abMap[a];
	return fallback !== undefined ? fallback : a;
};

Parser._parse_bToA = function (abMap, b, fallback) {
	if (b === undefined || b === null) throw new TypeError("undefined or null object passed to parser");
	if (typeof b === "string") b = b.trim();
	for (const v in abMap) {
		if (!abMap.hasOwnProperty(v)) continue;
		if (abMap[v] === b) return v;
	}
	return fallback !== undefined ? fallback : b;
};

Parser.attrChooseToFull = function (attList) {
	if (attList.length === 1) return `${Parser.attAbvToFull(attList[0])} modifier`;
	else {
		const attsTemp = [];
		for (let i = 0; i < attList.length; ++i) {
			attsTemp.push(Parser.attAbvToFull(attList[i]));
		}
		return `${attsTemp.join(" or ")} modifier (your choice)`;
	}
};

Parser.numberToText = function (number) {
	if (number == null) throw new TypeError(`undefined or null object passed to parser`);
	if (Math.abs(number) >= 100) return `${number}`;

	function getAsText (num) {
		const abs = Math.abs(num);
		switch (abs) {
			case 0: return "zero";
			case 1: return "one";
			case 2: return "two";
			case 3: return "three";
			case 4: return "four";
			case 5: return "five";
			case 6: return "six";
			case 7: return "seven";
			case 8: return "eight";
			case 9: return "nine";
			case 10: return "ten";
			case 11: return "eleven";
			case 12: return "twelve";
			case 13: return "thirteen";
			case 14: return "fourteen";
			case 15: return "fifteen";
			case 16: return "sixteen";
			case 17: return "seventeen";
			case 18: return "eighteen";
			case 19: return "nineteen";
			case 20: return "twenty";
			case 30: return "thirty";
			case 40: return "forty";
			case 50: return "fiddy"; // :^)
			case 60: return "sixty";
			case 70: return "seventy";
			case 80: return "eighty";
			case 90: return "ninety";
			default: {
				const str = String(abs);
				return `${getAsText(Number(`${str[0]}0`))}-${getAsText(Number(str[1]))}`;
			}
		}
	}
	return `${number < 0 ? "negative " : ""}${getAsText(number)}`;
};

Parser.textToNumber = function (str) {
	str = str.trim().toLowerCase();
	if (!isNaN(str)) return Number(str);
	switch (str) {
		case "zero": return 0;
		case "one": case "a": case "an": return 1;
		case "two": case "double": return 2;
		case "three": case "triple": return 3;
		case "four": case "quadruple": return 4;
		case "five": return 5;
		case "six": return 6;
		case "seven": return 7;
		case "eight": return 8;
		case "nine": return 9;
		case "ten": return 10;
		case "eleven": return 11;
		case "twelve": return 12;
		case "thirteen": return 13;
		case "fourteen": return 14;
		case "fifteen": return 15;
		case "sixteen": return 16;
		case "seventeen": return 17;
		case "eighteen": return 18;
		case "nineteen": return 19;
		case "twenty": return 20;
		case "thirty": return 30;
		case "forty": return 40;
		case "fifty": case "fiddy": return 50;
		case "sixty": return 60;
		case "seventy": return 70;
		case "eighty": return 80;
		case "ninety": return 90;
	}
	return NaN;
};

Parser.numberToVulgar = function (number) {
	const isNeg = number < 0;
	const spl = `${number}`.replace(/^-/, "").split(".");
	if (spl.length === 1) return number;

	let preDot = spl[0] === "0" ? "" : spl[0];
	if (isNeg) preDot = `-${preDot}`;

	switch (spl[1]) {
		case "125": return `${preDot}⅛`;
		case "25": return `${preDot}¼`;
		case "375": return `${preDot}⅜`;
		case "5": return `${preDot}½`;
		case "625": return `${preDot}⅝`;
		case "75": return `${preDot}¾`;
		case "875": return `${preDot}⅞`;

		default: {
			// Handle recursive
			const asNum = Number(`0.${spl[1]}`);

			if (asNum.toFixed(2) === (1 / 3).toFixed(2)) return `${preDot}⅓`;
			if (asNum.toFixed(2) === (2 / 3).toFixed(2)) return `${preDot}⅔`;

			if (asNum.toFixed(2) === (1 / 6).toFixed(2)) return `${preDot}⅙`;
			if (asNum.toFixed(2) === (5 / 6).toFixed(2)) return `${preDot}⅚`;
		}
	}

	return Parser.numberToFractional(number);
};

Parser.vulgarToNumber = function (str) {
	const [, leading = "0", vulgar = ""] = /^(\d+)?([⅛¼⅜½⅝¾⅞⅓⅔⅙⅚])?$/.exec(str) || [];
	let out = Number(leading);
	switch (vulgar) {
		case "⅛": out += 0.125; break;
		case "¼": out += 0.25; break;
		case "⅜": out += 0.375; break;
		case "½": out += 0.5; break;
		case "⅝": out += 0.625; break;
		case "¾": out += 0.75; break;
		case "⅞": out += 0.875; break;
		case "⅓": out += 1 / 3; break;
		case "⅔": out += 2 / 3; break;
		case "⅙": out += 1 / 6; break;
		case "⅚": out += 5 / 6; break;
		case "": break;
		default: throw new Error(`Unhandled vulgar part "${vulgar}"`);
	}
	return out;
};

Parser.numberToSuperscript = function (number) {
	return `${number}`.split("").map(c => isNaN(c) ? c : Parser._NUMBERS_SUPERSCRIPT[Number(c)]).join("");
};
Parser._NUMBERS_SUPERSCRIPT = "⁰¹²³⁴⁵⁶⁷⁸⁹";

Parser.numberToSubscript = function (number) {
	return `${number}`.split("").map(c => isNaN(c) ? c : Parser._NUMBERS_SUBSCRIPT[Number(c)]).join("");
};
Parser._NUMBERS_SUBSCRIPT = "₀₁₂₃₄₅₆₇₈₉";

Parser._greatestCommonDivisor = function (a, b) {
	if (b < Number.EPSILON) return a;
	return Parser._greatestCommonDivisor(b, Math.floor(a % b));
};
Parser.numberToFractional = function (number) {
	const len = number.toString().length - 2;
	let denominator = 10 ** len;
	let numerator = number * denominator;
	const divisor = Parser._greatestCommonDivisor(numerator, denominator);
	numerator = Math.floor(numerator / divisor);
	denominator = Math.floor(denominator / divisor);

	return denominator === 1 ? String(numerator) : `${Math.floor(numerator)}/${Math.floor(denominator)}`;
};

Parser.ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

Parser.attAbvToFull = function (abv) {
	return Parser._parse_aToB(Parser.ATB_ABV_TO_FULL, abv);
};

Parser.attFullToAbv = function (full) {
	return Parser._parse_bToA(Parser.ATB_ABV_TO_FULL, full);
};

Parser.sizeAbvToFull = function (abv) {
	return Parser._parse_aToB(Parser.SIZE_ABV_TO_FULL, abv);
};

Parser.getAbilityModNumber = function (abilityScore) {
	return Math.floor((abilityScore - 10) / 2);
};

Parser.getAbilityModifier = function (abilityScore) {
	let modifier = Parser.getAbilityModNumber(abilityScore);
	if (modifier >= 0) modifier = `+${modifier}`;
	return `${modifier}`;
};

Parser.getSpeedString = (it) => {
	if (it.speed == null) return "\u2014";

	function procSpeed (propName) {
		function addSpeed (s) {
			stack.push(`${propName === "walk" ? "" : `${propName} `}${getVal(s)} ft.${getCond(s)}`);
		}

		if (it.speed[propName] || propName === "walk") addSpeed(it.speed[propName] || 0);
		if (it.speed.alternate && it.speed.alternate[propName]) it.speed.alternate[propName].forEach(addSpeed);
	}

	function getVal (speedProp) {
		return speedProp.number != null ? speedProp.number : speedProp;
	}

	function getCond (speedProp) {
		return speedProp.condition ? ` ${Renderer.get().render(speedProp.condition)}` : "";
	}

	const stack = [];
	if (typeof it.speed === "object") {
		let joiner = ", ";
		Parser.SPEED_MODES.forEach(mode => procSpeed(mode));
		if (it.speed.choose) {
			joiner = "; ";
			stack.push(`${it.speed.choose.from.sort().joinConjunct(", ", " or ")} ${it.speed.choose.amount} ft.${it.speed.choose.note ? ` ${it.speed.choose.note}` : ""}`);
		}
		return stack.join(joiner) + (it.speed.note ? ` ${it.speed.note}` : "");
	} else {
		return it.speed + (it.speed === "Varies" ? "" : " ft. ");
	}
};

Parser.SPEED_MODES = ["walk", "burrow", "climb", "fly", "swim"];

Parser.SPEED_TO_PROGRESSIVE = {
	"walk": "walking",
	"burrow": "burrowing",
	"climb": "climbing",
	"fly": "flying",
	"swim": "swimming",
};

Parser.speedToProgressive = function (prop) {
	return Parser._parse_aToB(Parser.SPEED_TO_PROGRESSIVE, prop);
};

Parser._addCommas = function (intNum) {
	return `${intNum}`.replace(/(\d)(?=(\d{3})+$)/g, "$1,");
};

Parser.raceCreatureTypesToFull = function (creatureTypes) {
	const hasSubOptions = creatureTypes.some(it => it.choose);
	return creatureTypes
		.map(it => {
			if (!it.choose) return Parser.monTypeToFullObj(it).asText.toTitleCase();
			return [...it.choose]
				.sort(SortUtil.ascSortLower)
				.map(sub => Parser.monTypeToFullObj(sub).asText.toTitleCase())
				.joinConjunct(", ", " or ");
		})
		.joinConjunct(hasSubOptions ? "; " : ", ", " and ")
};

Parser.crToXp = function (cr, {isDouble = false} = {}) {
	if (cr != null && cr.xp) return Parser._addCommas(`${isDouble ? cr.xp * 2 : cr.xp}`);

	const toConvert = cr ? (cr.cr || cr) : null;
	if (toConvert === "Unknown" || toConvert == null || !Parser.XP_CHART_ALT[toConvert]) return "Unknown";
	if (toConvert === "0") return "0 or 10";
	const xp = Parser.XP_CHART_ALT[toConvert];
	return Parser._addCommas(`${isDouble ? 2 * xp : xp}`);
};

Parser.crToXpNumber = function (cr) {
	if (cr != null && cr.xp) return cr.xp;
	const toConvert = cr ? (cr.cr || cr) : cr;
	if (toConvert === "Unknown" || toConvert == null) return null;
	return Parser.XP_CHART_ALT[toConvert] ?? null;
};

LEVEL_TO_XP_EASY = [0, 25, 50, 75, 125, 250, 300, 350, 450, 550, 600, 800, 1000, 1100, 1250, 1400, 1600, 2000, 2100, 2400, 2800];
LEVEL_TO_XP_MEDIUM = [0, 50, 100, 150, 250, 500, 600, 750, 900, 1100, 1200, 1600, 2000, 2200, 2500, 2800, 3200, 3900, 4100, 4900, 5700];
LEVEL_TO_XP_HARD = [0, 75, 150, 225, 375, 750, 900, 1100, 1400, 1600, 1900, 2400, 3000, 3400, 3800, 4300, 4800, 5900, 6300, 7300, 8500];
LEVEL_TO_XP_DEADLY = [0, 100, 200, 400, 500, 1100, 1400, 1700, 2100, 2400, 2800, 3600, 4500, 5100, 5700, 6400, 7200, 8800, 9500, 10900, 12700];
LEVEL_TO_XP_DAILY = [0, 300, 600, 1200, 1700, 3500, 4000, 5000, 6000, 7500, 9000, 10500, 11500, 13500, 15000, 18000, 20000, 25000, 27000, 30000, 40000];

Parser.LEVEL_XP_REQUIRED = [0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000];

Parser.CRS = ["0", "1/8", "1/4", "1/2", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"];

Parser.levelToXpThreshold = function (level) {
	return [LEVEL_TO_XP_EASY[level], LEVEL_TO_XP_MEDIUM[level], LEVEL_TO_XP_HARD[level], LEVEL_TO_XP_DEADLY[level]];
};

Parser.isValidCr = function (cr) {
	return Parser.CRS.includes(cr);
};

Parser.crToNumber = function (cr) {
	if (cr === "Unknown" || cr === "\u2014" || cr == null) return VeCt.CR_UNKNOWN;
	if (cr.cr) return Parser.crToNumber(cr.cr);

	const parts = cr.trim().split("/");

	if (parts.length === 1) {
		if (isNaN(parts[0])) return VeCt.CR_CUSTOM;
		return Number(parts[0]);
	} else if (parts.length === 2) {
		if (isNaN(parts[0]) || isNaN(Number(parts[1]))) return VeCt.CR_CUSTOM;
		return Number(parts[0]) / Number(parts[1]);
	} else return 0;
};

Parser.numberToCr = function (number, safe) {
	// avoid dying if already-converted number is passed in
	if (safe && typeof number === "string" && Parser.CRS.includes(number)) return number;

	if (number == null) return "Unknown";

	return Parser.numberToFractional(number);
};

Parser.crToPb = function (cr) {
	if (cr === "Unknown" || cr == null) return 0;
	cr = cr.cr || cr;
	if (Parser.crToNumber(cr) < 5) return 2;
	return Math.ceil(cr / 4) + 1;
};

Parser.levelToPb = function (level) {
	if (!level) return 2;
	return Math.ceil(level / 4) + 1;
};

Parser.SKILL_TO_ATB_ABV = {
	"athletics": "str",
	"acrobatics": "dex",
	"sleight of hand": "dex",
	"stealth": "dex",
	"arcana": "int",
	"history": "int",
	"investigation": "int",
	"nature": "int",
	"religion": "int",
	"animal handling": "wis",
	"insight": "wis",
	"medicine": "wis",
	"perception": "wis",
	"survival": "wis",
	"deception": "cha",
	"intimidation": "cha",
	"performance": "cha",
	"persuasion": "cha",
};

Parser.skillToAbilityAbv = function (skill) {
	return Parser._parse_aToB(Parser.SKILL_TO_ATB_ABV, skill);
};

Parser.SKILL_TO_SHORT = {
	"athletics": "ath",
	"acrobatics": "acro",
	"sleight of hand": "soh",
	"stealth": "slth",
	"arcana": "arc",
	"history": "hist",
	"investigation": "invn",
	"nature": "natr",
	"religion": "reli",
	"animal handling": "hndl",
	"insight": "ins",
	"medicine": "med",
	"perception": "perp",
	"survival": "surv",
	"deception": "decp",
	"intimidation": "intm",
	"performance": "perf",
	"persuasion": "pers",
};

Parser.skillToShort = function (skill) {
	return Parser._parse_aToB(Parser.SKILL_TO_SHORT, skill);
};

Parser.LANGUAGES_STANDARD = [
	"Common",
	"Dwarvish",
	"Elvish",
	"Giant",
	"Gnomish",
	"Goblin",
	"Halfling",
	"Orc",
];

Parser.LANGUAGES_EXOTIC = [
	"Abyssal",
	"Aquan",
	"Auran",
	"Celestial",
	"Draconic",
	"Deep Speech",
	"Ignan",
	"Infernal",
	"Primordial",
	"Sylvan",
	"Terran",
	"Undercommon",
];

Parser.LANGUAGES_SECRET = [
	"Druidic",
	"Thieves' cant",
];

Parser.LANGUAGES_ALL = [
	...Parser.LANGUAGES_STANDARD,
	...Parser.LANGUAGES_EXOTIC,
	...Parser.LANGUAGES_SECRET,
].sort();

Parser.dragonColorToFull = function (c) {
	return Parser._parse_aToB(Parser.DRAGON_COLOR_TO_FULL, c);
};

Parser.DRAGON_COLOR_TO_FULL = {
	B: "black",
	U: "blue",
	G: "green",
	R: "red",
	W: "white",
	A: "brass",
	Z: "bronze",
	C: "copper",
	O: "gold",
	S: "silver",
};

Parser.acToFull = function (ac, renderer) {
	if (typeof ac === "string") return ac; // handle classic format

	renderer = renderer || Renderer.get();

	let stack = "";
	let inBraces = false;
	for (let i = 0; i < ac.length; ++i) {
		const cur = ac[i];
		const nxt = ac[i + 1];

		if (cur.special != null) {
			if (inBraces) inBraces = false;

			stack += cur.special;
		} else if (cur.ac) {
			const isNxtBraces = nxt && nxt.braces;

			if (!inBraces && cur.braces) {
				stack += "(";
				inBraces = true;
			}

			stack += cur.ac;

			if (cur.from) {
				// always brace nested braces
				if (cur.braces) {
					stack += " (";
				} else {
					stack += inBraces ? "; " : " (";
				}

				inBraces = true;

				stack += cur.from.map(it => renderer.render(it)).join(", ");

				if (cur.braces) {
					stack += ")";
				} else if (!isNxtBraces) {
					stack += ")";
					inBraces = false;
				}
			}

			if (cur.condition) stack += ` ${renderer.render(cur.condition)}`;

			if (inBraces && !isNxtBraces) {
				stack += ")";
				inBraces = false;
			}
		} else {
			stack += cur;
		}

		if (nxt) {
			if (nxt.braces) {
				stack += inBraces ? "; " : " (";
				inBraces = true;
			} else stack += ", ";
		}
	}
	if (inBraces) stack += ")";

	return stack.trim();
};

MONSTER_COUNT_TO_XP_MULTIPLIER = [1, 1.5, 2, 2, 2, 2, 2.5, 2.5, 2.5, 2.5, 3, 3, 3, 3, 4];
Parser.numMonstersToXpMult = function (num, playerCount = 3) {
	const baseVal = (() => {
		if (num >= MONSTER_COUNT_TO_XP_MULTIPLIER.length) return 4;
		return MONSTER_COUNT_TO_XP_MULTIPLIER[num - 1];
	})();

	if (playerCount < 3) return baseVal >= 3 ? baseVal + 1 : baseVal + 0.5;
	else if (playerCount > 5) {
		return baseVal === 4 ? 3 : baseVal - 0.5;
	} else return baseVal;
};

Parser.armorFullToAbv = function (armor) {
	return Parser._parse_bToA(Parser.ARMOR_ABV_TO_FULL, armor);
};

Parser.weaponFullToAbv = function (weapon) {
	return Parser._parse_bToA(Parser.WEAPON_ABV_TO_FULL, weapon);
};

Parser._getSourceStringFromSource = function (source) {
	if (source && source.source) return source.source;
	return source;
};
Parser._buildSourceCache = function (dict) {
	const out = {};
	Object.entries(dict).forEach(([k, v]) => out[k.toLowerCase()] = v);
	return out;
};
Parser._sourceFullCache = null;
Parser.hasSourceFull = function (source) {
	Parser._sourceFullCache = Parser._sourceFullCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_FULL);
	return !!Parser._sourceFullCache[source.toLowerCase()];
};
Parser._sourceAbvCache = null;
Parser.hasSourceAbv = function (source) {
	Parser._sourceAbvCache = Parser._sourceAbvCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_ABV);
	return !!Parser._sourceAbvCache[source.toLowerCase()];
};
Parser._sourceDateCache = null;
Parser.hasSourceDate = function (source) {
	Parser._sourceDateCache = Parser._sourceDateCache || Parser._buildSourceCache(Parser.SOURCE_JSON_TO_DATE);
	return !!Parser._sourceDateCache[source.toLowerCase()];
};
Parser.sourceJsonToFull = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceFull(source)) return Parser._sourceFullCache[source.toLowerCase()].replace(/'/g, "\u2019");
	if (BrewUtil.hasSourceJson(source)) return BrewUtil.sourceJsonToFull(source).replace(/'/g, "\u2019");
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_FULL, source).replace(/'/g, "\u2019");
};
Parser.sourceJsonToFullCompactPrefix = function (source) {
	return Parser.sourceJsonToFull(source)
		.replace(UA_PREFIX, UA_PREFIX_SHORT)
		.replace(AL_PREFIX, AL_PREFIX_SHORT)
		.replace(PS_PREFIX, PS_PREFIX_SHORT);
};
Parser.sourceJsonToAbv = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceAbv(source)) return Parser._sourceAbvCache[source.toLowerCase()];
	if (BrewUtil.hasSourceJson(source)) return BrewUtil.sourceJsonToAbv(source);
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_ABV, source);
};
Parser.sourceJsonToDate = function (source) {
	source = Parser._getSourceStringFromSource(source);
	if (Parser.hasSourceDate(source)) return Parser._sourceDateCache[source.toLowerCase()];
	if (BrewUtil.hasSourceJson(source)) return BrewUtil.sourceJsonToDate(source);
	return Parser._parse_aToB(Parser.SOURCE_JSON_TO_DATE, source, null);
};

Parser.sourceJsonToColor = function (source) {
	return `source${Parser.sourceJsonToAbv(source)}`;
};

Parser.stringToSlug = function (str) {
	return str.trim().toLowerCase().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
};

Parser.stringToCasedSlug = function (str) {
	return str.replace(/[^\w ]+/g, "").replace(/ +/g, "-");
};

Parser.ITEM_SPELLCASTING_FOCUS_CLASSES = ["Artificer", "Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"];

Parser.itemValueToFull = function (item, opts = {isShortForm: false, isSmallUnits: false}) {
	return Parser._moneyToFull(item, "value", "valueMult", opts);
};

Parser.itemValueToFullMultiCurrency = function (item, opts = {isShortForm: false, isSmallUnits: false, multiplier: 1}) {
	return Parser._moneyToFullMultiCurrency(item, "value", "valueMult", opts);
};

Parser.itemVehicleCostsToFull = function (item, isShortForm) {
	return {
		travelCostFull: Parser._moneyToFull(item, "travelCost", "travelCostMult", {isShortForm}),
		shippingCostFull: Parser._moneyToFull(item, "shippingCost", "shippingCostMult", {isShortForm}),
	};
};

Parser.spellComponentCostToFull = function (item, isShortForm) {
	return Parser._moneyToFull(item, "cost", "costMult", {isShortForm});
};

Parser._moneyToFull = function (it, prop, propMult, opts = {isShortForm: false, isSmallUnits: false}) {
	if (it[prop] == null && it[propMult] == null) return "";
	if (it[prop] != null) {
		const {coin, mult} = Parser.getCurrencyAndMultiplier(it[prop], it.currencyConversion);
		return `${(it[prop] * mult).toLocaleString(undefined, {maximumFractionDigits: 5})}${opts.isSmallUnits ? `<span class="small ml-1">${coin}</span>` : ` ${coin}`}`;
	} else if (it[propMult] != null) return opts.isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;
	return "";
};

Parser._moneyToFullMultiCurrency = function (it, prop, propMult, {isShortForm, multiplier} = {}) {
	if (it[prop]) {
		const simplified = CurrencyUtil.doSimplifyCoins(
			{
				cp: it[prop] * (multiplier ?? 1),
			},
			{
				currencyConversionId: it.currencyConversion,
			},
		);

		const conversionTable = Parser.getCurrencyConversionTable(it.currencyConversion);

		return [...conversionTable]
			.reverse()
			.filter(meta => simplified[meta.coin])
			.map(meta => `${simplified[meta.coin].toLocaleString(undefined, {maximumFractionDigits: 5})} ${meta.coin}`)
			.join(", ");
	} else if (it[propMult]) return isShortForm ? `×${it[propMult]}` : `base value ×${it[propMult]}`;
	return "";
};

Parser.DEFAULT_CURRENCY_CONVERSION_TABLE = [
	{
		coin: "cp",
		mult: 1,
	},
	{
		coin: "sp",
		mult: 0.1,
	},
	{
		coin: "gp",
		mult: 0.01,
		isFallback: true,
	},
];
Parser.FULL_CURRENCY_CONVERSION_TABLE = [
	{
		coin: "cp",
		mult: 1,
	},
	{
		coin: "sp",
		mult: 0.1,
	},
	{
		coin: "ep",
		mult: 0.02,
	},
	{
		coin: "gp",
		mult: 0.01,
		isFallback: true,
	},
	{
		coin: "pp",
		mult: 0.001,
	},
];
Parser.getCurrencyConversionTable = function (currencyConversionId) {
	const fromBrew = currencyConversionId ? MiscUtil.get(BrewUtil.homebrewMeta, "currencyConversions", currencyConversionId) : null;
	const conversionTable = fromBrew && fromBrew.length ? fromBrew : Parser.DEFAULT_CURRENCY_CONVERSION_TABLE;
	if (conversionTable !== Parser.DEFAULT_CURRENCY_CONVERSION_TABLE) conversionTable.sort((a, b) => SortUtil.ascSort(b.mult, a.mult));
	return conversionTable;
};
Parser.getCurrencyAndMultiplier = function (value, currencyConversionId) {
	const conversionTable = Parser.getCurrencyConversionTable(currencyConversionId);

	if (!value) return conversionTable.find(it => it.isFallback) || conversionTable[0];
	if (conversionTable.length === 1) return conversionTable[0];
	if (!Number.isInteger(value) && value < conversionTable[0].mult) return conversionTable[0];

	for (let i = conversionTable.length - 1; i >= 0; --i) {
		if (Number.isInteger(value * conversionTable[i].mult)) return conversionTable[i];
	}

	return conversionTable.last();
};

Parser.COIN_ABVS = ["cp", "sp", "ep", "gp", "pp"];
Parser.COIN_ABV_TO_FULL = {
	"cp": "copper pieces",
	"sp": "silver pieces",
	"ep": "electrum pieces",
	"gp": "gold pieces",
	"pp": "platinum pieces",
};
Parser.COIN_CONVERSIONS = [1, 10, 50, 100, 1000];

Parser.coinAbvToFull = function (coin) {
	return Parser._parse_aToB(Parser.COIN_ABV_TO_FULL, coin);
};

/**
 * @param currency Object of the form `{pp: <n>, gp: <m>, ... }`.
 * @param isDisplayEmpty If "empty" values (i.e., those which are 0) should be displayed.
 */
Parser.getDisplayCurrency = function (currency, {isDisplayEmpty = false} = {}) {
	return [...Parser.COIN_ABVS]
		.reverse()
		.filter(abv => isDisplayEmpty ? currency[abv] != null : currency[abv])
		.map(abv => `${currency[abv].toLocaleString()} ${abv}`)
		.join(", ");
};

Parser.itemWeightToFull = function (item, isShortForm) {
	if (item.weight) {
		// Handle pure integers
		if (Math.round(item.weight) === item.weight) return `${item.weight} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`;

		// Attempt to render the amount as (a number +) a vulgar
		const weightOunces = item.weight * 16;
		const integerPart = Math.floor(item.weight);
		const vulgarPart = weightOunces % 16;

		let vulgarGlyph;
		switch (vulgarPart) {
			case 2: vulgarGlyph = "⅛"; break;
			case 4: vulgarGlyph = "¼"; break;
			case 6: vulgarGlyph = "⅜"; break;
			case 8: vulgarGlyph = "½"; break;
			case 10: vulgarGlyph = "⅝"; break;
			case 12: vulgarGlyph = "¾"; break;
			case 14: vulgarGlyph = "⅞"; break;
		}
		if (vulgarGlyph) return `${integerPart || ""}${vulgarGlyph} lb.${(item.weightNote ? ` ${item.weightNote}` : "")}`

		// Fall back on decimal pounds or ounces
		return `${item.weight < 1 ? item.weight * 16 : item.weight} ${item.weight < 1 ? "oz" : "lb"}.${(item.weightNote ? ` ${item.weightNote}` : "")}`
	}
	if (item.weightMult) return isShortForm ? `×${item.weightMult}` : `base weight ×${item.weightMult}`;
	return "";
};

Parser.ITEM_RECHARGE_TO_FULL = {
	round: "Every Round",
	restShort: "Short Rest",
	restLong: "Long Rest",
	dawn: "Dawn",
	dusk: "Dusk",
	midnight: "Midnight",
	special: "Special",
}
Parser.itemRechargeToFull = function (recharge) {
	return Parser._parse_aToB(Parser.ITEM_RECHARGE_TO_FULL, recharge);
};

Parser._decimalSeparator = (0.1).toLocaleString().substring(1, 2);
Parser._numberCleanRegexp = Parser._decimalSeparator === "." ? new RegExp(/[\s,]*/g, "g") : new RegExp(/[\s.]*/g, "g");
Parser._costSplitRegexp = Parser._decimalSeparator === "." ? new RegExp(/(\d+(\.\d+)?)([csegp]p)/) : new RegExp(/(\d+(,\d+)?)([csegp]p)/);

/** input e.g. "25 gp", "1,000pp" */
Parser.coinValueToNumber = function (value) {
	if (!value) return 0;
	// handle oddities
	if (value === "Varies") return 0;

	value = value
		.replace(/\s*/, "")
		.replace(Parser._numberCleanRegexp, "")
		.toLowerCase();
	const m = Parser._costSplitRegexp.exec(value);
	if (!m) throw new Error(`Badly formatted value "${value}"`);
	const ixCoin = Parser.COIN_ABVS.indexOf(m[3]);
	if (!~ixCoin) throw new Error(`Unknown coin type "${m[3]}"`);
	return Number(m[1]) * Parser.COIN_CONVERSIONS[ixCoin];
};

Parser.weightValueToNumber = function (value) {
	if (!value) return 0;

	if (Number(value)) return Number(value);
	else throw new Error(`Badly formatted value ${value}`);
};

Parser.dmgTypeToFull = function (dmgType) {
	return Parser._parse_aToB(Parser.DMGTYPE_JSON_TO_FULL, dmgType);
};

Parser.skillToExplanation = function (skillType) {
	const fromBrew = MiscUtil.get(BrewUtil.homebrewMeta, "skills", skillType);
	if (fromBrew) return fromBrew;
	return Parser._parse_aToB(Parser.SKILL_JSON_TO_FULL, skillType);
};

Parser.senseToExplanation = function (senseType) {
	senseType = senseType.toLowerCase();
	const fromBrew = MiscUtil.get(BrewUtil.homebrewMeta, "senses", senseType);
	if (fromBrew) return fromBrew;
	return Parser._parse_aToB(Parser.SENSE_JSON_TO_FULL, senseType, ["No explanation available."]);
};

Parser.skillProficienciesToFull = function (skillProficiencies) {
	function renderSingle (skProf) {
		if (skProf.any) {
			skProf = MiscUtil.copy(skProf);
			skProf.choose = {"from": Object.keys(Parser.SKILL_TO_ATB_ABV), "count": skProf.any};
			delete skProf.any;
		}

		const keys = Object.keys(skProf).sort(SortUtil.ascSortLower);

		const ixChoose = keys.indexOf("choose");
		if (~ixChoose) keys.splice(ixChoose, 1);

		const baseStack = [];
		keys.filter(k => skProf[k]).forEach(k => baseStack.push(Renderer.get().render(`{@skill ${k.toTitleCase()}}`)));

		const chooseStack = [];
		if (~ixChoose) {
			const chObj = skProf.choose;
			if (chObj.from.length === 18) {
				chooseStack.push(`choose any ${!chObj.count || chObj.count === 1 ? "skill" : chObj.count}`);
			} else {
				chooseStack.push(`choose ${chObj.count || 1} from ${chObj.from.map(it => Renderer.get().render(`{@skill ${it.toTitleCase()}}`)).joinConjunct(", ", " and ")}`);
			}
		}

		const base = baseStack.joinConjunct(", ", " and ");
		const choose = chooseStack.join(""); // this should currently only ever be 1-length

		if (baseStack.length && chooseStack.length) return `${base}; and ${choose}`;
		else if (baseStack.length) return base;
		else if (chooseStack.length) return choose;
	}

	return skillProficiencies.map(renderSingle).join(" <i>or</i> ");
};

// sp-prefix functions are for parsing spell data, and shared with the roll20 script
Parser.spSchoolAndSubschoolsAbvsToFull = function (school, subschools) {
	if (!subschools || !subschools.length) return Parser.spSchoolAbvToFull(school);
	else return `${Parser.spSchoolAbvToFull(school)} (${subschools.map(sub => Parser.spSchoolAbvToFull(sub)).join(", ")})`;
};

Parser.spSchoolAbvToFull = function (schoolOrSubschool) {
	const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_FULL, schoolOrSubschool);
	if (Parser.SP_SCHOOL_ABV_TO_FULL[schoolOrSubschool]) return out;
	if (BrewUtil.homebrewMeta && BrewUtil.homebrewMeta.spellSchools && BrewUtil.homebrewMeta.spellSchools[schoolOrSubschool]) return BrewUtil.homebrewMeta.spellSchools[schoolOrSubschool].full;
	return out;
};

Parser.spSchoolAndSubschoolsAbvsShort = function (school, subschools) {
	if (!subschools || !subschools.length) return Parser.spSchoolAbvToShort(school);
	else return `${Parser.spSchoolAbvToShort(school)} (${subschools.map(sub => Parser.spSchoolAbvToShort(sub)).join(", ")})`;
};

Parser.spSchoolAbvToShort = function (school) {
	const out = Parser._parse_aToB(Parser.SP_SCHOOL_ABV_TO_SHORT, school);
	if (Parser.SP_SCHOOL_ABV_TO_SHORT[school]) return out;
	if (BrewUtil.homebrewMeta && BrewUtil.homebrewMeta.spellSchools && BrewUtil.homebrewMeta.spellSchools[school]) return BrewUtil.homebrewMeta.spellSchools[school].short;
	return out;
};

Parser.spSchoolAbvToStyle = function (school) { // For homebrew
	const stylePart = Parser.spSchoolAbvToStylePart(school);
	if (!stylePart) return stylePart;
	return `style="${stylePart}"`;
};

Parser.spSchoolAbvToStylePart = function (school) { // For homebrew
	const rawColor = MiscUtil.get(BrewUtil, "homebrewMeta", "spellSchools", school, "color");
	if (!rawColor || !rawColor.trim()) return "";
	const validColor = BrewUtil.getValidColor(rawColor);
	if (validColor.length) return `color: #${validColor};`;
	return "";
};

Parser.getOrdinalForm = function (i) {
	i = Number(i);
	if (isNaN(i)) return "";
	const j = i % 10; const k = i % 100;
	if (j === 1 && k !== 11) return `${i}st`;
	if (j === 2 && k !== 12) return `${i}nd`;
	if (j === 3 && k !== 13) return `${i}rd`;
	return `${i}th`;
};

Parser.spLevelToFull = function (level) {
	if (level === 0) return "Cantrip";
	else return Parser.getOrdinalForm(level);
};

Parser.getArticle = function (str) {
	str = `${str}`;
	str = str.replace(/\d+/g, (...m) => Parser.numberToText(m[0]));
	return /^[aeiou]/i.test(str) ? "an" : "a";
};

Parser.spLevelToFullLevelText = function (level, dash) {
	return `${Parser.spLevelToFull(level)}${(level === 0 ? "s" : `${dash ? "-" : " "}level`)}`;
};

Parser.spLevelToSpellPoints = function (lvl) {
	lvl = Number(lvl);
	if (isNaN(lvl) || lvl === 0) return 0;
	return Math.ceil(1.34 * lvl);
};

Parser.spMetaToArr = function (meta) {
	if (!meta) return [];
	return Object.entries(meta)
		.filter(([_, v]) => v)
		.sort(SortUtil.ascSort)
		.map(([k]) => k);
};

Parser.spMetaToFull = function (meta) {
	if (!meta) return "";
	const metaTags = Parser.spMetaToArr(meta);
	if (metaTags.length) return ` (${metaTags.join(", ")})`;
	return "";
};

Parser.spLevelSchoolMetaToFull = function (level, school, meta, subschools) {
	const levelPart = level === 0 ? Parser.spLevelToFull(level).toLowerCase() : `${Parser.spLevelToFull(level)}-level`;
	const levelSchoolStr = level === 0 ? `${Parser.spSchoolAbvToFull(school)} ${levelPart}` : `${levelPart} ${Parser.spSchoolAbvToFull(school).toLowerCase()}`;

	const metaArr = Parser.spMetaToArr(meta);
	if (metaArr.length || (subschools && subschools.length)) {
		const metaAndSubschoolPart = [
			(subschools || []).map(sub => Parser.spSchoolAbvToFull(sub)).join(", "),
			metaArr.join(", "),
		].filter(Boolean).join("; ").toLowerCase();
		return `${levelSchoolStr} (${metaAndSubschoolPart})`;
	}
	return levelSchoolStr;
};

Parser.spTimeListToFull = function (times, isStripTags) {
	return times.map(t => `${Parser.getTimeToFull(t)}${t.condition ? `, ${isStripTags ? Renderer.stripTags(t.condition) : Renderer.get().render(t.condition)}` : ""}`).join(" or ");
};

Parser.getTimeToFull = function (time) {
	return `${time.number ? `${time.number} ` : ""}${time.unit === "bonus" ? "bonus action" : time.unit}${time.number > 1 ? "s" : ""}`;
};

RNG_SPECIAL = "special";
RNG_POINT = "point";
RNG_LINE = "line";
RNG_CUBE = "cube";
RNG_CONE = "cone";
RNG_RADIUS = "radius";
RNG_SPHERE = "sphere";
RNG_HEMISPHERE = "hemisphere";
RNG_CYLINDER = "cylinder"; // homebrew only
RNG_SELF = "self";
RNG_SIGHT = "sight";
RNG_UNLIMITED = "unlimited";
RNG_UNLIMITED_SAME_PLANE = "plane";
RNG_TOUCH = "touch";
Parser.SP_RANGE_TYPE_TO_FULL = {
	[RNG_SPECIAL]: "Special",
	[RNG_POINT]: "Point",
	[RNG_LINE]: "Line",
	[RNG_CUBE]: "Cube",
	[RNG_CONE]: "Cone",
	[RNG_RADIUS]: "Radius",
	[RNG_SPHERE]: "Sphere",
	[RNG_HEMISPHERE]: "Hemisphere",
	[RNG_CYLINDER]: "Cylinder",
	[RNG_SELF]: "Self",
	[RNG_SIGHT]: "Sight",
	[RNG_UNLIMITED]: "Unlimited",
	[RNG_UNLIMITED_SAME_PLANE]: "Unlimited on the same plane",
	[RNG_TOUCH]: "Touch",
};

Parser.spRangeTypeToFull = function (range) {
	return Parser._parse_aToB(Parser.SP_RANGE_TYPE_TO_FULL, range);
};

UNT_FEET = "feet";
UNT_MILES = "miles";
Parser.SP_DIST_TYPE_TO_FULL = {
	[UNT_FEET]: "Feet",
	[UNT_MILES]: "Miles",
	[RNG_SELF]: Parser.SP_RANGE_TYPE_TO_FULL[RNG_SELF],
	[RNG_TOUCH]: Parser.SP_RANGE_TYPE_TO_FULL[RNG_TOUCH],
	[RNG_SIGHT]: Parser.SP_RANGE_TYPE_TO_FULL[RNG_SIGHT],
	[RNG_UNLIMITED]: Parser.SP_RANGE_TYPE_TO_FULL[RNG_UNLIMITED],
	[RNG_UNLIMITED_SAME_PLANE]: Parser.SP_RANGE_TYPE_TO_FULL[RNG_UNLIMITED_SAME_PLANE],
};

Parser.spDistanceTypeToFull = function (range) {
	return Parser._parse_aToB(Parser.SP_DIST_TYPE_TO_FULL, range);
};

Parser.SP_RANGE_TO_ICON = {
	[RNG_SPECIAL]: "fa-star",
	[RNG_POINT]: "",
	[RNG_LINE]: "fa-grip-lines-vertical",
	[RNG_CUBE]: "fa-cube",
	[RNG_CONE]: "fa-traffic-cone",
	[RNG_RADIUS]: "fa-hockey-puck",
	[RNG_SPHERE]: "fa-globe",
	[RNG_HEMISPHERE]: "fa-globe",
	[RNG_CYLINDER]: "fa-database",
	[RNG_SELF]: "fa-street-view",
	[RNG_SIGHT]: "fa-eye",
	[RNG_UNLIMITED_SAME_PLANE]: "fa-globe-americas",
	[RNG_UNLIMITED]: "fa-infinity",
	[RNG_TOUCH]: "fa-hand-paper",
};

Parser.spRangeTypeToIcon = function (range) {
	return Parser._parse_aToB(Parser.SP_RANGE_TO_ICON, range);
};

Parser.spRangeToShortHtml = function (range) {
	switch (range.type) {
		case RNG_SPECIAL: return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="Special"></span>`;
		case RNG_POINT: return Parser.spRangeToShortHtml._renderPoint(range);
		case RNG_LINE:
		case RNG_CUBE:
		case RNG_CONE:
		case RNG_RADIUS:
		case RNG_SPHERE:
		case RNG_HEMISPHERE:
		case RNG_CYLINDER:
			return Parser.spRangeToShortHtml._renderArea(range);
	}
};
Parser.spRangeToShortHtml._renderPoint = function (range) {
	const dist = range.distance;
	switch (dist.type) {
		case RNG_SELF:
		case RNG_SIGHT:
		case RNG_UNLIMITED:
		case RNG_UNLIMITED_SAME_PLANE:
		case RNG_SPECIAL:
		case RNG_TOUCH: return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(dist.type)} help-subtle" title="${Parser.spRangeTypeToFull(dist.type)}"></span>`;
		case UNT_FEET:
		case UNT_MILES:
		default:
			return `${dist.amount} <span class="ve-small">${Parser.getSingletonUnit(dist.type, true)}</span>`;
	}
};
Parser.spRangeToShortHtml._renderArea = function (range) {
	const size = range.distance;
	return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(RNG_SELF)} help-subtle" title="Self"></span> ${size.amount}<span class="ve-small">-${Parser.getSingletonUnit(size.type, true)}</span> ${Parser.spRangeToShortHtml._getAreaStyleString(range)}`;
};
Parser.spRangeToShortHtml._getAreaStyleString = function (range) {
	return `<span class="fas fa-fw ${Parser.spRangeTypeToIcon(range.type)} help-subtle" title="${Parser.spRangeTypeToFull(range.type)}"></span>`
};

Parser.spRangeToFull = function (range) {
	switch (range.type) {
		case RNG_SPECIAL: return Parser.spRangeTypeToFull(range.type);
		case RNG_POINT: return Parser.spRangeToFull._renderPoint(range);
		case RNG_LINE:
		case RNG_CUBE:
		case RNG_CONE:
		case RNG_RADIUS:
		case RNG_SPHERE:
		case RNG_HEMISPHERE:
		case RNG_CYLINDER:
			return Parser.spRangeToFull._renderArea(range);
	}
};
Parser.spRangeToFull._renderPoint = function (range) {
	const dist = range.distance;
	switch (dist.type) {
		case RNG_SELF:
		case RNG_SIGHT:
		case RNG_UNLIMITED:
		case RNG_UNLIMITED_SAME_PLANE:
		case RNG_SPECIAL:
		case RNG_TOUCH: return Parser.spRangeTypeToFull(dist.type);
		case UNT_FEET:
		case UNT_MILES:
		default:
			return `${dist.amount} ${dist.amount === 1 ? Parser.getSingletonUnit(dist.type) : dist.type}`;
	}
};
Parser.spRangeToFull._renderArea = function (range) {
	const size = range.distance;
	return `Self (${size.amount}-${Parser.getSingletonUnit(size.type)}${Parser.spRangeToFull._getAreaStyleString(range)}${range.type === RNG_CYLINDER ? `${size.amountSecondary != null && size.typeSecondary != null ? `, ${size.amountSecondary}-${Parser.getSingletonUnit(size.typeSecondary)}-high` : ""} cylinder` : ""})`;
};
Parser.spRangeToFull._getAreaStyleString = function (range) {
	switch (range.type) {
		case RNG_SPHERE: return " radius";
		case RNG_HEMISPHERE: return `-radius ${range.type}`;
		case RNG_CYLINDER: return "-radius";
		default: return ` ${range.type}`;
	}
};

Parser.getSingletonUnit = function (unit, isShort) {
	switch (unit) {
		case UNT_FEET:
			return isShort ? "ft." : "foot";
		case UNT_MILES:
			return isShort ? "mi." : "mile";
		default: {
			const fromBrew = MiscUtil.get(BrewUtil.homebrewMeta, "spellDistanceUnits", unit, "singular");
			if (fromBrew) return fromBrew;
			if (unit.charAt(unit.length - 1) === "s") return unit.slice(0, -1);
			return unit;
		}
	}
};

Parser.RANGE_TYPES = [
	{type: RNG_POINT, hasDistance: true, isRequireAmount: false},

	{type: RNG_LINE, hasDistance: true, isRequireAmount: true},
	{type: RNG_CUBE, hasDistance: true, isRequireAmount: true},
	{type: RNG_CONE, hasDistance: true, isRequireAmount: true},
	{type: RNG_RADIUS, hasDistance: true, isRequireAmount: true},
	{type: RNG_SPHERE, hasDistance: true, isRequireAmount: true},
	{type: RNG_HEMISPHERE, hasDistance: true, isRequireAmount: true},
	{type: RNG_CYLINDER, hasDistance: true, isRequireAmount: true},

	{type: RNG_SPECIAL, hasDistance: false, isRequireAmount: false},
];

Parser.DIST_TYPES = [
	{type: RNG_SELF, hasAmount: false},
	{type: RNG_TOUCH, hasAmount: false},

	{type: UNT_FEET, hasAmount: true},
	{type: UNT_MILES, hasAmount: true},

	{type: RNG_SIGHT, hasAmount: false},
	{type: RNG_UNLIMITED_SAME_PLANE, hasAmount: false},
	{type: RNG_UNLIMITED, hasAmount: false},
];

Parser.spComponentsToFull = function (comp, level) {
	if (!comp) return "None";
	const out = [];
	if (comp.v) out.push("V");
	if (comp.s) out.push("S");
	if (comp.m != null) out.push(`M${comp.m !== true ? ` (${comp.m.text != null ? comp.m.text : comp.m})` : ""}`);
	if (comp.r) out.push(`R (${level} gp)`);
	return out.join(", ") || "None";
};

Parser.SP_END_TYPE_TO_FULL = {
	"dispel": "dispelled",
	"trigger": "triggered",
	"discharge": "discharged",
};
Parser.spEndTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_END_TYPE_TO_FULL, type);
};

Parser.spDurationToFull = function (dur) {
	let hasSubOr = false;
	const outParts = dur.map(d => {
		switch (d.type) {
			case "special":
				return "Special";
			case "instant":
				return `Instantaneous${d.condition ? ` (${d.condition})` : ""}`;
			case "timed":
				return `${d.concentration ? "Concentration, " : ""}${d.concentration ? "u" : d.duration.upTo ? "U" : ""}${d.concentration || d.duration.upTo ? "p to " : ""}${d.duration.amount} ${d.duration.amount === 1 ? d.duration.type : `${d.duration.type}s`}`;
			case "permanent": {
				if (d.ends) {
					const endsToJoin = d.ends.map(m => Parser.spEndTypeToFull(m));
					hasSubOr = hasSubOr || endsToJoin.length > 1;
					return `Until ${endsToJoin.joinConjunct(", ", " or ")}`;
				} else {
					return "Permanent";
				}
			}
		}
	});
	return `${outParts.joinConjunct(hasSubOr ? "; " : ", ", " or ")}${dur.length > 1 ? " (see below)" : ""}`;
};

Parser.DURATION_TYPES = [
	{type: "instant", full: "Instantaneous"},
	{type: "timed", hasAmount: true},
	{type: "permanent", hasEnds: true},
	{type: "special"},
];

Parser.DURATION_AMOUNT_TYPES = [
	"turn",
	"round",
	"minute",
	"hour",
	"day",
	"week",
	"year",
];

Parser.spClassesToFull = function (sp, isTextOnly, subclassLookup = {}) {
	const fromSubclassList = Renderer.spell.getCombinedClasses(sp, "fromSubclass");
	const fromSubclasses = Parser.spSubclassesToFull(fromSubclassList, isTextOnly, subclassLookup);
	const fromClassList = Renderer.spell.getCombinedClasses(sp, "fromClassList");
	return `${Parser.spMainClassesToFull(fromClassList, isTextOnly)}${fromSubclasses ? `, ${fromSubclasses}` : ""}`
};

Parser.spMainClassesToFull = function (fromClassList, textOnly = false) {
	return fromClassList
		.map(c => ({hash: UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c), c}))
		.filter(it => !ExcludeUtil.isInitialised || !ExcludeUtil.isExcluded(it.hash, "class", it.c.source))
		.sort((a, b) => SortUtil.ascSort(a.c.name, b.c.name))
		.map(it => textOnly ? it.c.name : `<a title="${it.c.definedInSource ? `Class source` : "Source"}: ${Parser.sourceJsonToFull(it.c.source)}${it.c.definedInSource ? `. Spell list defined in: ${Parser.sourceJsonToFull(it.c.definedInSource)}.` : ""}" href="${UrlUtil.PG_CLASSES}#${it.hash}">${it.c.name}</a>`)
		.join(", ") || "";
};

Parser.spSubclassesToFull = function (fromSubclassList, textOnly, subclassLookup = {}) {
	return fromSubclassList
		.filter(mt => {
			if (!ExcludeUtil.isInitialised) return true;
			const excludeClass = ExcludeUtil.isExcluded(UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](mt.class), "class", mt.class.source);
			if (excludeClass) return false;
			const fromLookup = MiscUtil.get(subclassLookup, mt.class.source, mt.class.name, mt.subclass.source, mt.subclass.name);
			if (!fromLookup) return true;
			const excludeSubclass = ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: fromLookup.name || mt.subclass.name, source: mt.subclass.source}),
				"subclass",
				mt.subclass.source,
			);
			return !excludeSubclass;
		})
		.sort((a, b) => {
			const byName = SortUtil.ascSort(a.class.name, b.class.name);
			return byName || SortUtil.ascSort(a.subclass.name, b.subclass.name);
		})
		.map(c => Parser._spSubclassItem({fromSubclass: c, textOnly, subclassLookup}))
		.join(", ") || "";
};

Parser._spSubclassItem = function ({fromSubclass, textOnly, subclassLookup}) {
	const c = fromSubclass.class;
	const sc = fromSubclass.subclass;
	const text = `${sc.name}${sc.subSubclass ? ` (${sc.subSubclass})` : ""}`;
	if (textOnly) return text;
	const classPart = `<a href="${UrlUtil.PG_CLASSES}#${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c)}" title="Source: ${Parser.sourceJsonToFull(c.source)}${c.definedInSource ? ` From a class spell list defined in: ${Parser.sourceJsonToFull(c.definedInSource)}` : ""}">${c.name}</a>`;
	const fromLookup = subclassLookup ? MiscUtil.get(subclassLookup, c.source, c.name, sc.source, sc.name) : null;
	if (fromLookup) return `<a class="italic" href="${UrlUtil.PG_CLASSES}#${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](c)}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({subclass: {shortName: sc.name, source: sc.source}})}" title="Source: ${Parser.sourceJsonToFull(fromSubclass.subclass.source)}">${text}</a> ${classPart}`;
	else return `<span class="italic" title="Source: ${Parser.sourceJsonToFull(fromSubclass.subclass.source)}">${text}</span> ${classPart}`;
};

Parser.SPELL_ATTACK_TYPE_TO_FULL = {};
Parser.SPELL_ATTACK_TYPE_TO_FULL["M"] = "Melee";
Parser.SPELL_ATTACK_TYPE_TO_FULL["R"] = "Ranged";
Parser.SPELL_ATTACK_TYPE_TO_FULL["O"] = "Other/Unknown";

Parser.spAttackTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SPELL_ATTACK_TYPE_TO_FULL, type);
};

Parser.SPELL_AREA_TYPE_TO_FULL = {
	ST: "Single Target",
	MT: "Multiple Targets",
	C: "Cube",
	N: "Cone",
	Y: "Cylinder",
	S: "Sphere",
	R: "Circle",
	Q: "Square",
	L: "Line",
	H: "Hemisphere",
	W: "Wall",
};
Parser.spAreaTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.SPELL_AREA_TYPE_TO_FULL, type);
};

Parser.SP_MISC_TAG_TO_FULL = {
	HL: "Healing",
	THP: "Grants Temporary Hit Points",
	SGT: "Requires Sight",
	PRM: "Permanent Effects",
	SCL: "Scaling Effects",
	SMN: "Summons Creature",
	MAC: "Modifies AC",
	TP: "Teleportation",
	FMV: "Forced Movement",
};
Parser.spMiscTagToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_MISC_TAG_TO_FULL, type);
};

Parser.SP_CASTER_PROGRESSION_TO_FULL = {
	full: "Full",
	"1/2": "Half",
	"1/3": "One-Third",
	"pact": "Pact Magic",
};
Parser.spCasterProgressionToFull = function (type) {
	return Parser._parse_aToB(Parser.SP_CASTER_PROGRESSION_TO_FULL, type);
};

// mon-prefix functions are for parsing monster data, and shared with the roll20 script
Parser.monTypeToFullObj = function (type) {
	const out = {type: "", tags: [], asText: ""};

	if (typeof type === "string") {
		// handles e.g. "fey"
		out.type = type;
		out.asText = type;
		return out;
	}

	const tempTags = [];
	if (type.tags) {
		for (const tag of type.tags) {
			if (typeof tag === "string") {
				// handles e.g. "fiend (devil)"
				out.tags.push(tag);
				tempTags.push(tag);
			} else {
				// handles e.g. "humanoid (Chondathan human)"
				out.tags.push(tag.tag);
				tempTags.push(`${tag.prefix} ${tag.tag}`);
			}
		}
	}
	out.type = type.type;
	if (type.swarmSize) {
		out.tags.push("swarm");
		out.asText = `swarm of ${Parser.sizeAbvToFull(type.swarmSize).toLowerCase()} ${Parser.monTypeToPlural(type.type)}`;
		out.swarmSize = type.swarmSize;
	} else {
		out.asText = `${type.type}`;
	}
	if (tempTags.length) out.asText += ` (${tempTags.join(", ")})`;
	return out;
};

Parser.monTypeToPlural = function (type) {
	return Parser._parse_aToB(Parser.MON_TYPE_TO_PLURAL, type);
};

Parser.monTypeFromPlural = function (type) {
	return Parser._parse_bToA(Parser.MON_TYPE_TO_PLURAL, type);
};

Parser.monCrToFull = function (cr, {xp = null, isMythic = false} = {}) {
	if (cr == null) return "";

	if (typeof cr === "string") {
		if (Parser.crToNumber(cr) >= VeCt.CR_CUSTOM) return `${cr}${xp != null ? ` (${xp} XP)` : ""}`;

		xp = xp != null ? Parser._addCommas(xp) : Parser.crToXp(cr);
		return `${cr} (${xp} XP${isMythic ? `, or ${Parser.crToXp(cr, {isDouble: true})} XP as a mythic encounter` : ""})`;
	} else {
		const stack = [Parser.monCrToFull(cr.cr, {xp: cr.xp, isMythic})];
		if (cr.lair) stack.push(`${Parser.monCrToFull(cr.lair)} when encountered in lair`);
		if (cr.coven) stack.push(`${Parser.monCrToFull(cr.coven)} when part of a coven`);
		return stack.joinConjunct(", ", " or ");
	}
};

Parser.getFullImmRes = function (toParse) {
	if (!toParse.length) return "";

	let maxDepth = 0;

	function toString (it, depth = 0) {
		maxDepth = Math.max(maxDepth, depth);
		if (typeof it === "string") {
			return it;
		} else if (it.special) {
			return it.special;
		} else {
			const stack = [];

			if (it.preNote) stack.push(it.preNote);

			const prop = it.immune ? "immune" : it.resist ? "resist" : it.vulnerable ? "vulnerable" : null;
			if (prop) {
				const toJoin = it[prop].map(nxt => toString(nxt, depth + 1));
				stack.push(depth ? toJoin.join(maxDepth ? "; " : ", ") : toJoin.joinConjunct(", ", " and "));
			}

			if (it.note) stack.push(it.note);

			return stack.join(" ");
		}
	}

	const arr = toParse.map(it => toString(it));

	if (arr.length <= 1) return arr.join("");

	let out = "";
	for (let i = 0; i < arr.length - 1; ++i) {
		const it = arr[i];
		const nxt = arr[i + 1];

		const orig = toParse[i];
		const origNxt = toParse[i + 1];

		out += it;
		out += (it.includes(",") || nxt.includes(",") || (orig && orig.cond) || (origNxt && origNxt.cond)) ? "; " : ", ";
	}
	out += arr.last();
	return out;
};

Parser.getFullCondImm = function (condImm, isPlainText) {
	function render (condition) {
		return isPlainText ? condition : Renderer.get().render(`{@condition ${condition}}`);
	}
	return condImm.map(it => {
		if (it.special) return it.special;
		if (it.conditionImmune) return `${it.preNote ? `${it.preNote} ` : ""}${it.conditionImmune.map(render).join(", ")}${it.note ? ` ${it.note}` : ""}`;
		return render(it);
	}).sort(SortUtil.ascSortLower).join(", ");
};

Parser.MON_SENSE_TAG_TO_FULL = {
	"B": "blindsight",
	"D": "darkvision",
	"SD": "superior darkvision",
	"T": "tremorsense",
	"U": "truesight",
};
Parser.monSenseTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_SENSE_TAG_TO_FULL, tag);
};

Parser.MON_SPELLCASTING_TAG_TO_FULL = {
	"P": "Psionics",
	"I": "Innate",
	"F": "Form Only",
	"S": "Shared",
	"CA": "Class, Artificer",
	"CB": "Class, Bard",
	"CC": "Class, Cleric",
	"CD": "Class, Druid",
	"CP": "Class, Paladin",
	"CR": "Class, Ranger",
	"CS": "Class, Sorcerer",
	"CL": "Class, Warlock",
	"CW": "Class, Wizard",
};
Parser.monSpellcastingTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_SPELLCASTING_TAG_TO_FULL, tag);
};

Parser.MON_MISC_TAG_TO_FULL = {
	"AOE": "Has Areas of Effect",
	"MW": "Has Weapon Attacks, Melee",
	"RW": "Has Weapon Attacks, Ranged",
	"RNG": "Has Ranged Weapons",
	"RCH": "Has Reach Attacks",
	"THW": "Has Thrown Weapons",
};
Parser.monMiscTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_MISC_TAG_TO_FULL, tag);
};

Parser.MON_LANGUAGE_TAG_TO_FULL = {
	"AB": "Abyssal",
	"AQ": "Aquan",
	"AU": "Auran",
	"C": "Common",
	"CE": "Celestial",
	"CS": "Can't Speak Known Languages",
	"D": "Dwarvish",
	"DR": "Draconic",
	"DS": "Deep Speech",
	"DU": "Druidic",
	"E": "Elvish",
	"G": "Gnomish",
	"GI": "Giant",
	"GO": "Goblin",
	"GTH": "Gith",
	"H": "Halfling",
	"I": "Infernal",
	"IG": "Ignan",
	"LF": "Languages Known in Life",
	"O": "Orc",
	"OTH": "Other",
	"P": "Primordial",
	"S": "Sylvan",
	"T": "Terran",
	"TC": "Thieves' cant",
	"TP": "Telepathy",
	"U": "Undercommon",
	"X": "Any (Choose)",
	"XX": "All",
};
Parser.monLanguageTagToFull = function (tag) {
	return Parser._parse_aToB(Parser.MON_LANGUAGE_TAG_TO_FULL, tag);
};

Parser.ENVIRONMENTS = ["arctic", "coastal", "desert", "forest", "grassland", "hill", "mountain", "swamp", "underdark", "underwater", "urban"];

// psi-prefix functions are for parsing psionic data, and shared with the roll20 script
Parser.PSI_ABV_TYPE_TALENT = "T";
Parser.PSI_ABV_TYPE_DISCIPLINE = "D";
Parser.PSI_ORDER_NONE = "None";
Parser.psiTypeToFull = type => Parser.psiTypeToMeta(type).full;

Parser.psiTypeToMeta = type => {
	let out = {};
	if (type === Parser.PSI_ABV_TYPE_TALENT) out = {hasOrder: false, full: "Talent"};
	else if (type === Parser.PSI_ABV_TYPE_DISCIPLINE) out = {hasOrder: true, full: "Discipline"};
	else if (BrewUtil.homebrewMeta && BrewUtil.homebrewMeta.psionicTypes && BrewUtil.homebrewMeta.psionicTypes[type]) out = BrewUtil.homebrewMeta.psionicTypes[type];
	out.full = out.full || "Unknown";
	out.short = out.short || out.full;
	return out;
};

Parser.psiOrderToFull = (order) => {
	return order === undefined ? Parser.PSI_ORDER_NONE : order;
};

Parser.prereqSpellToFull = function (spell, {isTextOnly = false} = {}) {
	if (spell) {
		const [text, suffix] = spell.split("#");
		if (!suffix) return isTextOnly ? spell : Renderer.get().render(`{@spell ${spell}}`);
		else if (suffix === "c") return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))(`{@spell ${text}} cantrip`);
		else if (suffix === "x") return (isTextOnly ? Renderer.stripTags : Renderer.get().render.bind(Renderer.get()))("{@spell hex} spell or a warlock feature that curses");
	} else return VeCt.STR_NONE;
};

Parser.prereqPactToFull = function (pact) {
	if (pact === "Chain") return "Pact of the Chain";
	if (pact === "Tome") return "Pact of the Tome";
	if (pact === "Blade") return "Pact of the Blade";
	if (pact === "Talisman") return "Pact of the Talisman";
	return pact;
};

Parser.prereqPatronToShort = function (patron) {
	if (patron === "Any") return patron;
	const mThe = /^The (.*?)$/.exec(patron);
	if (mThe) return mThe[1];
	return patron;
};

// NOTE: These need to be reflected in omnidexer.js to be indexed
Parser.OPT_FEATURE_TYPE_TO_FULL = {
	AI: "Artificer Infusion",
	ED: "Elemental Discipline",
	EI: "Eldritch Invocation",
	MM: "Metamagic",
	"MV": "Maneuver",
	"MV:B": "Maneuver, Battle Master",
	"MV:C2-UA": "Maneuver, Cavalier V2 (UA)",
	"AS:V1-UA": "Arcane Shot, V1 (UA)",
	"AS:V2-UA": "Arcane Shot, V2 (UA)",
	"AS": "Arcane Shot",
	OTH: "Other",
	"FS:F": "Fighting Style; Fighter",
	"FS:B": "Fighting Style; Bard",
	"FS:P": "Fighting Style; Paladin",
	"FS:R": "Fighting Style; Ranger",
	"PB": "Pact Boon",
	"OR": "Onomancy Resonant",
	"RN": "Rune Knight Rune",
	"AF": "Alchemical Formula",
};

Parser.optFeatureTypeToFull = function (type) {
	if (Parser.OPT_FEATURE_TYPE_TO_FULL[type]) return Parser.OPT_FEATURE_TYPE_TO_FULL[type];
	if (BrewUtil.homebrewMeta && BrewUtil.homebrewMeta.optionalFeatureTypes && BrewUtil.homebrewMeta.optionalFeatureTypes[type]) return BrewUtil.homebrewMeta.optionalFeatureTypes[type];
	return type;
};

Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL = {
	"SG": "Supernatural Gift",
	"OF": "Optional Feature",
	"DG": "Dark Gift",
	"RF:B": "Replacement Feature: Background",
};

Parser.charCreationOptionTypeToFull = function (type) {
	if (Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type]) return Parser.CHAR_OPTIONAL_FEATURE_TYPE_TO_FULL[type];
	if (BrewUtil.homebrewMeta && BrewUtil.homebrewMeta.charOption && BrewUtil.homebrewMeta.charOption[type]) return BrewUtil.homebrewMeta.charOption[type];
	return type;
};

Parser.alignmentAbvToFull = function (alignment) {
	if (!alignment) return null; // used in sidekicks
	if (typeof alignment === "object") {
		if (alignment.special != null) {
			// use in MTF Sacred Statue
			return alignment.special;
		} else {
			// e.g. `{alignment: ["N", "G"], chance: 50}` or `{alignment: ["N", "G"]}`
			return `${alignment.alignment.map(a => Parser.alignmentAbvToFull(a)).join(" ")}${alignment.chance ? ` (${alignment.chance}%)` : ""}${alignment.note ? ` (${alignment.note})` : ""}`;
		}
	} else {
		alignment = alignment.toUpperCase();
		switch (alignment) {
			case "L":
				return "lawful";
			case "N":
				return "neutral";
			case "NX":
				return "neutral (law/chaos axis)";
			case "NY":
				return "neutral (good/evil axis)";
			case "C":
				return "chaotic";
			case "G":
				return "good";
			case "E":
				return "evil";
			// "special" values
			case "U":
				return "unaligned";
			case "A":
				return "any alignment";
		}
		return alignment;
	}
};

Parser.alignmentListToFull = function (alignList) {
	if (alignList.some(it => typeof it !== "string")) {
		if (alignList.some(it => typeof it === "string")) throw new Error(`Mixed alignment types: ${JSON.stringify(alignList)}`);
		// filter out any nonexistent alignments, as we don't care about "alignment does not exist" if there are other alignments
		alignList = alignList.filter(it => it.alignment === undefined || it.alignment != null);
		return alignList.map(it => it.special != null || it.chance != null || it.note != null ? Parser.alignmentAbvToFull(it) : Parser.alignmentListToFull(it.alignment)).join(" or ");
	} else {
		// assume all single-length arrays can be simply parsed
		if (alignList.length === 1) return Parser.alignmentAbvToFull(alignList[0]);
		// a pair of abv's, e.g. "L" "G"
		if (alignList.length === 2) {
			return alignList.map(a => Parser.alignmentAbvToFull(a)).join(" ");
		}
		if (alignList.length === 3) {
			if (alignList.includes("NX") && alignList.includes("NY") && alignList.includes("N")) return "any neutral alignment";
		}
		// longer arrays should have a custom mapping
		if (alignList.length === 5) {
			if (!alignList.includes("G")) return "any non-good alignment";
			if (!alignList.includes("E")) return "any non-evil alignment";
			if (!alignList.includes("L")) return "any non-lawful alignment";
			if (!alignList.includes("C")) return "any non-chaotic alignment";
		}
		if (alignList.length === 4) {
			if (!alignList.includes("L") && !alignList.includes("NX")) return "any chaotic alignment";
			if (!alignList.includes("G") && !alignList.includes("NY")) return "any evil alignment";
			if (!alignList.includes("C") && !alignList.includes("NX")) return "any lawful alignment";
			if (!alignList.includes("E") && !alignList.includes("NY")) return "any good alignment";
		}
		throw new Error(`Unmapped alignment: ${JSON.stringify(alignList)}`);
	}
};

Parser.weightToFull = function (lbs, isSmallUnit) {
	const tons = Math.floor(lbs / 2000);
	lbs = lbs - (2000 * tons);
	return [
		tons ? `${tons}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}ton${tons === 1 ? "" : "s"}${isSmallUnit ? `</span>` : ""}` : null,
		lbs ? `${lbs}${isSmallUnit ? `<span class="ve-small ml-1">` : " "}lb.${isSmallUnit ? `</span>` : ""}` : null,
	].filter(Boolean).join(", ");
};

Parser.RARITIES = ["common", "uncommon", "rare", "very rare", "legendary", "artifact"];
Parser.ITEM_RARITIES = ["none", ...Parser.RARITIES, "unknown", "unknown (magic)", "other"];

Parser.CAT_ID_CREATURE = 1;
Parser.CAT_ID_SPELL = 2;
Parser.CAT_ID_BACKGROUND = 3;
Parser.CAT_ID_ITEM = 4;
Parser.CAT_ID_CLASS = 5;
Parser.CAT_ID_CONDITION = 6;
Parser.CAT_ID_FEAT = 7;
Parser.CAT_ID_ELDRITCH_INVOCATION = 8;
Parser.CAT_ID_PSIONIC = 9;
Parser.CAT_ID_RACE = 10;
Parser.CAT_ID_OTHER_REWARD = 11;
Parser.CAT_ID_VARIANT_OPTIONAL_RULE = 12;
Parser.CAT_ID_ADVENTURE = 13;
Parser.CAT_ID_DEITY = 14;
Parser.CAT_ID_OBJECT = 15;
Parser.CAT_ID_TRAP = 16;
Parser.CAT_ID_HAZARD = 17;
Parser.CAT_ID_QUICKREF = 18;
Parser.CAT_ID_CULT = 19;
Parser.CAT_ID_BOON = 20;
Parser.CAT_ID_DISEASE = 21;
Parser.CAT_ID_METAMAGIC = 22;
Parser.CAT_ID_MANEUVER_BATTLEMASTER = 23;
Parser.CAT_ID_TABLE = 24;
Parser.CAT_ID_TABLE_GROUP = 25;
Parser.CAT_ID_MANEUVER_CAVALIER = 26;
Parser.CAT_ID_ARCANE_SHOT = 27;
Parser.CAT_ID_OPTIONAL_FEATURE_OTHER = 28;
Parser.CAT_ID_FIGHTING_STYLE = 29;
Parser.CAT_ID_CLASS_FEATURE = 30;
Parser.CAT_ID_VEHICLE = 31;
Parser.CAT_ID_PACT_BOON = 32;
Parser.CAT_ID_ELEMENTAL_DISCIPLINE = 33;
Parser.CAT_ID_ARTIFICER_INFUSION = 34;
Parser.CAT_ID_SHIP_UPGRADE = 35;
Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE = 36;
Parser.CAT_ID_ONOMANCY_RESONANT = 37;
Parser.CAT_ID_RUNE_KNIGHT_RUNE = 37;
Parser.CAT_ID_ALCHEMICAL_FORMULA = 38;
Parser.CAT_ID_MANEUVER = 39;
Parser.CAT_ID_SUBCLASS = 40;
Parser.CAT_ID_SUBCLASS_FEATURE = 41;
Parser.CAT_ID_ACTION = 42;
Parser.CAT_ID_LANGUAGE = 43;
Parser.CAT_ID_BOOK = 44;
Parser.CAT_ID_PAGE = 45;
Parser.CAT_ID_LEGENDARY_GROUP = 46;
Parser.CAT_ID_CHAR_CREATION_OPTIONS = 47;
Parser.CAT_ID_RECIPES = 48;

Parser.CAT_ID_TO_FULL = {};
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CREATURE] = "Bestiary";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SPELL] = "Spell";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BACKGROUND] = "Background";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ITEM] = "Item";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS] = "Class";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CONDITION] = "Condition";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FEAT] = "Feat";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELDRITCH_INVOCATION] = "Eldritch Invocation";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PSIONIC] = "Psionic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RACE] = "Race";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OTHER_REWARD] = "Other Reward";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "Variant/Optional Rule";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ADVENTURE] = "Adventure";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DEITY] = "Deity";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OBJECT] = "Object";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TRAP] = "Trap";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_HAZARD] = "Hazard";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_QUICKREF] = "Quick Reference";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CULT] = "Cult";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOON] = "Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_DISEASE] = "Disease";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_METAMAGIC] = "Metamagic";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "Maneuver; Battlemaster";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_TABLE_GROUP] = "Table";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER_CAVALIER] = "Maneuver; Cavalier";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARCANE_SHOT] = "Arcane Shot";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "Optional Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_FIGHTING_STYLE] = "Fighting Style";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CLASS_FEATURE] = "Class Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_VEHICLE] = "Vehicle";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PACT_BOON] = "Pact Boon";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "Elemental Discipline";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ARTIFICER_INFUSION] = "Infusion";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SHIP_UPGRADE] = "Ship Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "Infernal War Machine Upgrade";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ONOMANCY_RESONANT] = "Onomancy Resonant";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "Rune Knight Rune";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "Alchemical Formula";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_MANEUVER] = "Maneuver";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS] = "Subclass";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_SUBCLASS_FEATURE] = "Subclass Feature";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_ACTION] = "Action";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LANGUAGE] = "Language";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_BOOK] = "Book";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_PAGE] = "Page";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_LEGENDARY_GROUP] = "Legendary Group";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "Character Creation Option";
Parser.CAT_ID_TO_FULL[Parser.CAT_ID_RECIPES] = "Recipe";

Parser.pageCategoryToFull = function (catId) {
	return Parser._parse_aToB(Parser.CAT_ID_TO_FULL, catId);
};

Parser.CAT_ID_TO_PROP = {};
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CREATURE] = "monster";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SPELL] = "spell";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BACKGROUND] = "background";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ITEM] = "item";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS] = "class";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CONDITION] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FEAT] = "feat";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PSIONIC] = "psionic";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RACE] = "race";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OTHER_REWARD] = "reward";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = "variantrule";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ADVENTURE] = "adventure";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DEITY] = "deity";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OBJECT] = "object";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TRAP] = "trap";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_HAZARD] = "hazard";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CULT] = "cult";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOON] = "boon";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_DISEASE] = "condition";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE] = "table";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_TABLE_GROUP] = "tableGroup";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_VEHICLE] = "vehicle";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELDRITCH_INVOCATION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_CAVALIER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARCANE_SHOT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_FIGHTING_STYLE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_METAMAGIC] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PACT_BOON] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ARTIFICER_INFUSION] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SHIP_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = "vehicleUpgrade";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ONOMANCY_RESONANT] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ALCHEMICAL_FORMULA] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_MANEUVER] = "optionalfeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_QUICKREF] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CLASS_FEATURE] = "classFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS] = "subclass";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassFeature";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_ACTION] = "action";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LANGUAGE] = "language";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_BOOK] = "book";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_PAGE] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_LEGENDARY_GROUP] = null;
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = "charoption";
Parser.CAT_ID_TO_PROP[Parser.CAT_ID_RECIPES] = "recipe";

Parser.pageCategoryToProp = function (catId) {
	return Parser._parse_aToB(Parser.CAT_ID_TO_PROP, catId);
};

Parser.ABIL_ABVS = ["str", "dex", "con", "int", "wis", "cha"];

Parser.spClassesToCurrentAndLegacy = function (fromClassList) {
	const current = [];
	const legacy = [];
	fromClassList.forEach(cls => {
		if ((cls.name === "Artificer" && cls.source === "UAArtificer") || (cls.name === "Artificer (Revisited)" && cls.source === "UAArtificerRevisited")) legacy.push(cls);
		else current.push(cls);
	});
	return [current, legacy];
};

/**
 * Build a pair of strings; one with all current subclasses, one with all legacy subclasses
 *
 * @param sp a spell
 * @param subclassLookup Data loaded from `generated/gendata-subclass-lookup.json`. Of the form: `{PHB: {Barbarian: {PHB: {Berserker: "Path of the Berserker"}}}}`
 * @returns {*[]} A two-element array. First item is a string of all the current subclasses, second item a string of
 * all the legacy/superseded subclasses
 */
Parser.spSubclassesToCurrentAndLegacyFull = function (sp, subclassLookup) {
	return Parser._spSubclassesToCurrentAndLegacyFull({sp, subclassLookup, prop: "fromSubclass"});
};

Parser.spVariantSubclassesToCurrentAndLegacyFull = function (sp, subclassLookup) {
	return Parser._spSubclassesToCurrentAndLegacyFull({sp, subclassLookup, prop: "fromSubclassVariant"});
};

Parser._spSubclassesToCurrentAndLegacyFull = ({sp, subclassLookup, prop}) => {
	const fromSubclass = Renderer.spell.getCombinedClasses(sp, prop);
	if (!fromSubclass.length) return ["", ""];

	const current = [];
	const legacy = [];
	const curNames = new Set();
	const toCheck = [];
	fromSubclass
		.filter(c => {
			const excludeClass = ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: c.class.name, source: c.class.source}),
				"class",
				c.class.source,
				{isNoCount: true},
			);
			if (excludeClass) return false;

			const fromLookup = MiscUtil.get(subclassLookup, c.class.source, c.class.name, c.subclass.source, c.subclass.name);
			const excludeSubclass = ExcludeUtil.isExcluded(
				UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: (fromLookup || {}).name || c.subclass.name, source: c.subclass.source}),
				"subclass",
				c.subclass.source,
				{isNoCount: true},
			);
			if (excludeSubclass) return false;

			return !Renderer.spell.isExcludedSubclassVariantSource({classDefinedInSource: c.class.definedInSource});
		})
		.sort((a, b) => {
			const byName = SortUtil.ascSort(a.subclass.name, b.subclass.name);
			return byName || SortUtil.ascSort(a.class.name, b.class.name);
		})
		.forEach(c => {
			const nm = c.subclass.name;
			const src = c.subclass.source;

			const toAdd = Parser._spSubclassItem({fromSubclass: c, textOnly: false, subclassLookup});

			const fromLookup = MiscUtil.get(
				subclassLookup,
				c.class.source,
				c.class.name,
				c.subclass.source,
				c.subclass.name,
			);

			if (fromLookup && fromLookup.isReprinted) {
				legacy.push(toAdd);
			} else if (SourceUtil.isNonstandardSource(src)) {
				const cleanName = Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent(
					nm.split("(")[0].trim().split(/v\d+/)[0].trim(),
				);
				toCheck.push({"name": cleanName, "ele": toAdd});
			} else {
				current.push(toAdd);
				curNames.add(nm);
			}
		});

	toCheck.forEach(n => {
		if (curNames.has(n.name)) {
			legacy.push(n.ele);
		} else {
			current.push(n.ele);
		}
	});

	return [current.join(", "), legacy.join(", ")];
};

/**
 * Get the most recent iteration of a subclass name.
 */
Parser._spSubclassesToCurrentAndLegacyFull.mapClassShortNameToMostRecent = (shortName) => {
	switch (shortName) {
		case "Favored Soul": return "Divine Soul";
		case "Undying Light": return "Celestial";
		case "Deep Stalker": return "Gloom Stalker";
	}
	return shortName;
};

Parser.spVariantClassesToCurrentAndLegacy = function (fromVariantClassList) {
	const current = [];
	const legacy = [];
	fromVariantClassList.forEach(cls => {
		if (cls.definedInSource === SRC_UACFV) legacy.push(cls);
		else current.push(cls);
	});
	return [current, legacy];
}

Parser.attackTypeToFull = function (attackType) {
	return Parser._parse_aToB(Parser.ATK_TYPE_TO_FULL, attackType);
};

Parser.trapHazTypeToFull = function (type) {
	return Parser._parse_aToB(Parser.TRAP_HAZARD_TYPE_TO_FULL, type);
};

Parser.TRAP_HAZARD_TYPE_TO_FULL = {
	MECH: "Mechanical trap",
	MAG: "Magical trap",
	SMPL: "Simple trap",
	CMPX: "Complex trap",
	HAZ: "Hazard",
	WTH: "Weather",
	ENV: "Environmental Hazard",
	WLD: "Wilderness Hazard",
	GEN: "Generic",
	EST: "Eldritch Storm",
};

Parser.tierToFullLevel = function (tier) {
	return Parser._parse_aToB(Parser.TIER_TO_FULL_LEVEL, tier);
};

Parser.TIER_TO_FULL_LEVEL = {};
Parser.TIER_TO_FULL_LEVEL[1] = "level 1\u20134";
Parser.TIER_TO_FULL_LEVEL[2] = "level 5\u201310";
Parser.TIER_TO_FULL_LEVEL[3] = "level 11\u201316";
Parser.TIER_TO_FULL_LEVEL[4] = "level 17\u201320";

Parser.trapInitToFull = function (init) {
	return Parser._parse_aToB(Parser.TRAP_INIT_TO_FULL, init);
};

Parser.TRAP_INIT_TO_FULL = {};
Parser.TRAP_INIT_TO_FULL[1] = "initiative count 10";
Parser.TRAP_INIT_TO_FULL[2] = "initiative count 20";
Parser.TRAP_INIT_TO_FULL[3] = "initiative count 20 and initiative count 10";

Parser.ATK_TYPE_TO_FULL = {};
Parser.ATK_TYPE_TO_FULL["MW"] = "Melee Weapon Attack";
Parser.ATK_TYPE_TO_FULL["RW"] = "Ranged Weapon Attack";

Parser.bookOrdinalToAbv = (ordinal, preNoSuff) => {
	if (ordinal === undefined) return "";
	switch (ordinal.type) {
		case "part": return `${preNoSuff ? " " : ""}Part ${ordinal.identifier}${preNoSuff ? "" : " \u2014 "}`;
		case "chapter": return `${preNoSuff ? " " : ""}Ch. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		case "episode": return `${preNoSuff ? " " : ""}Ep. ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		case "appendix": return `${preNoSuff ? " " : ""}App.${ordinal.identifier != null ? ` ${ordinal.identifier}` : ""}${preNoSuff ? "" : ": "}`;
		case "level": return `${preNoSuff ? " " : ""}Level ${ordinal.identifier}${preNoSuff ? "" : ": "}`;
		default: throw new Error(`Unhandled ordinal type "${ordinal.type}"`);
	}
};

Parser.nameToTokenName = function (name) {
	return name
		.toAscii()
		.replace(/"/g, "");
};

Parser.bytesToHumanReadable = function (bytes, {fixedDigits = 2} = {}) {
	if (bytes == null) return "";
	if (!bytes) return "0 B";
	const e = Math.floor(Math.log(bytes) / Math.log(1024));
	return `${(bytes / Math.pow(1024, e)).toFixed(fixedDigits)} ${`\u200bKMGTP`.charAt(e)}B`;
};

SKL_ABV_ABJ = "A";
SKL_ABV_EVO = "V";
SKL_ABV_ENC = "E";
SKL_ABV_ILL = "I";
SKL_ABV_DIV = "D";
SKL_ABV_NEC = "N";
SKL_ABV_TRA = "T";
SKL_ABV_CON = "C";
SKL_ABV_PSI = "P";
Parser.SKL_ABVS = [
	SKL_ABV_ABJ,
	SKL_ABV_CON,
	SKL_ABV_DIV,
	SKL_ABV_ENC,
	SKL_ABV_EVO,
	SKL_ABV_ILL,
	SKL_ABV_NEC,
	SKL_ABV_PSI,
	SKL_ABV_TRA,
];

Parser.SP_TM_ACTION = "action";
Parser.SP_TM_B_ACTION = "bonus";
Parser.SP_TM_REACTION = "reaction";
Parser.SP_TM_ROUND = "round";
Parser.SP_TM_MINS = "minute";
Parser.SP_TM_HRS = "hour";
Parser.SP_TIME_SINGLETONS = [Parser.SP_TM_ACTION, Parser.SP_TM_B_ACTION, Parser.SP_TM_REACTION, Parser.SP_TM_ROUND];
Parser.SP_TIME_TO_FULL = {
	[Parser.SP_TM_ACTION]: "Action",
	[Parser.SP_TM_B_ACTION]: "Bonus Action",
	[Parser.SP_TM_REACTION]: "Reaction",
	[Parser.SP_TM_ROUND]: "Rounds",
	[Parser.SP_TM_MINS]: "Minutes",
	[Parser.SP_TM_HRS]: "Hours",
};
Parser.spTimeUnitToFull = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_FULL, timeUnit);
};

Parser.SP_TIME_TO_SHORT = {
	[Parser.SP_TM_ROUND]: "Rnd.",
	[Parser.SP_TM_MINS]: "Min.",
	[Parser.SP_TM_HRS]: "Hr.",
}
Parser.spTimeUnitToShort = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_SHORT, timeUnit);
};

Parser.SP_TIME_TO_ABV = {
	[Parser.SP_TM_ACTION]: "A",
	[Parser.SP_TM_B_ACTION]: "BA",
	[Parser.SP_TM_REACTION]: "R",
	[Parser.SP_TM_ROUND]: "rnd",
	[Parser.SP_TM_MINS]: "min",
	[Parser.SP_TM_HRS]: "hr",
};
Parser.spTimeUnitToAbv = function (timeUnit) {
	return Parser._parse_aToB(Parser.SP_TIME_TO_ABV, timeUnit);
};

Parser.spTimeToShort = function (time, isHtml) {
	if (!time) return "";
	return (time.number === 1 && Parser.SP_TIME_SINGLETONS.includes(time.unit))
		? `${Parser.spTimeUnitToAbv(time.unit).uppercaseFirst()}${time.condition ? "*" : ""}`
		: `${time.number} ${isHtml ? `<span class="ve-small">` : ""}${Parser.spTimeUnitToAbv(time.unit)}${isHtml ? `</span>` : ""}${time.condition ? "*" : ""}`;
};

SKL_ABJ = "Abjuration";
SKL_EVO = "Evocation";
SKL_ENC = "Enchantment";
SKL_ILL = "Illusion";
SKL_DIV = "Divination";
SKL_NEC = "Necromancy";
SKL_TRA = "Transmutation";
SKL_CON = "Conjuration";
SKL_PSI = "Psionic";

Parser.SP_SCHOOL_ABV_TO_FULL = {};
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_ABJ] = SKL_ABJ;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_EVO] = SKL_EVO;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_ENC] = SKL_ENC;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_ILL] = SKL_ILL;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_DIV] = SKL_DIV;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_NEC] = SKL_NEC;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_TRA] = SKL_TRA;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_CON] = SKL_CON;
Parser.SP_SCHOOL_ABV_TO_FULL[SKL_ABV_PSI] = SKL_PSI;

Parser.SP_SCHOOL_ABV_TO_SHORT = {};
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_ABJ] = "Abj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_EVO] = "Evoc.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_ENC] = "Ench.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_ILL] = "Illu.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_DIV] = "Divin.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_NEC] = "Necro.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_TRA] = "Trans.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_CON] = "Conj.";
Parser.SP_SCHOOL_ABV_TO_SHORT[SKL_ABV_PSI] = "Psi.";

Parser.ATB_ABV_TO_FULL = {
	"str": "Strength",
	"dex": "Dexterity",
	"con": "Constitution",
	"int": "Intelligence",
	"wis": "Wisdom",
	"cha": "Charisma",
};

TP_ABERRATION = "aberration";
TP_BEAST = "beast";
TP_CELESTIAL = "celestial";
TP_CONSTRUCT = "construct";
TP_DRAGON = "dragon";
TP_ELEMENTAL = "elemental";
TP_FEY = "fey";
TP_FIEND = "fiend";
TP_GIANT = "giant";
TP_HUMANOID = "humanoid";
TP_MONSTROSITY = "monstrosity";
TP_OOZE = "ooze";
TP_PLANT = "plant";
TP_UNDEAD = "undead";
Parser.MON_TYPES = [TP_ABERRATION, TP_BEAST, TP_CELESTIAL, TP_CONSTRUCT, TP_DRAGON, TP_ELEMENTAL, TP_FEY, TP_FIEND, TP_GIANT, TP_HUMANOID, TP_MONSTROSITY, TP_OOZE, TP_PLANT, TP_UNDEAD];
Parser.MON_TYPE_TO_PLURAL = {};
Parser.MON_TYPE_TO_PLURAL[TP_ABERRATION] = "aberrations";
Parser.MON_TYPE_TO_PLURAL[TP_BEAST] = "beasts";
Parser.MON_TYPE_TO_PLURAL[TP_CELESTIAL] = "celestials";
Parser.MON_TYPE_TO_PLURAL[TP_CONSTRUCT] = "constructs";
Parser.MON_TYPE_TO_PLURAL[TP_DRAGON] = "dragons";
Parser.MON_TYPE_TO_PLURAL[TP_ELEMENTAL] = "elementals";
Parser.MON_TYPE_TO_PLURAL[TP_FEY] = "fey";
Parser.MON_TYPE_TO_PLURAL[TP_FIEND] = "fiends";
Parser.MON_TYPE_TO_PLURAL[TP_GIANT] = "giants";
Parser.MON_TYPE_TO_PLURAL[TP_HUMANOID] = "humanoids";
Parser.MON_TYPE_TO_PLURAL[TP_MONSTROSITY] = "monstrosities";
Parser.MON_TYPE_TO_PLURAL[TP_OOZE] = "oozes";
Parser.MON_TYPE_TO_PLURAL[TP_PLANT] = "plants";
Parser.MON_TYPE_TO_PLURAL[TP_UNDEAD] = "undead";

SZ_FINE = "F";
SZ_DIMINUTIVE = "D";
SZ_TINY = "T";
SZ_SMALL = "S";
SZ_MEDIUM = "M";
SZ_LARGE = "L";
SZ_HUGE = "H";
SZ_GARGANTUAN = "G";
SZ_COLOSSAL = "C";
SZ_VARIES = "V";
Parser.SIZE_ABVS = [SZ_TINY, SZ_SMALL, SZ_MEDIUM, SZ_LARGE, SZ_HUGE, SZ_GARGANTUAN, SZ_VARIES];
Parser.SIZE_ABV_TO_FULL = {};
Parser.SIZE_ABV_TO_FULL[SZ_FINE] = "Fine";
Parser.SIZE_ABV_TO_FULL[SZ_DIMINUTIVE] = "Diminutive";
Parser.SIZE_ABV_TO_FULL[SZ_TINY] = "Tiny";
Parser.SIZE_ABV_TO_FULL[SZ_SMALL] = "Small";
Parser.SIZE_ABV_TO_FULL[SZ_MEDIUM] = "Medium";
Parser.SIZE_ABV_TO_FULL[SZ_LARGE] = "Large";
Parser.SIZE_ABV_TO_FULL[SZ_HUGE] = "Huge";
Parser.SIZE_ABV_TO_FULL[SZ_GARGANTUAN] = "Gargantuan";
Parser.SIZE_ABV_TO_FULL[SZ_COLOSSAL] = "Colossal";
Parser.SIZE_ABV_TO_FULL[SZ_VARIES] = "Varies";

Parser.XP_CHART_ALT = {
	"0": 10,
	"1/8": 25,
	"1/4": 50,
	"1/2": 100,
	"1": 200,
	"2": 450,
	"3": 700,
	"4": 1100,
	"5": 1800,
	"6": 2300,
	"7": 2900,
	"8": 3900,
	"9": 5000,
	"10": 5900,
	"11": 7200,
	"12": 8400,
	"13": 10000,
	"14": 11500,
	"15": 13000,
	"16": 15000,
	"17": 18000,
	"18": 20000,
	"19": 22000,
	"20": 25000,
	"21": 33000,
	"22": 41000,
	"23": 50000,
	"24": 62000,
	"25": 75000,
	"26": 90000,
	"27": 105000,
	"28": 120000,
	"29": 135000,
	"30": 155000,
};

Parser.ARMOR_ABV_TO_FULL = {
	"l.": "light",
	"m.": "medium",
	"h.": "heavy",
};

Parser.WEAPON_ABV_TO_FULL = {
	"s.": "simple",
	"m.": "martial",
};

Parser.CONDITION_TO_COLOR = {
	"Blinded": "#525252",
	"Charmed": "#f01789",
	"Deafened": "#ababab",
	"Exhausted": "#947a47",
	"Frightened": "#c9ca18",
	"Grappled": "#8784a0",
	"Incapacitated": "#3165a0",
	"Invisible": "#7ad2d6",
	"Paralyzed": "#c00900",
	"Petrified": "#a0a0a0",
	"Poisoned": "#4dc200",
	"Prone": "#5e60a0",
	"Restrained": "#d98000",
	"Stunned": "#a23bcb",
	"Unconscious": "#3a40ad",

	"Concentration": "#009f7a",
};

Parser.RULE_TYPE_TO_FULL = {
	"O": "Optional",
	"V": "Variant",
	"VO": "Variant Optional",
	"VV": "Variant Variant",
	"U": "Unknown",
};

Parser.ruleTypeToFull = function (ruleType) {
	return Parser._parse_aToB(Parser.RULE_TYPE_TO_FULL, ruleType);
};

Parser.VEHICLE_TYPE_TO_FULL = {
	"SHIP": "Ship",
	"INFWAR": "Infernal War Machine",
	"CREATURE": "Creature",
	"OBJECT": "Object",
	"SHP:H": "Ship Upgrade, Hull",
	"SHP:M": "Ship Upgrade, Movement",
	"SHP:W": "Ship Upgrade, Weapon",
	"SHP:F": "Ship Upgrade, Figurehead",
	"SHP:O": "Ship Upgrade, Miscellaneous",
	"IWM:W": "Infernal War Machine Variant, Weapon",
	"IWM:A": "Infernal War Machine Upgrade, Armor",
	"IWM:G": "Infernal War Machine Upgrade, Gadget",
};

Parser.vehicleTypeToFull = function (vehicleType) {
	return Parser._parse_aToB(Parser.VEHICLE_TYPE_TO_FULL, vehicleType);
};

SRC_5ETOOLS_TMP = "SRC_5ETOOLS_TMP"; // Temp source, used as a placeholder value

SRC_CoS = "CoS";
SRC_DMG = "DMG";
SRC_EEPC = "EEPC";
SRC_EET = "EET";
SRC_HotDQ = "HotDQ";
SRC_LMoP = "LMoP";
SRC_MM = "MM";
SRC_OotA = "OotA";
SRC_PHB = "PHB";
SRC_PotA = "PotA";
SRC_RoT = "RoT";
SRC_RoTOS = "RoTOS";
SRC_SCAG = "SCAG";
SRC_SKT = "SKT";
SRC_ToA = "ToA";
SRC_TLK = "TLK";
SRC_ToD = "ToD";
SRC_TTP = "TTP";
SRC_TYP = "TftYP";
SRC_TYP_AtG = "TftYP-AtG";
SRC_TYP_DiT = "TftYP-DiT";
SRC_TYP_TFoF = "TftYP-TFoF";
SRC_TYP_THSoT = "TftYP-THSoT";
SRC_TYP_TSC = "TftYP-TSC";
SRC_TYP_ToH = "TftYP-ToH";
SRC_TYP_WPM = "TftYP-WPM";
SRC_VGM = "VGM";
SRC_XGE = "XGE";
SRC_OGA = "OGA";
SRC_MTF = "MTF";
SRC_WDH = "WDH";
SRC_WDMM = "WDMM";
SRC_GGR = "GGR";
SRC_KKW = "KKW";
SRC_LLK = "LLK";
SRC_AZfyT = "AZfyT";
SRC_GoS = "GoS";
SRC_AI = "AI";
SRC_OoW = "OoW";
SRC_ESK = "ESK";
SRC_DIP = "DIP";
SRC_HftT = "HftT";
SRC_DC = "DC";
SRC_SLW = "SLW";
SRC_SDW = "SDW";
SRC_BGDIA = "BGDIA";
SRC_LR = "LR";
SRC_AL = "AL";
SRC_SAC = "SAC";
SRC_ERLW = "ERLW";
SRC_EFR = "EFR";
SRC_RMBRE = "RMBRE";
SRC_RMR = "RMR";
SRC_MFF = "MFF";
SRC_AWM = "AWM";
SRC_IMR = "IMR";
SRC_SADS = "SADS";
SRC_EGW = "EGW";
SRC_EGW_ToR = "ToR";
SRC_EGW_DD = "DD";
SRC_EGW_FS = "FS";
SRC_EGW_US = "US";
SRC_MOT = "MOT";
SRC_IDRotF = "IDRotF";
SRC_TCE = "TCE";
SRC_VRGR = "VRGR";
SRC_HoL = "HoL";
SRC_XMtS = "XMtS";
SRC_RtG = "RtG";
SRC_AitFR = "AitFR";
SRC_AitFR_ISF = "AitFR-ISF";
SRC_AitFR_THP = "AitFR-THP";
SRC_AitFR_AVT = "AitFR-AVT";
SRC_AitFR_DN = "AitFR-DN";
SRC_AitFR_FCD = "AitFR-FCD";
SRC_WBtW = "WBtW";
SRC_DoD = "DoD";
SRC_MaBJoV = "MaBJoV";
SRC_FTD = "FTD";
SRC_SCREEN = "Screen";
SRC_SCREEN_WILDERNESS_KIT = "ScreenWildernessKit";
SRC_HEROES_FEAST = "HF";
SRC_CM = "CM";

SRC_AL_PREFIX = "AL";

SRC_ALCoS = `${SRC_AL_PREFIX}CurseOfStrahd`;
SRC_ALEE = `${SRC_AL_PREFIX}ElementalEvil`;
SRC_ALRoD = `${SRC_AL_PREFIX}RageOfDemons`;

SRC_PS_PREFIX = "PS";

SRC_PSA = `${SRC_PS_PREFIX}A`;
SRC_PSI = `${SRC_PS_PREFIX}I`;
SRC_PSK = `${SRC_PS_PREFIX}K`;
SRC_PSZ = `${SRC_PS_PREFIX}Z`;
SRC_PSX = `${SRC_PS_PREFIX}X`;
SRC_PSD = `${SRC_PS_PREFIX}D`;

SRC_UA_PREFIX = "UA";

SRC_UAA = `${SRC_UA_PREFIX}Artificer`;
SRC_UAEAG = `${SRC_UA_PREFIX}EladrinAndGith`;
SRC_UAEBB = `${SRC_UA_PREFIX}Eberron`;
SRC_UAFFR = `${SRC_UA_PREFIX}FeatsForRaces`;
SRC_UAFFS = `${SRC_UA_PREFIX}FeatsForSkills`;
SRC_UAFO = `${SRC_UA_PREFIX}FiendishOptions`;
SRC_UAFT = `${SRC_UA_PREFIX}Feats`;
SRC_UAGH = `${SRC_UA_PREFIX}GothicHeroes`;
SRC_UAMDM = `${SRC_UA_PREFIX}ModernMagic`;
SRC_UASSP = `${SRC_UA_PREFIX}StarterSpells`;
SRC_UATMC = `${SRC_UA_PREFIX}TheMysticClass`;
SRC_UATOBM = `${SRC_UA_PREFIX}ThatOldBlackMagic`;
SRC_UATRR = `${SRC_UA_PREFIX}TheRangerRevised`;
SRC_UAWA = `${SRC_UA_PREFIX}WaterborneAdventures`;
SRC_UAVR = `${SRC_UA_PREFIX}VariantRules`;
SRC_UALDR = `${SRC_UA_PREFIX}LightDarkUnderdark`;
SRC_UARAR = `${SRC_UA_PREFIX}RangerAndRogue`;
SRC_UAATOSC = `${SRC_UA_PREFIX}ATrioOfSubclasses`;
SRC_UABPP = `${SRC_UA_PREFIX}BarbarianPrimalPaths`;
SRC_UARSC = `${SRC_UA_PREFIX}RevisedSubclasses`;
SRC_UAKOO = `${SRC_UA_PREFIX}KitsOfOld`;
SRC_UABBC = `${SRC_UA_PREFIX}BardBardColleges`;
SRC_UACDD = `${SRC_UA_PREFIX}ClericDivineDomains`;
SRC_UAD = `${SRC_UA_PREFIX}Druid`;
SRC_UARCO = `${SRC_UA_PREFIX}RevisedClassOptions`;
SRC_UAF = `${SRC_UA_PREFIX}Fighter`;
SRC_UAM = `${SRC_UA_PREFIX}Monk`;
SRC_UAP = `${SRC_UA_PREFIX}Paladin`;
SRC_UAMC = `${SRC_UA_PREFIX}ModifyingClasses`;
SRC_UAS = `${SRC_UA_PREFIX}Sorcerer`;
SRC_UAWAW = `${SRC_UA_PREFIX}WarlockAndWizard`;
SRC_UATF = `${SRC_UA_PREFIX}TheFaithful`;
SRC_UAWR = `${SRC_UA_PREFIX}WizardRevisited`;
SRC_UAESR = `${SRC_UA_PREFIX}ElfSubraces`;
SRC_UAMAC = `${SRC_UA_PREFIX}MassCombat`;
SRC_UA3PE = `${SRC_UA_PREFIX}ThreePillarExperience`;
SRC_UAGHI = `${SRC_UA_PREFIX}GreyhawkInitiative`;
SRC_UATSC = `${SRC_UA_PREFIX}ThreeSubclasses`;
SRC_UAOD = `${SRC_UA_PREFIX}OrderDomain`;
SRC_UACAM = `${SRC_UA_PREFIX}CentaursMinotaurs`;
SRC_UAGSS = `${SRC_UA_PREFIX}GiantSoulSorcerer`;
SRC_UARoE = `${SRC_UA_PREFIX}RacesOfEberron`;
SRC_UARoR = `${SRC_UA_PREFIX}RacesOfRavnica`;
SRC_UAWGE = `${SRC_UA_PREFIX}WGE`;
SRC_UAOSS = `${SRC_UA_PREFIX}OfShipsAndSea`;
SRC_UASIK = `${SRC_UA_PREFIX}Sidekicks`;
SRC_UAAR = `${SRC_UA_PREFIX}ArtificerRevisited`;
SRC_UABAM = `${SRC_UA_PREFIX}BarbarianAndMonk`;
SRC_UASAW = `${SRC_UA_PREFIX}SorcererAndWarlock`;
SRC_UABAP = `${SRC_UA_PREFIX}BardAndPaladin`;
SRC_UACDW = `${SRC_UA_PREFIX}ClericDruidWizard`;
SRC_UAFRR = `${SRC_UA_PREFIX}FighterRangerRogue`;
SRC_UACFV = `${SRC_UA_PREFIX}ClassFeatureVariants`;
SRC_UAFRW = `${SRC_UA_PREFIX}FighterRogueWizard`;
SRC_UAPCRM = `${SRC_UA_PREFIX}PrestigeClassesRunMagic`;
SRC_UAR = `${SRC_UA_PREFIX}Ranger`;
SRC_UA2020SC1 = `${SRC_UA_PREFIX}2020SubclassesPt1`;
SRC_UA2020SC2 = `${SRC_UA_PREFIX}2020SubclassesPt2`;
SRC_UA2020SC3 = `${SRC_UA_PREFIX}2020SubclassesPt3`;
SRC_UA2020SC4 = `${SRC_UA_PREFIX}2020SubclassesPt4`;
SRC_UA2020SC5 = `${SRC_UA_PREFIX}2020SubclassesPt5`;
SRC_UA2020SMT = `${SRC_UA_PREFIX}2020SpellsAndMagicTattoos`;
SRC_UA2020POR = `${SRC_UA_PREFIX}2020PsionicOptionsRevisited`;
SRC_UA2020SCR = `${SRC_UA_PREFIX}2020SubclassesRevisited`;
SRC_UA2020F = `${SRC_UA_PREFIX}2020Feats`;
SRC_UA2021GL = `${SRC_UA_PREFIX}2021GothicLineages`;
SRC_UA2021FF = `${SRC_UA_PREFIX}2021FolkOfTheFeywild`;
SRC_UA2021DO = `${SRC_UA_PREFIX}2021DraconicOptions`;
SRC_UA2021MoS = `${SRC_UA_PREFIX}2021MagesOfStrixhaven`;
SRC_UA2021TotM = `${SRC_UA_PREFIX}2021TravelersOfTheMultiverse`;

SRC_3PP_SUFFIX = " 3pp";

AL_PREFIX = "Adventurers League: ";
AL_PREFIX_SHORT = "AL: ";
PS_PREFIX = "Plane Shift: ";
PS_PREFIX_SHORT = "PS: ";
UA_PREFIX = "Unearthed Arcana: ";
UA_PREFIX_SHORT = "UA: ";
TftYP_NAME = "Tales from the Yawning Portal";
AitFR_NAME = "Adventures in the Forgotten Realms";

Parser.SOURCE_JSON_TO_FULL = {};
Parser.SOURCE_JSON_TO_FULL[SRC_CoS] = "Curse of Strahd";
Parser.SOURCE_JSON_TO_FULL[SRC_DMG] = "Dungeon Master's Guide";
Parser.SOURCE_JSON_TO_FULL[SRC_EEPC] = "Elemental Evil Player's Companion";
Parser.SOURCE_JSON_TO_FULL[SRC_EET] = "Elemental Evil: Trinkets";
Parser.SOURCE_JSON_TO_FULL[SRC_HotDQ] = "Hoard of the Dragon Queen";
Parser.SOURCE_JSON_TO_FULL[SRC_LMoP] = "Lost Mine of Phandelver";
Parser.SOURCE_JSON_TO_FULL[SRC_MM] = "Monster Manual";
Parser.SOURCE_JSON_TO_FULL[SRC_OotA] = "Out of the Abyss";
Parser.SOURCE_JSON_TO_FULL[SRC_PHB] = "Player's Handbook";
Parser.SOURCE_JSON_TO_FULL[SRC_PotA] = "Princes of the Apocalypse";
Parser.SOURCE_JSON_TO_FULL[SRC_RoT] = "The Rise of Tiamat";
Parser.SOURCE_JSON_TO_FULL[SRC_RoTOS] = "The Rise of Tiamat Online Supplement";
Parser.SOURCE_JSON_TO_FULL[SRC_SCAG] = "Sword Coast Adventurer's Guide";
Parser.SOURCE_JSON_TO_FULL[SRC_SKT] = "Storm King's Thunder";
Parser.SOURCE_JSON_TO_FULL[SRC_ToA] = "Tomb of Annihilation";
Parser.SOURCE_JSON_TO_FULL[SRC_TLK] = "The Lost Kenku";
Parser.SOURCE_JSON_TO_FULL[SRC_ToD] = "Tyranny of Dragons";
Parser.SOURCE_JSON_TO_FULL[SRC_TTP] = "The Tortle Package";
Parser.SOURCE_JSON_TO_FULL[SRC_TYP] = TftYP_NAME;
Parser.SOURCE_JSON_TO_FULL[SRC_TYP_AtG] = `${TftYP_NAME}: Against the Giants`;
Parser.SOURCE_JSON_TO_FULL[SRC_TYP_DiT] = `${TftYP_NAME}: Dead in Thay`;
Parser.SOURCE_JSON_TO_FULL[SRC_TYP_TFoF] = `${TftYP_NAME}: The Forge of Fury`;
Parser.SOURCE_JSON_TO_FULL[SRC_TYP_THSoT] = `${TftYP_NAME}: The Hidden Shrine of Tamoachan`;
Parser.SOURCE_JSON_TO_FULL[SRC_TYP_TSC] = `${TftYP_NAME}: The Sunless Citadel`;
Parser.SOURCE_JSON_TO_FULL[SRC_TYP_ToH] = `${TftYP_NAME}: Tomb of Horrors`;
Parser.SOURCE_JSON_TO_FULL[SRC_TYP_WPM] = `${TftYP_NAME}: White Plume Mountain`;
Parser.SOURCE_JSON_TO_FULL[SRC_VGM] = "Volo's Guide to Monsters";
Parser.SOURCE_JSON_TO_FULL[SRC_XGE] = "Xanathar's Guide to Everything";
Parser.SOURCE_JSON_TO_FULL[SRC_OGA] = "One Grung Above";
Parser.SOURCE_JSON_TO_FULL[SRC_MTF] = "Mordenkainen's Tome of Foes";
Parser.SOURCE_JSON_TO_FULL[SRC_WDH] = "Waterdeep: Dragon Heist";
Parser.SOURCE_JSON_TO_FULL[SRC_WDMM] = "Waterdeep: Dungeon of the Mad Mage";
Parser.SOURCE_JSON_TO_FULL[SRC_GGR] = "Guildmasters' Guide to Ravnica";
Parser.SOURCE_JSON_TO_FULL[SRC_KKW] = "Krenko's Way";
Parser.SOURCE_JSON_TO_FULL[SRC_LLK] = "Lost Laboratory of Kwalish";
Parser.SOURCE_JSON_TO_FULL[SRC_AZfyT] = "A Zib for your Thoughts";
Parser.SOURCE_JSON_TO_FULL[SRC_GoS] = "Ghosts of Saltmarsh";
Parser.SOURCE_JSON_TO_FULL[SRC_AI] = "Acquisitions Incorporated";
Parser.SOURCE_JSON_TO_FULL[SRC_OoW] = "The Orrery of the Wanderer";
Parser.SOURCE_JSON_TO_FULL[SRC_ESK] = "Essentials Kit";
Parser.SOURCE_JSON_TO_FULL[SRC_DIP] = "Dragon of Icespire Peak";
Parser.SOURCE_JSON_TO_FULL[SRC_HftT] = "Hunt for the Thessalhydra";
Parser.SOURCE_JSON_TO_FULL[SRC_DC] = "Divine Contention";
Parser.SOURCE_JSON_TO_FULL[SRC_SLW] = "Storm Lord's Wrath";
Parser.SOURCE_JSON_TO_FULL[SRC_SDW] = "Sleeping Dragon's Wake";
Parser.SOURCE_JSON_TO_FULL[SRC_BGDIA] = "Baldur's Gate: Descent Into Avernus";
Parser.SOURCE_JSON_TO_FULL[SRC_LR] = "Locathah Rising";
Parser.SOURCE_JSON_TO_FULL[SRC_AL] = "Adventurers' League";
Parser.SOURCE_JSON_TO_FULL[SRC_SAC] = "Sage Advice Compendium";
Parser.SOURCE_JSON_TO_FULL[SRC_ERLW] = "Eberron: Rising from the Last War";
Parser.SOURCE_JSON_TO_FULL[SRC_EFR] = "Eberron: Forgotten Relics";
Parser.SOURCE_JSON_TO_FULL[SRC_RMBRE] = "The Lost Dungeon of Rickedness: Big Rick Energy";
Parser.SOURCE_JSON_TO_FULL[SRC_RMR] = "Dungeons & Dragons vs. Rick and Morty: Basic Rules";
Parser.SOURCE_JSON_TO_FULL[SRC_MFF] = "Mordenkainen's Fiendish Folio";
Parser.SOURCE_JSON_TO_FULL[SRC_AWM] = "Adventure with Muk";
Parser.SOURCE_JSON_TO_FULL[SRC_IMR] = "Infernal Machine Rebuild";
Parser.SOURCE_JSON_TO_FULL[SRC_SADS] = "Sapphire Anniversary Dice Set";
Parser.SOURCE_JSON_TO_FULL[SRC_EGW] = "Explorer's Guide to Wildemount";
Parser.SOURCE_JSON_TO_FULL[SRC_EGW_ToR] = "Tide of Retribution";
Parser.SOURCE_JSON_TO_FULL[SRC_EGW_DD] = "Dangerous Designs";
Parser.SOURCE_JSON_TO_FULL[SRC_EGW_FS] = "Frozen Sick";
Parser.SOURCE_JSON_TO_FULL[SRC_EGW_US] = "Unwelcome Spirits";
Parser.SOURCE_JSON_TO_FULL[SRC_MOT] = "Mythic Odysseys of Theros";
Parser.SOURCE_JSON_TO_FULL[SRC_IDRotF] = "Icewind Dale: Rime of the Frostmaiden";
Parser.SOURCE_JSON_TO_FULL[SRC_TCE] = "Tasha's Cauldron of Everything";
Parser.SOURCE_JSON_TO_FULL[SRC_VRGR] = "Van Richten's Guide to Ravenloft";
Parser.SOURCE_JSON_TO_FULL[SRC_HoL] = "The House of Lament";
Parser.SOURCE_JSON_TO_FULL[SRC_RtG] = "Return to Glory";
Parser.SOURCE_JSON_TO_FULL[SRC_AitFR] = AitFR_NAME;
Parser.SOURCE_JSON_TO_FULL[SRC_AitFR_ISF] = `${AitFR_NAME}: In Scarlet Flames`;
Parser.SOURCE_JSON_TO_FULL[SRC_AitFR_THP] = `${AitFR_NAME}: The Hidden Page`;
Parser.SOURCE_JSON_TO_FULL[SRC_AitFR_AVT] = `${AitFR_NAME}: A Verdant Tomb`;
Parser.SOURCE_JSON_TO_FULL[SRC_AitFR_DN] = `${AitFR_NAME}: Deepest Night`;
Parser.SOURCE_JSON_TO_FULL[SRC_AitFR_FCD] = `${AitFR_NAME}: From Cyan Depths`;
Parser.SOURCE_JSON_TO_FULL[SRC_WBtW] = `The Wild Beyond the Witchlight`;
Parser.SOURCE_JSON_TO_FULL[SRC_DoD] = `Domains of Delight`;
Parser.SOURCE_JSON_TO_FULL[SRC_MaBJoV] = `Minsc and Boo's Journal of Villainy`;
Parser.SOURCE_JSON_TO_FULL[SRC_FTD] = `Fizban's Treasury of Dragons`;
Parser.SOURCE_JSON_TO_FULL[SRC_SCREEN] = "Dungeon Master's Screen";
Parser.SOURCE_JSON_TO_FULL[SRC_SCREEN_WILDERNESS_KIT] = "Dungeon Master's Screen: Wilderness Kit";
Parser.SOURCE_JSON_TO_FULL[SRC_HEROES_FEAST] = "Heroes' Feast";
Parser.SOURCE_JSON_TO_FULL[SRC_CM] = "Candlekeep Mysteries";
Parser.SOURCE_JSON_TO_FULL[SRC_ALCoS] = `${AL_PREFIX}Curse of Strahd`;
Parser.SOURCE_JSON_TO_FULL[SRC_ALEE] = `${AL_PREFIX}Elemental Evil`;
Parser.SOURCE_JSON_TO_FULL[SRC_ALRoD] = `${AL_PREFIX}Rage of Demons`;
Parser.SOURCE_JSON_TO_FULL[SRC_PSA] = `${PS_PREFIX}Amonkhet`;
Parser.SOURCE_JSON_TO_FULL[SRC_PSI] = `${PS_PREFIX}Innistrad`;
Parser.SOURCE_JSON_TO_FULL[SRC_PSK] = `${PS_PREFIX}Kaladesh`;
Parser.SOURCE_JSON_TO_FULL[SRC_PSZ] = `${PS_PREFIX}Zendikar`;
Parser.SOURCE_JSON_TO_FULL[SRC_PSX] = `${PS_PREFIX}Ixalan`;
Parser.SOURCE_JSON_TO_FULL[SRC_PSD] = `${PS_PREFIX}Dominaria`;
Parser.SOURCE_JSON_TO_FULL[SRC_XMtS] = `X Marks the Spot`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAA] = `${UA_PREFIX}Artificer`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAEAG] = `${UA_PREFIX}Eladrin and Gith`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAEBB] = `${UA_PREFIX}Eberron`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAFFR] = `${UA_PREFIX}Feats for Races`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAFFS] = `${UA_PREFIX}Feats for Skills`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAFO] = `${UA_PREFIX}Fiendish Options`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAFT] = `${UA_PREFIX}Feats`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAGH] = `${UA_PREFIX}Gothic Heroes`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAMDM] = `${UA_PREFIX}Modern Magic`;
Parser.SOURCE_JSON_TO_FULL[SRC_UASSP] = `${UA_PREFIX}Starter Spells`;
Parser.SOURCE_JSON_TO_FULL[SRC_UATMC] = `${UA_PREFIX}The Mystic Class`;
Parser.SOURCE_JSON_TO_FULL[SRC_UATOBM] = `${UA_PREFIX}That Old Black Magic`;
Parser.SOURCE_JSON_TO_FULL[SRC_UATRR] = `${UA_PREFIX}The Ranger, Revised`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAWA] = `${UA_PREFIX}Waterborne Adventures`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAVR] = `${UA_PREFIX}Variant Rules`;
Parser.SOURCE_JSON_TO_FULL[SRC_UALDR] = `${UA_PREFIX}Light, Dark, Underdark!`;
Parser.SOURCE_JSON_TO_FULL[SRC_UARAR] = `${UA_PREFIX}Ranger and Rogue`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAATOSC] = `${UA_PREFIX}A Trio of Subclasses`;
Parser.SOURCE_JSON_TO_FULL[SRC_UABPP] = `${UA_PREFIX}Barbarian Primal Paths`;
Parser.SOURCE_JSON_TO_FULL[SRC_UARSC] = `${UA_PREFIX}Revised Subclasses`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAKOO] = `${UA_PREFIX}Kits of Old`;
Parser.SOURCE_JSON_TO_FULL[SRC_UABBC] = `${UA_PREFIX}Bard: Bard Colleges`;
Parser.SOURCE_JSON_TO_FULL[SRC_UACDD] = `${UA_PREFIX}Cleric: Divine Domains`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAD] = `${UA_PREFIX}Druid`;
Parser.SOURCE_JSON_TO_FULL[SRC_UARCO] = `${UA_PREFIX}Revised Class Options`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAF] = `${UA_PREFIX}Fighter`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAM] = `${UA_PREFIX}Monk`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAP] = `${UA_PREFIX}Paladin`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAMC] = `${UA_PREFIX}Modifying Classes`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAS] = `${UA_PREFIX}Sorcerer`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAWAW] = `${UA_PREFIX}Warlock and Wizard`;
Parser.SOURCE_JSON_TO_FULL[SRC_UATF] = `${UA_PREFIX}The Faithful`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAWR] = `${UA_PREFIX}Wizard Revisited`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAESR] = `${UA_PREFIX}Elf Subraces`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAMAC] = `${UA_PREFIX}Mass Combat`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA3PE] = `${UA_PREFIX}Three-Pillar Experience`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAGHI] = `${UA_PREFIX}Greyhawk Initiative`;
Parser.SOURCE_JSON_TO_FULL[SRC_UATSC] = `${UA_PREFIX}Three Subclasses`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAOD] = `${UA_PREFIX}Order Domain`;
Parser.SOURCE_JSON_TO_FULL[SRC_UACAM] = `${UA_PREFIX}Centaurs and Minotaurs`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAGSS] = `${UA_PREFIX}Giant Soul Sorcerer`;
Parser.SOURCE_JSON_TO_FULL[SRC_UARoE] = `${UA_PREFIX}Races of Eberron`;
Parser.SOURCE_JSON_TO_FULL[SRC_UARoR] = `${UA_PREFIX}Races of Ravnica`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAWGE] = "Wayfinder's Guide to Eberron";
Parser.SOURCE_JSON_TO_FULL[SRC_UAOSS] = `${UA_PREFIX}Of Ships and the Sea`;
Parser.SOURCE_JSON_TO_FULL[SRC_UASIK] = `${UA_PREFIX}Sidekicks`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAAR] = `${UA_PREFIX}Artificer Revisited`;
Parser.SOURCE_JSON_TO_FULL[SRC_UABAM] = `${UA_PREFIX}Barbarian and Monk`;
Parser.SOURCE_JSON_TO_FULL[SRC_UASAW] = `${UA_PREFIX}Sorcerer and Warlock`;
Parser.SOURCE_JSON_TO_FULL[SRC_UABAP] = `${UA_PREFIX}Bard and Paladin`;
Parser.SOURCE_JSON_TO_FULL[SRC_UACDW] = `${UA_PREFIX}Cleric, Druid, and Wizard`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAFRR] = `${UA_PREFIX}Fighter, Ranger, and Rogue`;
Parser.SOURCE_JSON_TO_FULL[SRC_UACFV] = `${UA_PREFIX}Class Feature Variants`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAFRW] = `${UA_PREFIX}Fighter, Rogue, and Wizard`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAPCRM] = `${UA_PREFIX}Prestige Classes and Rune Magic`;
Parser.SOURCE_JSON_TO_FULL[SRC_UAR] = `${UA_PREFIX}Ranger`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020SC1] = `${UA_PREFIX}2020 Subclasses, Part 1`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020SC2] = `${UA_PREFIX}2020 Subclasses, Part 2`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020SC3] = `${UA_PREFIX}2020 Subclasses, Part 3`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020SC4] = `${UA_PREFIX}2020 Subclasses, Part 4`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020SC5] = `${UA_PREFIX}2020 Subclasses, Part 5`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020SMT] = `${UA_PREFIX}2020 Spells and Magic Tattoos`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020POR] = `${UA_PREFIX}2020 Psionic Options Revisited`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020SCR] = `${UA_PREFIX}2020 Subclasses Revisited`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2020F] = `${UA_PREFIX}2020 Feats`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2021GL] = `${UA_PREFIX}2021 Gothic Lineages`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2021FF] = `${UA_PREFIX}2021 Folk of the Feywild`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2021DO] = `${UA_PREFIX}2021 Draconic Options`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2021MoS] = `${UA_PREFIX}2021 Mages of Strixhaven`;
Parser.SOURCE_JSON_TO_FULL[SRC_UA2021TotM] = `${UA_PREFIX}2021 Travelers of the Multiverse`;

Parser.SOURCE_JSON_TO_ABV = {};
Parser.SOURCE_JSON_TO_ABV[SRC_CoS] = "CoS";
Parser.SOURCE_JSON_TO_ABV[SRC_DMG] = "DMG";
Parser.SOURCE_JSON_TO_ABV[SRC_EEPC] = "EEPC";
Parser.SOURCE_JSON_TO_ABV[SRC_EET] = "EET";
Parser.SOURCE_JSON_TO_ABV[SRC_HotDQ] = "HotDQ";
Parser.SOURCE_JSON_TO_ABV[SRC_LMoP] = "LMoP";
Parser.SOURCE_JSON_TO_ABV[SRC_MM] = "MM";
Parser.SOURCE_JSON_TO_ABV[SRC_OotA] = "OotA";
Parser.SOURCE_JSON_TO_ABV[SRC_PHB] = "PHB";
Parser.SOURCE_JSON_TO_ABV[SRC_PotA] = "PotA";
Parser.SOURCE_JSON_TO_ABV[SRC_RoT] = "RoT";
Parser.SOURCE_JSON_TO_ABV[SRC_RoTOS] = "RoTOS";
Parser.SOURCE_JSON_TO_ABV[SRC_SCAG] = "SCAG";
Parser.SOURCE_JSON_TO_ABV[SRC_SKT] = "SKT";
Parser.SOURCE_JSON_TO_ABV[SRC_ToA] = "ToA";
Parser.SOURCE_JSON_TO_ABV[SRC_TLK] = "TLK";
Parser.SOURCE_JSON_TO_ABV[SRC_ToD] = "ToD";
Parser.SOURCE_JSON_TO_ABV[SRC_TTP] = "TTP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP_AtG] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP_DiT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP_TFoF] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP_THSoT] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP_TSC] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP_ToH] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_TYP_WPM] = "TftYP";
Parser.SOURCE_JSON_TO_ABV[SRC_VGM] = "VGM";
Parser.SOURCE_JSON_TO_ABV[SRC_XGE] = "XGE";
Parser.SOURCE_JSON_TO_ABV[SRC_OGA] = "OGA";
Parser.SOURCE_JSON_TO_ABV[SRC_MTF] = "MTF";
Parser.SOURCE_JSON_TO_ABV[SRC_WDH] = "WDH";
Parser.SOURCE_JSON_TO_ABV[SRC_WDMM] = "WDMM";
Parser.SOURCE_JSON_TO_ABV[SRC_GGR] = "GGR";
Parser.SOURCE_JSON_TO_ABV[SRC_KKW] = "KKW";
Parser.SOURCE_JSON_TO_ABV[SRC_LLK] = "LLK";
Parser.SOURCE_JSON_TO_ABV[SRC_AZfyT] = "AZfyT";
Parser.SOURCE_JSON_TO_ABV[SRC_GoS] = "GoS";
Parser.SOURCE_JSON_TO_ABV[SRC_AI] = "AI";
Parser.SOURCE_JSON_TO_ABV[SRC_OoW] = "OoW";
Parser.SOURCE_JSON_TO_ABV[SRC_ESK] = "ESK";
Parser.SOURCE_JSON_TO_ABV[SRC_DIP] = "DIP";
Parser.SOURCE_JSON_TO_ABV[SRC_HftT] = "HftT";
Parser.SOURCE_JSON_TO_ABV[SRC_DC] = "DC";
Parser.SOURCE_JSON_TO_ABV[SRC_SLW] = "SLW";
Parser.SOURCE_JSON_TO_ABV[SRC_SDW] = "SDW";
Parser.SOURCE_JSON_TO_ABV[SRC_BGDIA] = "BGDIA";
Parser.SOURCE_JSON_TO_ABV[SRC_LR] = "LR";
Parser.SOURCE_JSON_TO_ABV[SRC_AL] = "AL";
Parser.SOURCE_JSON_TO_ABV[SRC_SAC] = "SAC";
Parser.SOURCE_JSON_TO_ABV[SRC_ERLW] = "ERLW";
Parser.SOURCE_JSON_TO_ABV[SRC_EFR] = "EFR";
Parser.SOURCE_JSON_TO_ABV[SRC_RMBRE] = "RMBRE";
Parser.SOURCE_JSON_TO_ABV[SRC_RMR] = "RMR";
Parser.SOURCE_JSON_TO_ABV[SRC_MFF] = "MFF";
Parser.SOURCE_JSON_TO_ABV[SRC_AWM] = "AWM";
Parser.SOURCE_JSON_TO_ABV[SRC_IMR] = "IMR";
Parser.SOURCE_JSON_TO_ABV[SRC_SADS] = "SADS";
Parser.SOURCE_JSON_TO_ABV[SRC_EGW] = "EGW";
Parser.SOURCE_JSON_TO_ABV[SRC_EGW_ToR] = "ToR";
Parser.SOURCE_JSON_TO_ABV[SRC_EGW_DD] = "DD";
Parser.SOURCE_JSON_TO_ABV[SRC_EGW_FS] = "FS";
Parser.SOURCE_JSON_TO_ABV[SRC_EGW_US] = "US";
Parser.SOURCE_JSON_TO_ABV[SRC_MOT] = "MOT";
Parser.SOURCE_JSON_TO_ABV[SRC_IDRotF] = "IDRotF";
Parser.SOURCE_JSON_TO_ABV[SRC_TCE] = "TCE";
Parser.SOURCE_JSON_TO_ABV[SRC_VRGR] = "VRGR";
Parser.SOURCE_JSON_TO_ABV[SRC_HoL] = "HoL";
Parser.SOURCE_JSON_TO_ABV[SRC_RtG] = "RtG";
Parser.SOURCE_JSON_TO_ABV[SRC_AitFR] = "AitFR";
Parser.SOURCE_JSON_TO_ABV[SRC_AitFR_ISF] = "AitFR-ISF";
Parser.SOURCE_JSON_TO_ABV[SRC_AitFR_THP] = "AitFR-THP";
Parser.SOURCE_JSON_TO_ABV[SRC_AitFR_AVT] = "AitFR-AVT";
Parser.SOURCE_JSON_TO_ABV[SRC_AitFR_DN] = "AitFR-DN";
Parser.SOURCE_JSON_TO_ABV[SRC_AitFR_FCD] = "AitFR-FCD";
Parser.SOURCE_JSON_TO_ABV[SRC_WBtW] = "WBtW";
Parser.SOURCE_JSON_TO_ABV[SRC_DoD] = "DoD";
Parser.SOURCE_JSON_TO_ABV[SRC_MaBJoV] = "MaBJoV";
Parser.SOURCE_JSON_TO_ABV[SRC_FTD] = "FTD";
Parser.SOURCE_JSON_TO_ABV[SRC_SCREEN] = "Screen";
Parser.SOURCE_JSON_TO_ABV[SRC_SCREEN_WILDERNESS_KIT] = "Wild";
Parser.SOURCE_JSON_TO_ABV[SRC_HEROES_FEAST] = "HF";
Parser.SOURCE_JSON_TO_ABV[SRC_CM] = "CM";
Parser.SOURCE_JSON_TO_ABV[SRC_ALCoS] = "ALCoS";
Parser.SOURCE_JSON_TO_ABV[SRC_ALEE] = "ALEE";
Parser.SOURCE_JSON_TO_ABV[SRC_ALRoD] = "ALRoD";
Parser.SOURCE_JSON_TO_ABV[SRC_PSA] = "PSA";
Parser.SOURCE_JSON_TO_ABV[SRC_PSI] = "PSI";
Parser.SOURCE_JSON_TO_ABV[SRC_PSK] = "PSK";
Parser.SOURCE_JSON_TO_ABV[SRC_PSZ] = "PSZ";
Parser.SOURCE_JSON_TO_ABV[SRC_PSX] = "PSX";
Parser.SOURCE_JSON_TO_ABV[SRC_PSD] = "PSD";
Parser.SOURCE_JSON_TO_ABV[SRC_XMtS] = "XMtS";
Parser.SOURCE_JSON_TO_ABV[SRC_UAA] = "UAA";
Parser.SOURCE_JSON_TO_ABV[SRC_UAEAG] = "UAEaG";
Parser.SOURCE_JSON_TO_ABV[SRC_UAEBB] = "UAEB";
Parser.SOURCE_JSON_TO_ABV[SRC_UAFFR] = "UAFFR";
Parser.SOURCE_JSON_TO_ABV[SRC_UAFFS] = "UAFFS";
Parser.SOURCE_JSON_TO_ABV[SRC_UAFO] = "UAFO";
Parser.SOURCE_JSON_TO_ABV[SRC_UAFT] = "UAFT";
Parser.SOURCE_JSON_TO_ABV[SRC_UAGH] = "UAGH";
Parser.SOURCE_JSON_TO_ABV[SRC_UAMDM] = "UAMM";
Parser.SOURCE_JSON_TO_ABV[SRC_UASSP] = "UASS";
Parser.SOURCE_JSON_TO_ABV[SRC_UATMC] = "UAMy";
Parser.SOURCE_JSON_TO_ABV[SRC_UATOBM] = "UAOBM";
Parser.SOURCE_JSON_TO_ABV[SRC_UATRR] = "UATRR";
Parser.SOURCE_JSON_TO_ABV[SRC_UAWA] = "UAWA";
Parser.SOURCE_JSON_TO_ABV[SRC_UAVR] = "UAVR";
Parser.SOURCE_JSON_TO_ABV[SRC_UALDR] = "UALDU";
Parser.SOURCE_JSON_TO_ABV[SRC_UARAR] = "UARAR";
Parser.SOURCE_JSON_TO_ABV[SRC_UAATOSC] = "UAATOSC";
Parser.SOURCE_JSON_TO_ABV[SRC_UABPP] = "UABPP";
Parser.SOURCE_JSON_TO_ABV[SRC_UARSC] = "UARSC";
Parser.SOURCE_JSON_TO_ABV[SRC_UAKOO] = "UAKoO";
Parser.SOURCE_JSON_TO_ABV[SRC_UABBC] = "UABBC";
Parser.SOURCE_JSON_TO_ABV[SRC_UACDD] = "UACDD";
Parser.SOURCE_JSON_TO_ABV[SRC_UAD] = "UAD";
Parser.SOURCE_JSON_TO_ABV[SRC_UARCO] = "UARCO";
Parser.SOURCE_JSON_TO_ABV[SRC_UAF] = "UAF";
Parser.SOURCE_JSON_TO_ABV[SRC_UAM] = "UAMk";
Parser.SOURCE_JSON_TO_ABV[SRC_UAP] = "UAP";
Parser.SOURCE_JSON_TO_ABV[SRC_UAMC] = "UAMC";
Parser.SOURCE_JSON_TO_ABV[SRC_UAS] = "UAS";
Parser.SOURCE_JSON_TO_ABV[SRC_UAWAW] = "UAWAW";
Parser.SOURCE_JSON_TO_ABV[SRC_UATF] = "UATF";
Parser.SOURCE_JSON_TO_ABV[SRC_UAWR] = "UAWR";
Parser.SOURCE_JSON_TO_ABV[SRC_UAESR] = "UAESR";
Parser.SOURCE_JSON_TO_ABV[SRC_UAMAC] = "UAMAC";
Parser.SOURCE_JSON_TO_ABV[SRC_UA3PE] = "UA3PE";
Parser.SOURCE_JSON_TO_ABV[SRC_UAGHI] = "UAGHI";
Parser.SOURCE_JSON_TO_ABV[SRC_UATSC] = "UATSC";
Parser.SOURCE_JSON_TO_ABV[SRC_UAOD] = "UAOD";
Parser.SOURCE_JSON_TO_ABV[SRC_UACAM] = "UACAM";
Parser.SOURCE_JSON_TO_ABV[SRC_UAGSS] = "UAGSS";
Parser.SOURCE_JSON_TO_ABV[SRC_UARoE] = "UARoE";
Parser.SOURCE_JSON_TO_ABV[SRC_UARoR] = "UARoR";
Parser.SOURCE_JSON_TO_ABV[SRC_UAWGE] = "WGE";
Parser.SOURCE_JSON_TO_ABV[SRC_UAOSS] = "UAOSS";
Parser.SOURCE_JSON_TO_ABV[SRC_UASIK] = "UASIK";
Parser.SOURCE_JSON_TO_ABV[SRC_UAAR] = "UAAR";
Parser.SOURCE_JSON_TO_ABV[SRC_UABAM] = "UABAM";
Parser.SOURCE_JSON_TO_ABV[SRC_UASAW] = "UASAW";
Parser.SOURCE_JSON_TO_ABV[SRC_UABAP] = "UABAP";
Parser.SOURCE_JSON_TO_ABV[SRC_UACDW] = "UACDW";
Parser.SOURCE_JSON_TO_ABV[SRC_UAFRR] = "UAFRR";
Parser.SOURCE_JSON_TO_ABV[SRC_UACFV] = "UACFV";
Parser.SOURCE_JSON_TO_ABV[SRC_UAFRW] = "UAFRW";
Parser.SOURCE_JSON_TO_ABV[SRC_UAPCRM] = "UAPCRM";
Parser.SOURCE_JSON_TO_ABV[SRC_UAR] = "UAR";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020SC1] = "UA20S1";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020SC2] = "UA20S2";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020SC3] = "UA20S3";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020SC4] = "UA20S4";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020SC5] = "UA20S5";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020SMT] = "UA20SMT";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020POR] = "UA20POR";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020SCR] = "UA20SCR";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2020F] = "UA20F";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2021GL] = "UA21GL";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2021FF] = "UA21FF";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2021DO] = "UA21DO";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2021MoS] = "UA21MoS";
Parser.SOURCE_JSON_TO_ABV[SRC_UA2021TotM] = "UA21TotM";

Parser.SOURCE_JSON_TO_DATE = {};
Parser.SOURCE_JSON_TO_DATE[SRC_CoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[SRC_DMG] = "2014-12-09";
Parser.SOURCE_JSON_TO_DATE[SRC_EEPC] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[SRC_EET] = "2015-03-10";
Parser.SOURCE_JSON_TO_DATE[SRC_HotDQ] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[SRC_LMoP] = "2014-07-15";
Parser.SOURCE_JSON_TO_DATE[SRC_MM] = "2014-09-30";
Parser.SOURCE_JSON_TO_DATE[SRC_OotA] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[SRC_PHB] = "2014-08-19";
Parser.SOURCE_JSON_TO_DATE[SRC_PotA] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[SRC_RoT] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[SRC_RoTOS] = "2014-11-04";
Parser.SOURCE_JSON_TO_DATE[SRC_SCAG] = "2015-11-03";
Parser.SOURCE_JSON_TO_DATE[SRC_SKT] = "2016-09-06";
Parser.SOURCE_JSON_TO_DATE[SRC_ToA] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[SRC_TLK] = "2017-11-28";
Parser.SOURCE_JSON_TO_DATE[SRC_ToD] = "2019-10-22";
Parser.SOURCE_JSON_TO_DATE[SRC_TTP] = "2017-09-19";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP_AtG] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP_DiT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP_TFoF] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP_THSoT] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP_TSC] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP_ToH] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_TYP_WPM] = "2017-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_VGM] = "2016-11-15";
Parser.SOURCE_JSON_TO_DATE[SRC_XGE] = "2017-11-21";
Parser.SOURCE_JSON_TO_DATE[SRC_OGA] = "2017-10-11";
Parser.SOURCE_JSON_TO_DATE[SRC_MTF] = "2018-05-29";
Parser.SOURCE_JSON_TO_DATE[SRC_WDH] = "2018-09-18";
Parser.SOURCE_JSON_TO_DATE[SRC_WDMM] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[SRC_GGR] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[SRC_KKW] = "2018-11-20";
Parser.SOURCE_JSON_TO_DATE[SRC_LLK] = "2018-11-10";
Parser.SOURCE_JSON_TO_DATE[SRC_AZfyT] = "2019-03-05";
Parser.SOURCE_JSON_TO_DATE[SRC_GoS] = "2019-05-21";
Parser.SOURCE_JSON_TO_DATE[SRC_AI] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[SRC_OoW] = "2019-06-18";
Parser.SOURCE_JSON_TO_DATE[SRC_ESK] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[SRC_DIP] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[SRC_HftT] = "2019-05-01";
Parser.SOURCE_JSON_TO_DATE[SRC_DC] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[SRC_SLW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[SRC_SDW] = "2019-06-24";
Parser.SOURCE_JSON_TO_DATE[SRC_BGDIA] = "2019-09-17";
Parser.SOURCE_JSON_TO_DATE[SRC_LR] = "2019-09-19";
Parser.SOURCE_JSON_TO_DATE[SRC_SAC] = "2019-01-31";
Parser.SOURCE_JSON_TO_DATE[SRC_ERLW] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[SRC_EFR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[SRC_RMBRE] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[SRC_RMR] = "2019-11-19";
Parser.SOURCE_JSON_TO_DATE[SRC_MFF] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[SRC_AWM] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[SRC_IMR] = "2019-11-12";
Parser.SOURCE_JSON_TO_DATE[SRC_SADS] = "2019-12-12";
Parser.SOURCE_JSON_TO_DATE[SRC_EGW] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[SRC_EGW_ToR] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[SRC_EGW_DD] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[SRC_EGW_FS] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[SRC_EGW_US] = "2020-03-17";
Parser.SOURCE_JSON_TO_DATE[SRC_MOT] = "2020-06-02";
Parser.SOURCE_JSON_TO_DATE[SRC_IDRotF] = "2020-09-15";
Parser.SOURCE_JSON_TO_DATE[SRC_TCE] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[SRC_VRGR] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[SRC_HoL] = "2021-05-18";
Parser.SOURCE_JSON_TO_DATE[SRC_RtG] = "2021-05-21";
Parser.SOURCE_JSON_TO_DATE[SRC_AitFR] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[SRC_AitFR_ISF] = "2021-06-30";
Parser.SOURCE_JSON_TO_DATE[SRC_AitFR_THP] = "2021-07-07";
Parser.SOURCE_JSON_TO_DATE[SRC_AitFR_AVT] = "2021-07-14";
Parser.SOURCE_JSON_TO_DATE[SRC_AitFR_DN] = "2021-07-21";
Parser.SOURCE_JSON_TO_DATE[SRC_AitFR_FCD] = "2021-07-28";
Parser.SOURCE_JSON_TO_DATE[SRC_WBtW] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[SRC_DoD] = "2021-09-21";
Parser.SOURCE_JSON_TO_DATE[SRC_MaBJoV] = "2021-10-05";
Parser.SOURCE_JSON_TO_DATE[SRC_FTD] = "2021-11-26";
Parser.SOURCE_JSON_TO_DATE[SRC_SCREEN] = "2015-01-20";
Parser.SOURCE_JSON_TO_DATE[SRC_SCREEN_WILDERNESS_KIT] = "2020-11-17";
Parser.SOURCE_JSON_TO_DATE[SRC_HEROES_FEAST] = "2020-10-27";
Parser.SOURCE_JSON_TO_DATE[SRC_CM] = "2021-03-16";
Parser.SOURCE_JSON_TO_DATE[SRC_ALCoS] = "2016-03-15";
Parser.SOURCE_JSON_TO_DATE[SRC_ALEE] = "2015-04-07";
Parser.SOURCE_JSON_TO_DATE[SRC_ALRoD] = "2015-09-15";
Parser.SOURCE_JSON_TO_DATE[SRC_PSA] = "2017-07-06";
Parser.SOURCE_JSON_TO_DATE[SRC_PSI] = "2016-07-12";
Parser.SOURCE_JSON_TO_DATE[SRC_PSK] = "2017-02-16";
Parser.SOURCE_JSON_TO_DATE[SRC_PSZ] = "2016-04-27";
Parser.SOURCE_JSON_TO_DATE[SRC_PSX] = "2018-01-09";
Parser.SOURCE_JSON_TO_DATE[SRC_PSD] = "2018-07-31";
Parser.SOURCE_JSON_TO_DATE[SRC_XMtS] = "2017-12-11";
Parser.SOURCE_JSON_TO_DATE[SRC_UAEBB] = "2015-02-02";
Parser.SOURCE_JSON_TO_DATE[SRC_UAA] = "2017-01-09";
Parser.SOURCE_JSON_TO_DATE[SRC_UAEAG] = "2017-09-11";
Parser.SOURCE_JSON_TO_DATE[SRC_UAFFR] = "2017-04-24";
Parser.SOURCE_JSON_TO_DATE[SRC_UAFFS] = "2017-04-17";
Parser.SOURCE_JSON_TO_DATE[SRC_UAFO] = "2017-10-09";
Parser.SOURCE_JSON_TO_DATE[SRC_UAFT] = "2016-06-06";
Parser.SOURCE_JSON_TO_DATE[SRC_UAGH] = "2016-04-04";
Parser.SOURCE_JSON_TO_DATE[SRC_UAMDM] = "2015-08-03";
Parser.SOURCE_JSON_TO_DATE[SRC_UASSP] = "2017-04-03";
Parser.SOURCE_JSON_TO_DATE[SRC_UATMC] = "2017-03-13";
Parser.SOURCE_JSON_TO_DATE[SRC_UATOBM] = "2015-12-07";
Parser.SOURCE_JSON_TO_DATE[SRC_UATRR] = "2016-09-12";
Parser.SOURCE_JSON_TO_DATE[SRC_UAWA] = "2015-05-04";
Parser.SOURCE_JSON_TO_DATE[SRC_UAVR] = "2015-06-08";
Parser.SOURCE_JSON_TO_DATE[SRC_UALDR] = "2015-11-02";
Parser.SOURCE_JSON_TO_DATE[SRC_UARAR] = "2017-01-16";
Parser.SOURCE_JSON_TO_DATE[SRC_UAATOSC] = "2017-03-27";
Parser.SOURCE_JSON_TO_DATE[SRC_UABPP] = "2016-11-07";
Parser.SOURCE_JSON_TO_DATE[SRC_UARSC] = "2017-05-01";
Parser.SOURCE_JSON_TO_DATE[SRC_UAKOO] = "2016-01-04";
Parser.SOURCE_JSON_TO_DATE[SRC_UABBC] = "2016-11-14";
Parser.SOURCE_JSON_TO_DATE[SRC_UACDD] = "2016-11-12";
Parser.SOURCE_JSON_TO_DATE[SRC_UAD] = "2016-11-28";
Parser.SOURCE_JSON_TO_DATE[SRC_UARCO] = "2017-06-05";
Parser.SOURCE_JSON_TO_DATE[SRC_UAF] = "2016-12-5";
Parser.SOURCE_JSON_TO_DATE[SRC_UAM] = "2016-12-12";
Parser.SOURCE_JSON_TO_DATE[SRC_UAP] = "2016-12-19";
Parser.SOURCE_JSON_TO_DATE[SRC_UAMC] = "2015-04-06";
Parser.SOURCE_JSON_TO_DATE[SRC_UAS] = "2017-02-06";
Parser.SOURCE_JSON_TO_DATE[SRC_UAWAW] = "2017-02-13";
Parser.SOURCE_JSON_TO_DATE[SRC_UATF] = "2016-08-01";
Parser.SOURCE_JSON_TO_DATE[SRC_UAWR] = "2017-03-20";
Parser.SOURCE_JSON_TO_DATE[SRC_UAESR] = "2017-11-13";
Parser.SOURCE_JSON_TO_DATE[SRC_UAMAC] = "2017-02-21";
Parser.SOURCE_JSON_TO_DATE[SRC_UA3PE] = "2017-08-07";
Parser.SOURCE_JSON_TO_DATE[SRC_UAGHI] = "2017-07-10";
Parser.SOURCE_JSON_TO_DATE[SRC_UATSC] = "2018-01-08";
Parser.SOURCE_JSON_TO_DATE[SRC_UAOD] = "2018-04-09";
Parser.SOURCE_JSON_TO_DATE[SRC_UACAM] = "2018-05-14";
Parser.SOURCE_JSON_TO_DATE[SRC_UAGSS] = "2018-06-11";
Parser.SOURCE_JSON_TO_DATE[SRC_UARoE] = "2018-07-23";
Parser.SOURCE_JSON_TO_DATE[SRC_UARoR] = "2018-08-13";
Parser.SOURCE_JSON_TO_DATE[SRC_UAWGE] = "2018-07-23";
Parser.SOURCE_JSON_TO_DATE[SRC_UAOSS] = "2018-11-12";
Parser.SOURCE_JSON_TO_DATE[SRC_UASIK] = "2018-12-17";
Parser.SOURCE_JSON_TO_DATE[SRC_UAAR] = "2019-02-28";
Parser.SOURCE_JSON_TO_DATE[SRC_UABAM] = "2019-08-15";
Parser.SOURCE_JSON_TO_DATE[SRC_UASAW] = "2019-09-05";
Parser.SOURCE_JSON_TO_DATE[SRC_UABAP] = "2019-09-18";
Parser.SOURCE_JSON_TO_DATE[SRC_UACDW] = "2019-10-03";
Parser.SOURCE_JSON_TO_DATE[SRC_UAFRR] = "2019-10-17";
Parser.SOURCE_JSON_TO_DATE[SRC_UACFV] = "2019-11-04";
Parser.SOURCE_JSON_TO_DATE[SRC_UAFRW] = "2019-11-25";
Parser.SOURCE_JSON_TO_DATE[SRC_UAPCRM] = "2015-10-05";
Parser.SOURCE_JSON_TO_DATE[SRC_UAR] = "2015-09-09";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020SC1] = "2020-01-14";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020SC2] = "2020-02-04";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020SC3] = "2020-02-24";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020SC4] = "2020-08-05";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020SC5] = "2020-10-26";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020SMT] = "2020-03-26";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020POR] = "2020-04-14";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020SCR] = "2020-05-12";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2020F] = "2020-07-13";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2021GL] = "2020-01-26";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2021FF] = "2020-03-12";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2021DO] = "2021-04-14";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2021MoS] = "2021-06-08";
Parser.SOURCE_JSON_TO_DATE[SRC_UA2021TotM] = "2021-10-08";

Parser.SOURCES_ADVENTURES = new Set([
	SRC_LMoP,
	SRC_HotDQ,
	SRC_RoT,
	SRC_RoTOS,
	SRC_PotA,
	SRC_OotA,
	SRC_CoS,
	SRC_SKT,
	SRC_TYP,
	SRC_TYP_AtG,
	SRC_TYP_DiT,
	SRC_TYP_TFoF,
	SRC_TYP_THSoT,
	SRC_TYP_TSC,
	SRC_TYP_ToH,
	SRC_TYP_WPM,
	SRC_ToA,
	SRC_TLK,
	SRC_TTP,
	SRC_WDH,
	SRC_LLK,
	SRC_WDMM,
	SRC_KKW,
	SRC_AZfyT,
	SRC_GoS,
	SRC_HftT,
	SRC_OoW,
	SRC_DIP,
	SRC_SLW,
	SRC_SDW,
	SRC_DC,
	SRC_BGDIA,
	SRC_LR,
	SRC_EFR,
	SRC_RMBRE,
	SRC_IMR,
	SRC_EGW_ToR,
	SRC_EGW_DD,
	SRC_EGW_FS,
	SRC_EGW_US,
	SRC_IDRotF,
	SRC_CM,
	SRC_HoL,
	SRC_XMtS,
	SRC_RtG,
	SRC_AitFR,
	SRC_AitFR_ISF,
	SRC_AitFR_THP,
	SRC_AitFR_AVT,
	SRC_AitFR_DN,
	SRC_AitFR_FCD,
	SRC_WBtW,

	SRC_AWM,
]);
Parser.SOURCES_CORE_SUPPLEMENTS = new Set(Object.keys(Parser.SOURCE_JSON_TO_FULL).filter(it => !Parser.SOURCES_ADVENTURES.has(it)));
Parser.SOURCES_NON_STANDARD_WOTC = new Set([
	SRC_OGA,
	SRC_LLK,
	SRC_AZfyT,
	SRC_LR,
	SRC_TLK,
	SRC_TTP,
	SRC_AWM,
	SRC_IMR,
	SRC_SADS,
	SRC_MFF,
	SRC_XMtS,
	SRC_RtG,
	SRC_AitFR,
	SRC_AitFR_ISF,
	SRC_AitFR_THP,
	SRC_AitFR_AVT,
	SRC_AitFR_DN,
	SRC_AitFR_FCD,
	SRC_DoD,
	SRC_MaBJoV,
]);
// region Source categories

// An opinionated set of source that could be considered "core-core"
Parser.SOURCES_VANILLA = new Set([
	SRC_DMG,
	SRC_MM,
	SRC_PHB,
	SRC_SCAG,
	SRC_TTP,
	SRC_VGM,
	SRC_XGE,
	SRC_MTF,
	SRC_SAC,
	SRC_MFF,
	SRC_SADS,
	SRC_TCE,
	SRC_FTD,
	SRC_SCREEN,
	SRC_SCREEN_WILDERNESS_KIT,
]);

// Any opinionated set of sources that are """hilarious, dude"""
Parser.SOURCES_COMEDY = new Set([
	SRC_AI,
	SRC_OoW,
	SRC_RMR,
	SRC_RMBRE,
	SRC_HftT,
]);

// Any opinionated set of sources that are "other settings"
Parser.SOURCES_NON_FR = new Set([
	SRC_GGR,
	SRC_KKW,
	SRC_ERLW,
	SRC_EFR,
	SRC_UAWGE,
	SRC_EGW,
	SRC_EGW_ToR,
	SRC_EGW_DD,
	SRC_EGW_FS,
	SRC_EGW_US,
	SRC_MOT,
	SRC_XMtS,
	SRC_AZfyT,
]);

// endregion
Parser.SOURCES_AVAILABLE_DOCS_BOOK = {};
[
	SRC_PHB,
	SRC_MM,
	SRC_DMG,
	SRC_SCAG,
	SRC_VGM,
	SRC_OGA,
	SRC_XGE,
	SRC_MTF,
	SRC_GGR,
	SRC_AI,
	SRC_ERLW,
	SRC_RMR,
	SRC_EGW,
	SRC_MOT,
	SRC_TCE,
	SRC_VRGR,
	SRC_DoD,
	SRC_MaBJoV,
	SRC_FTD,
].forEach(src => {
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src] = src;
	Parser.SOURCES_AVAILABLE_DOCS_BOOK[src.toLowerCase()] = src;
});
Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE = {};
[
	SRC_LMoP,
	SRC_HotDQ,
	SRC_RoT,
	SRC_PotA,
	SRC_OotA,
	SRC_CoS,
	SRC_SKT,
	SRC_TYP_AtG,
	SRC_TYP_DiT,
	SRC_TYP_TFoF,
	SRC_TYP_THSoT,
	SRC_TYP_TSC,
	SRC_TYP_ToH,
	SRC_TYP_WPM,
	SRC_ToA,
	SRC_TLK,
	SRC_TTP,
	SRC_WDH,
	SRC_LLK,
	SRC_WDMM,
	SRC_KKW,
	SRC_AZfyT,
	SRC_GoS,
	SRC_HftT,
	SRC_OoW,
	SRC_DIP,
	SRC_SLW,
	SRC_SDW,
	SRC_DC,
	SRC_BGDIA,
	SRC_LR,
	SRC_EFR,
	SRC_RMBRE,
	SRC_IMR,
	SRC_EGW_ToR,
	SRC_EGW_DD,
	SRC_EGW_FS,
	SRC_EGW_US,
	SRC_IDRotF,
	SRC_CM,
	SRC_HoL,
	SRC_XMtS,
	SRC_RtG,
	SRC_AitFR_ISF,
	SRC_AitFR_THP,
	SRC_AitFR_AVT,
	SRC_AitFR_DN,
	SRC_AitFR_FCD,
	SRC_WBtW,
].forEach(src => {
	Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src] = src;
	Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[src.toLowerCase()] = src;
});

Parser.TAG_TO_DEFAULT_SOURCE = {
	"spell": SRC_PHB,
	"item": SRC_DMG,
	"class": SRC_PHB,
	"creature": SRC_MM,
	"condition": SRC_PHB,
	"disease": SRC_DMG,
	"status": SRC_DMG,
	"background": SRC_PHB,
	"race": SRC_PHB,
	"optfeature": SRC_PHB,
	"reward": SRC_DMG,
	"feat": SRC_PHB,
	"psionic": SRC_UATMC,
	"object": SRC_DMG,
	"cult": SRC_MTF,
	"boon": SRC_MTF,
	"trap": SRC_DMG,
	"hazard": SRC_DMG,
	"deity": SRC_PHB,
	"variantrule": SRC_DMG,
	"vehicle": SRC_GoS,
	"vehupgrade": SRC_GoS,
	"action": SRC_PHB,
	"classFeature": SRC_PHB,
	"subclassFeature": SRC_PHB,
	"table": SRC_DMG,
	"language": SRC_PHB,
	"charoption": SRC_MOT,
	"recipe": SRC_HEROES_FEAST,
	"itemEntry": SRC_DMG,
};
Parser.getTagSource = function (tag, source) {
	if (source && source.trim()) return source;

	tag = tag.trim();
	if (tag.startsWith("@")) tag = tag.slice(1);

	if (!Parser.TAG_TO_DEFAULT_SOURCE[tag]) throw new Error(`Unhandled tag "${tag}"`);
	return Parser.TAG_TO_DEFAULT_SOURCE[tag];
};

Parser.ITEM_TYPE_JSON_TO_ABV = {
	"A": "ammunition",
	"AF": "ammunition",
	"AT": "artisan's tools",
	"EM": "eldritch machine",
	"EXP": "explosive",
	"FD": "food and drink",
	"G": "adventuring gear",
	"GS": "gaming set",
	"HA": "heavy armor",
	"INS": "instrument",
	"LA": "light armor",
	"M": "melee weapon",
	"MA": "medium armor",
	"MNT": "mount",
	"MR": "master rune",
	"GV": "generic variant",
	"P": "potion",
	"R": "ranged weapon",
	"RD": "rod",
	"RG": "ring",
	"S": "shield",
	"SC": "scroll",
	"SCF": "spellcasting focus",
	"OTH": "other",
	"T": "tools",
	"TAH": "tack and harness",
	"TG": "trade good",
	"$": "treasure",
	"VEH": "vehicle (land)",
	"SHP": "vehicle (water)",
	"AIR": "vehicle (air)",
	"WD": "wand",
};

Parser.DMGTYPE_JSON_TO_FULL = {
	"A": "acid",
	"B": "bludgeoning",
	"C": "cold",
	"F": "fire",
	"O": "force",
	"L": "lightning",
	"N": "necrotic",
	"P": "piercing",
	"I": "poison",
	"Y": "psychic",
	"R": "radiant",
	"S": "slashing",
	"T": "thunder",
};

Parser.DMG_TYPES = ["acid", "bludgeoning", "cold", "fire", "force", "lightning", "necrotic", "piercing", "poison", "psychic", "radiant", "slashing", "thunder"];
Parser.CONDITIONS = ["blinded", "charmed", "deafened", "exhaustion", "frightened", "grappled", "incapacitated", "invisible", "paralyzed", "petrified", "poisoned", "prone", "restrained", "stunned", "unconscious"];

Parser.SKILL_JSON_TO_FULL = {
	"Acrobatics": [
		"Your Dexterity (Acrobatics) check covers your attempt to stay on your feet in a tricky situation, such as when you're trying to run across a sheet of ice, balance on a tightrope, or stay upright on a rocking ship's deck. The DM might also call for a Dexterity (Acrobatics) check to see if you can perform acrobatic stunts, including dives, rolls, somersaults, and flips.",
	],
	"Animal Handling": [
		"When there is any question whether you can calm down a domesticated animal, keep a mount from getting spooked, or intuit an animal's intentions, the DM might call for a Wisdom (Animal Handling) check. You also make a Wisdom (Animal Handling) check to control your mount when you attempt a risky maneuver.",
	],
	"Arcana": [
		"Your Intelligence (Arcana) check measures your ability to recall lore about spells, magic items, eldritch symbols, magical traditions, the planes of existence, and the inhabitants of those planes.",
	],
	"Athletics": [
		"Your Strength (Athletics) check covers difficult situations you encounter while climbing, jumping, or swimming. Examples include the following activities:",
		{
			"type": "list",
			"items": [
				"You attempt to climb a sheer or slippery cliff, avoid hazards while scaling a wall, or cling to a surface while something is trying to knock you off.",
				"You try to jump an unusually long distance or pull off a stunt mid jump.",
				"You struggle to swim or stay afloat in treacherous currents, storm-tossed waves, or areas of thick seaweed. Or another creature tries to push or pull you underwater or otherwise interfere with your swimming.",
			],
		},
	],
	"Deception": [
		"Your Charisma (Deception) check determines whether you can convincingly hide the truth, either verbally or through your actions. This deception can encompass everything from misleading others through ambiguity to telling outright lies. Typical situations include trying to fast-talk a guard, con a merchant, earn money through gambling, pass yourself off in a disguise, dull someone's suspicions with false assurances, or maintain a straight face while telling a blatant lie.",
	],
	"History": [
		"Your Intelligence (History) check measures your ability to recall lore about historical events, legendary people, ancient kingdoms, past disputes, recent wars, and lost civilizations.",
	],
	"Insight": [
		"Your Wisdom (Insight) check decides whether you can determine the true intentions of a creature, such as when searching out a lie or predicting someone's next move. Doing so involves gleaning clues from body language, speech habits, and changes in mannerisms.",
	],
	"Intimidation": [
		"When you attempt to influence someone through overt threats, hostile actions, and physical violence, the DM might ask you to make a Charisma (Intimidation) check. Examples include trying to pry information out of a prisoner, convincing street thugs to back down from a confrontation, or using the edge of a broken bottle to convince a sneering vizier to reconsider a decision.",
	],
	"Investigation": [
		"When you look around for clues and make deductions based on those clues, you make an Intelligence (Investigation) check. You might deduce the location of a hidden object, discern from the appearance of a wound what kind of weapon dealt it, or determine the weakest point in a tunnel that could cause it to collapse. Poring through ancient scrolls in search of a hidden fragment of knowledge might also call for an Intelligence (Investigation) check.",
	],
	"Medicine": [
		"A Wisdom (Medicine) check lets you try to stabilize a dying companion or diagnose an illness.",
	],
	"Nature": [
		"Your Intelligence (Nature) check measures your ability to recall lore about terrain, plants and animals, the weather, and natural cycles.",
	],
	"Perception": [
		"Your Wisdom (Perception) check lets you spot, hear, or otherwise detect the presence of something. It measures your general awareness of your surroundings and the keenness of your senses.", "For example, you might try to hear a conversation through a closed door, eavesdrop under an open window, or hear monsters moving stealthily in the forest. Or you might try to spot things that are obscured or easy to miss, whether they are orcs lying in ambush on a road, thugs hiding in the shadows of an alley, or candlelight under a closed secret door.",
	],
	"Performance": [
		"Your Charisma (Performance) check determines how well you can delight an audience with music, dance, acting, storytelling, or some other form of entertainment.",
	],
	"Persuasion": [
		"When you attempt to influence someone or a group of people with tact, social graces, or good nature, the DM might ask you to make a Charisma (Persuasion) check. Typically, you use persuasion when acting in good faith, to foster friendships, make cordial requests, or exhibit proper etiquette. Examples of persuading others include convincing a chamberlain to let your party see the king, negotiating peace between warring tribes, or inspiring a crowd of townsfolk.",
	],
	"Religion": [
		"Your Intelligence (Religion) check measures your ability to recall lore about deities, rites and prayers, religious hierarchies, holy symbols, and the practices of secret cults.",
	],
	"Sleight of Hand": [
		"Whenever you attempt an act of legerdemain or manual trickery, such as planting something on someone else or concealing an object on your person, make a Dexterity (Sleight of Hand) check. The DM might also call for a Dexterity (Sleight of Hand) check to determine whether you can lift a coin purse off another person or slip something out of another person's pocket.",
	],
	"Stealth": [
		"Make a Dexterity (Stealth) check when you attempt to conceal yourself from enemies, slink past guards, slip away without being noticed, or sneak up on someone without being seen or heard.",
	],
	"Survival": [
		"The DM might ask you to make a Wisdom (Survival) check to follow tracks, hunt wild game, guide your group through frozen wastelands, identify signs that owlbears live nearby, predict the weather, or avoid quicksand and other natural hazards.",
	],
};

Parser.SENSE_JSON_TO_FULL = {
	"blindsight": [
		"A creature with blindsight can perceive its surroundings without relying on sight, within a specific radius. Creatures without eyes, such as oozes, and creatures with echolocation or heightened senses, such as bats and true dragons, have this sense.",
	],
	"darkvision": [
		"Many creatures in fantasy gaming worlds, especially those that dwell underground, have darkvision. Within a specified range, a creature with darkvision can see in dim light as if it were bright light and in darkness as if it were dim light, so areas of darkness are only lightly obscured as far as that creature is concerned. However, the creature can't discern color in that darkness, only shades of gray.",
	],
	"tremorsense": [
		"A creature with tremorsense can detect and pinpoint the origin of vibrations within a specific radius, provided that the creature and the source of the vibrations are in contact with the same ground or substance. Tremorsense can't be used to detect flying or incorporeal creatures. Many burrowing creatures, such as ankhegs and umber hulks, have this special sense.",
	],
	"truesight": [
		"A creature with truesight can, out to a specific range, see in normal and magical darkness, see invisible creatures and objects, automatically detect visual illusions and succeed on saving throws against them, and perceives the original form of a shapechanger or a creature that is transformed by magic. Furthermore, the creature can see into the Ethereal Plane.",
	],
};

Parser.NUMBERS_ONES = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
Parser.NUMBERS_TENS = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];
Parser.NUMBERS_TEENS = ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];

}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_4 () {
// ************************************************************************* //
// Strict mode should not be used, as the roll20 script depends on this file //
// Do not use classes                                                        //
// ************************************************************************* //
IS_NODE = typeof module !== "undefined";
if (IS_NODE) require("./parser.js");

// in deployment, `IS_DEPLOYED = "<version number>";` should be set below.
IS_DEPLOYED = undefined;
VERSION_NUMBER = /* 5ETOOLS_VERSION__OPEN */"1.141.2"/* 5ETOOLS_VERSION__CLOSE */;
DEPLOYED_STATIC_ROOT = ""; // "https://static.5etools.com/"; // FIXME re-enable this when we have a CDN again
// for the roll20 script to set
IS_VTT = false;

IMGUR_CLIENT_ID = `abdea4de492d3b0`;

// TODO refactor into VeCt
HASH_PART_SEP = ",";
HASH_LIST_SEP = "_";
HASH_SUB_LIST_SEP = "~";
HASH_SUB_KV_SEP = ":";
HASH_BLANK = "blankhash";
HASH_SUB_NONE = "null";

VeCt = {
	STR_NONE: "None",
	STR_SEE_CONSOLE: "See the console (CTRL+SHIFT+J) for details.",

	HASH_SCALED: "scaled",
	HASH_SCALED_SPELL_SUMMON: "scaledspellsummon",
	HASH_SCALED_CLASS_SUMMON: "scaledclasssummon",

	FILTER_BOX_SUB_HASH_SEARCH_PREFIX: "fbsr",

	JSON_HOMEBREW_INDEX: `homebrew/index.json`,

	STORAGE_HOMEBREW: "HOMEBREW_STORAGE",
	STORAGE_HOMEBREW_META: "HOMEBREW_META_STORAGE",
	STORAGE_EXCLUDES: "EXCLUDES_STORAGE",
	STORAGE_DMSCREEN: "DMSCREEN_STORAGE",
	STORAGE_DMSCREEN_TEMP_SUBLIST: "DMSCREEN_TEMP_SUBLIST",
	STORAGE_ROLLER_MACRO: "ROLLER_MACRO_STORAGE",
	STORAGE_ENCOUNTER: "ENCOUNTER_STORAGE",
	STORAGE_POINTBUY: "POINTBUY_STORAGE",
	STORAGE_GLOBAL_COMPONENT_STATE: "GLOBAL_COMPONENT_STATE",

	DUR_INLINE_NOTIFY: 500,

	PG_NONE: "NO_PAGE",
	STR_GENERIC: "Generic",

	SYM_UI_SKIP: Symbol("uiSkip"),

	LOC_ORIGIN_CANCER: "https://5e.tools",

	STR_NO_ATTUNEMENT: "No Attunement Required",

	CR_UNKNOWN: 100001,
	CR_CUSTOM: 100000,

	SPELL_LEVEL_MAX: 9,
	LEVEL_MAX: 20,

	ENTDATA_TABLE_INCLUDE: "tableInclude",
	ENTDATA_ITEM_MERGED_ENTRY_TAG: "item.mergedEntryTag",
};

// STRING ==============================================================================================================
String.prototype.uppercaseFirst = String.prototype.uppercaseFirst || function () {
	const str = this.toString();
	if (str.length === 0) return str;
	if (str.length === 1) return str.charAt(0).toUpperCase();
	return str.charAt(0).toUpperCase() + str.slice(1);
};

String.prototype.lowercaseFirst = String.prototype.lowercaseFirst || function () {
	const str = this.toString();
	if (str.length === 0) return str;
	if (str.length === 1) return str.charAt(0).toLowerCase();
	return str.charAt(0).toLowerCase() + str.slice(1);
};

String.prototype.toTitleCase = String.prototype.toTitleCase || function () {
	let str = this.replace(/([^\W_]+[^\s-/]*) */g, m0 => m0.charAt(0).toUpperCase() + m0.substr(1).toLowerCase());

	// Require space surrounded, as title-case requires a full word on either side
	StrUtil._TITLE_LOWER_WORDS_RE = StrUtil._TITLE_LOWER_WORDS_RE || StrUtil.TITLE_LOWER_WORDS.map(it => new RegExp(`\\s${it}\\s`, "gi"));
	StrUtil._TITLE_UPPER_WORDS_RE = StrUtil._TITLE_UPPER_WORDS_RE || StrUtil.TITLE_UPPER_WORDS.map(it => new RegExp(`\\b${it}\\b`, "g"));
	StrUtil._TITLE_UPPER_WORDS_PLURAL_RE = StrUtil._TITLE_UPPER_WORDS_PLURAL_RE || StrUtil.TITLE_UPPER_WORDS.map(it => new RegExp(`\\b${it}s\\b`, "g"));

	const len = StrUtil.TITLE_LOWER_WORDS.length;
	for (let i = 0; i < len; i++) {
		str = str.replace(
			StrUtil._TITLE_LOWER_WORDS_RE[i],
			txt => txt.toLowerCase(),
		);
	}

	const len1 = StrUtil.TITLE_UPPER_WORDS.length;
	for (let i = 0; i < len1; i++) {
		str = str.replace(
			StrUtil._TITLE_UPPER_WORDS_RE[i],
			StrUtil.TITLE_UPPER_WORDS[i].toUpperCase(),
		);
	}

	for (let i = 0; i < len1; i++) {
		str = str.replace(
			StrUtil._TITLE_UPPER_WORDS_PLURAL_RE[i],
			`${StrUtil.TITLE_UPPER_WORDS[i].toUpperCase()}s`,
		);
	}

	str = str
		.split(/([;:?!.])/g)
		.map(pt => pt.replace(/^(\s*)([^\s])/, (...m) => `${m[1]}${m[2].toUpperCase()}`))
		.join("");

	return str;
};

String.prototype.toSentenceCase = String.prototype.toSentenceCase || function () {
	const out = [];
	const re = /([^.!?]+)([.!?]\s*|$)/gi;
	let m;
	do {
		m = re.exec(this);
		if (m) {
			out.push(m[0].toLowerCase().uppercaseFirst());
		}
	} while (m);
	return out.join("");
};

String.prototype.toSpellCase = String.prototype.toSpellCase || function () {
	return this.toLowerCase().replace(/(^|of )(bigby|otiluke|mordenkainen|evard|hadar|agathys|abi-dalzim|aganazzar|drawmij|leomund|maximilian|melf|nystul|otto|rary|snilloc|tasha|tenser|jim)('s|$| )/g, (...m) => `${m[1]}${m[2].toTitleCase()}${m[3]}`);
};

String.prototype.toCamelCase = String.prototype.toCamelCase || function () {
	return this.split(" ").map((word, index) => {
		if (index === 0) return word.toLowerCase();
		return `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`;
	}).join("");
};

String.prototype.escapeQuotes = String.prototype.escapeQuotes || function () {
	return this.replace(/'/g, `&apos;`).replace(/"/g, `&quot;`).replace(/</g, `&lt;`).replace(/>/g, `&gt;`);
};

String.prototype.qq = String.prototype.qq || function () {
	return this.escapeQuotes();
};

String.prototype.unescapeQuotes = String.prototype.unescapeQuotes || function () {
	return this.replace(/&apos;/g, `'`).replace(/&quot;/g, `"`).replace(/&lt;/g, `<`).replace(/&gt;/g, `>`);
};

String.prototype.uq = String.prototype.uq || function () {
	return this.unescapeQuotes();
};

String.prototype.encodeApos = String.prototype.encodeApos || function () {
	return this.replace(/'/g, `%27`);
};

/**
 * Calculates the Damerau-Levenshtein distance between two strings.
 * https://gist.github.com/IceCreamYou/8396172
 */
String.prototype.distance = String.prototype.distance || function (target) {
	let source = this; let i; let j;
	if (!source) return target ? target.length : 0;
	else if (!target) return source.length;

	const m = source.length; const n = target.length; const INF = m + n; const score = new Array(m + 2); const sd = {};
	for (i = 0; i < m + 2; i++) score[i] = new Array(n + 2);
	score[0][0] = INF;
	for (i = 0; i <= m; i++) {
		score[i + 1][1] = i;
		score[i + 1][0] = INF;
		sd[source[i]] = 0;
	}
	for (j = 0; j <= n; j++) {
		score[1][j + 1] = j;
		score[0][j + 1] = INF;
		sd[target[j]] = 0;
	}

	for (i = 1; i <= m; i++) {
		let DB = 0;
		for (j = 1; j <= n; j++) {
			const i1 = sd[target[j - 1]]; const j1 = DB;
			if (source[i - 1] === target[j - 1]) {
				score[i + 1][j + 1] = score[i][j];
				DB = j;
			} else {
				score[i + 1][j + 1] = Math.min(score[i][j], Math.min(score[i + 1][j], score[i][j + 1])) + 1;
			}
			score[i + 1][j + 1] = Math.min(score[i + 1][j + 1], score[i1] ? score[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1) : Infinity);
		}
		sd[source[i - 1]] = i;
	}
	return score[m + 1][n + 1];
};

String.prototype.isNumeric = String.prototype.isNumeric || function () {
	return !isNaN(parseFloat(this)) && isFinite(this);
};

String.prototype.last = String.prototype.last || function () {
	return this[this.length - 1];
};

String.prototype.escapeRegexp = String.prototype.escapeRegexp || function () {
	return this.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};

String.prototype.toUrlified = String.prototype.toUrlified || function () {
	return encodeURIComponent(this.toLowerCase()).toLowerCase();
};

String.prototype.toChunks = String.prototype.toChunks || function (size) {
	// https://stackoverflow.com/a/29202760/5987433
	const numChunks = Math.ceil(this.length / size)
	const chunks = new Array(numChunks)
	for (let i = 0, o = 0; i < numChunks; ++i, o += size) chunks[i] = this.substr(o, size);
	return chunks
};

String.prototype.toAscii = String.prototype.toAscii || function () {
	return this
		.normalize("NFD") // replace diacritics with their individual graphemes
		.replace(/[\u0300-\u036f]/g, "") // remove accent graphemes
		.replace(/Æ/g, "AE").replace(/æ/g, "ae");
};

String.prototype.trimChar = String.prototype.trimChar || function (ch) {
	let start = 0; let end = this.length;
	while (start < end && this[start] === ch) ++start;
	while (end > start && this[end - 1] === ch) --end;
	return (start > 0 || end < this.length) ? this.substring(start, end) : this;
};

String.prototype.trimAnyChar = String.prototype.trimAnyChar || function (chars) {
	let start = 0; let end = this.length;
	while (start < end && chars.indexOf(this[start]) >= 0) ++start;
	while (end > start && chars.indexOf(this[end - 1]) >= 0) --end;
	return (start > 0 || end < this.length) ? this.substring(start, end) : this;
};

Array.prototype.joinConjunct || Object.defineProperty(Array.prototype, "joinConjunct", {
	enumerable: false,
	writable: true,
	value: function (joiner, lastJoiner, nonOxford) {
		if (this.length === 0) return "";
		if (this.length === 1) return this[0];
		if (this.length === 2) return this.join(lastJoiner);
		else {
			let outStr = "";
			for (let i = 0; i < this.length; ++i) {
				outStr += this[i];
				if (i < this.length - 2) outStr += joiner;
				else if (i === this.length - 2) outStr += `${(!nonOxford && this.length > 2 ? joiner.trim() : "")}${lastJoiner}`;
			}
			return outStr;
		}
	},
});

StrUtil = {
	COMMAS_NOT_IN_PARENTHESES_REGEX: /,\s?(?![^(]*\))/g,
	COMMA_SPACE_NOT_IN_PARENTHESES_REGEX: /, (?![^(]*\))/g,

	uppercaseFirst: function (string) {
		return string.uppercaseFirst();
	},
	// Certain minor words should be left lowercase unless they are the first or last words in the string
	TITLE_LOWER_WORDS: ["a", "an", "the", "and", "but", "or", "for", "nor", "as", "at", "by", "for", "from", "in", "into", "near", "of", "on", "onto", "to", "with", "over"],
	// Certain words such as initialisms or acronyms should be left uppercase
	TITLE_UPPER_WORDS: ["Id", "Tv", "Dm", "Ok", "Npc", "Pc"],

	padNumber: (n, len, padder) => {
		return String(n).padStart(len, padder);
	},

	elipsisTruncate (str, atLeastPre = 5, atLeastSuff = 0, maxLen = 20) {
		if (maxLen >= str.length) return str;

		maxLen = Math.max(atLeastPre + atLeastSuff + 3, maxLen);
		let out = "";
		let remain = maxLen - (3 + atLeastPre + atLeastSuff);
		for (let i = 0; i < str.length - atLeastSuff; ++i) {
			const c = str[i];
			if (i < atLeastPre) out += c;
			else if ((remain--) > 0) out += c;
		}
		if (remain < 0) out += "...";
		out += str.substring(str.length - atLeastSuff, str.length);
		return out;
	},

	toTitleCase (str) { return str.toTitleCase(); },
	qq (str) { return (str = str || "").qq(); },
};

CleanUtil = {
	getCleanJson (data, minify = false) {
		data = MiscUtil.copy(data);
		data = MiscUtil.getWalker().walk(data, {string: (str) => CleanUtil.getCleanString(str)});
		let str = minify ? JSON.stringify(data) : `${JSON.stringify(data, null, "\t")}\n`;
		return str.replace(CleanUtil.STR_REPLACEMENTS_REGEX, (match) => CleanUtil.STR_REPLACEMENTS[match]);
	},

	getCleanString (str) {
		return str
			.replace(CleanUtil.SHARED_REPLACEMENTS_REGEX, (match) => CleanUtil.SHARED_REPLACEMENTS[match])
			.replace(CleanUtil._SOFT_HYPHEN_REMOVE_REGEX, "")
			.replace(CleanUtil._ELLIPSIS_COLLAPSE_REGEX, "$1")
			.replace(CleanUtil._DASH_COLLAPSE_REGEX, "$1")
			.replace(CleanUtil._TAG_DASH_EXPAND_REGEX, "$1 $2")
		;
	},
};
CleanUtil.SHARED_REPLACEMENTS = {
	"’": "'",
	"": "'",
	"…": "...",
	" ": " ", // non-breaking space
	"ﬀ": "ff",
	"ﬃ": "ffi",
	"ﬄ": "ffl",
	"ﬁ": "fi",
	"ﬂ": "fl",
	"Ĳ": "IJ",
	"ĳ": "ij",
	"Ǉ": "LJ",
	"ǈ": "Lj",
	"ǉ": "lj",
	"Ǌ": "NJ",
	"ǋ": "Nj",
	"ǌ": "nj",
	"ﬅ": "ft",
	"“": `"`,
	"”": `"`,
};
CleanUtil.STR_REPLACEMENTS = {
	"—": "\\u2014",
	"–": "\\u2013",
	"−": "\\u2212",
};
CleanUtil.SHARED_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.SHARED_REPLACEMENTS).join("|"), "g");
CleanUtil.STR_REPLACEMENTS_REGEX = new RegExp(Object.keys(CleanUtil.STR_REPLACEMENTS).join("|"), "g");
CleanUtil._SOFT_HYPHEN_REMOVE_REGEX = /\u00AD/g;
CleanUtil._ELLIPSIS_COLLAPSE_REGEX = /\s*(\.\s*\.\s*\.)/g;
CleanUtil._DASH_COLLAPSE_REGEX = /[ ]*([\u2014\u2013])[ ]*/g;
CleanUtil._TAG_DASH_EXPAND_REGEX = /({@[a-zA-Z])([\u2014\u2013])/g;

// SOURCES =============================================================================================================
SourceUtil = {
	_subclassReprintLookup: {},
	async pInitSubclassReprintLookup () {
		SourceUtil._subclassReprintLookup = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`);
	},

	isSubclassReprinted (className, classSource, subclassShortName, subclassSource) {
		const fromLookup = MiscUtil.get(SourceUtil._subclassReprintLookup, classSource, className, subclassSource, subclassShortName);
		return fromLookup ? fromLookup.isReprinted : false;
	},

	/** I.e., not homebrew. */
	isSiteSource (source) { return !!Parser.SOURCE_JSON_TO_FULL[source]; },

	isAdventure (source) {
		if (source instanceof FilterItem) source = source.item;
		return Parser.SOURCES_ADVENTURES.has(source);
	},

	isCoreOrSupplement (source) {
		if (source instanceof FilterItem) source = source.item;
		return Parser.SOURCES_CORE_SUPPLEMENTS.has(source);
	},

	isNonstandardSource (source) {
		return source != null && !BrewUtil.hasSourceJson(source) && SourceUtil._isNonstandardSourceWiz(source);
	},

	_isNonstandardSourceWiz (source) {
		return source.startsWith(SRC_UA_PREFIX) || source.startsWith(SRC_PS_PREFIX) || source.startsWith(SRC_AL_PREFIX) || Parser.SOURCES_NON_STANDARD_WOTC.has(source);
	},

	getFilterGroup (source) {
		if (source instanceof FilterItem) source = source.item;
		if (BrewUtil.hasSourceJson(source)) return 2;
		return Number(SourceUtil.isNonstandardSource(source));
	},

	getAdventureBookSourceHref (source, page) {
		if (!source) return null;
		source = source.toLowerCase();

		// TODO this could be made to work with homebrew
		let docPage;
		if (Parser.SOURCES_AVAILABLE_DOCS_BOOK[source]) docPage = UrlUtil.PG_BOOK;
		else if (Parser.SOURCES_AVAILABLE_DOCS_ADVENTURE[source]) docPage = UrlUtil.PG_ADVENTURE;
		if (!docPage) return null;

		return `${docPage}#${[source, page ? `page:${page}` : null].filter(Boolean).join(HASH_PART_SEP)}`;
	},
};

// CURRENCY ============================================================================================================
CurrencyUtil = {
	/**
	 * Convert 10 gold -> 1 platinum, etc.
	 * @param obj Object of the form {cp: 123, sp: 456, ...} (values optional)
	 * @param [opts]
	 * @param [opts.currencyConversionId] Currency conversion table ID.
	 * @param [opts.currencyConversionTable] Currency conversion table.
	 * @param [opts.originalCurrency] Original currency object, if the current currency object is after spending coin.
	 * @param [opts.isPopulateAllValues] If all currency properties should be be populated, even if no currency of that
	 * type is being returned (i.e. zero out unused coins).
	 */
	doSimplifyCoins (obj, opts) {
		opts = opts || {};

		const conversionTable = opts.currencyConversionTable || Parser.getCurrencyConversionTable(opts.currencyConversionId);
		if (!conversionTable.length) return obj;

		const normalized = conversionTable
			.map(it => {
				return {
					...it,
					normalizedMult: 1 / it.mult,
				}
			})
			.sort((a, b) => SortUtil.ascSort(a.normalizedMult, b.normalizedMult));

		// Simplify currencies
		for (let i = 0; i < normalized.length - 1; ++i) {
			const coinCur = normalized[i].coin;
			const coinNxt = normalized[i + 1].coin;
			const coinRatio = normalized[i + 1].normalizedMult / normalized[i].normalizedMult;

			if (obj[coinCur] && Math.abs(obj[coinCur]) >= coinRatio) {
				const nxtVal = obj[coinCur] >= 0 ? Math.floor(obj[coinCur] / coinRatio) : Math.ceil(obj[coinCur] / coinRatio);
				obj[coinCur] = obj[coinCur] % coinRatio;
				obj[coinNxt] = (obj[coinNxt] || 0) + nxtVal;
			}
		}

		// Note: this assumes that we, overall, lost money.
		if (opts.originalCurrency) {
			const normalizedHighToLow = MiscUtil.copy(normalized).reverse();

			// For each currency, look at the previous coin's diff. Say, for gp, that it is -1pp. That means we could have
			//   gained up to 10gp as change. So we can have <original gold or 0> + <10gp> max gold; the rest is converted
			//   to sp. Repeat to the end.
			// Never allow more highest-value currency (i.e. pp) than we originally had.
			normalizedHighToLow
				.forEach((coinMeta, i) => {
					const valOld = opts.originalCurrency[coinMeta.coin] || 0;
					const valNew = obj[coinMeta.coin] || 0;

					const prevCoinMeta = normalizedHighToLow[i - 1];
					const nxtCoinMeta = normalizedHighToLow[i + 1];

					if (!prevCoinMeta) { // Handle the biggest currency, e.g. platinum--never allow it to increase
						if (nxtCoinMeta) {
							const diff = valNew - valOld;
							if (diff > 0) {
								obj[coinMeta.coin] = valOld;
								const coinRatio = coinMeta.normalizedMult / nxtCoinMeta.normalizedMult;
								obj[nxtCoinMeta.coin] = (obj[nxtCoinMeta.coin] || 0) + (diff * coinRatio);
							}
						}
					} else {
						if (nxtCoinMeta) {
							const diffPrevCoin = (opts.originalCurrency[prevCoinMeta.coin] || 0) - (obj[prevCoinMeta.coin] || 0);
							const coinRatio = prevCoinMeta.normalizedMult / coinMeta.normalizedMult;
							const capFromOld = valOld + (diffPrevCoin > 0 ? diffPrevCoin * coinRatio : 0);
							const diff = valNew - capFromOld;
							if (diff > 0) {
								obj[coinMeta.coin] = capFromOld;
								const coinRatio = coinMeta.normalizedMult / nxtCoinMeta.normalizedMult;
								obj[nxtCoinMeta.coin] = (obj[nxtCoinMeta.coin] || 0) + (diff * coinRatio);
							}
						}
					}
				});
		}

		normalized
			.filter(coinMeta => obj[coinMeta.coin] === 0 || obj[coinMeta.coin] == null)
			.forEach(coinMeta => {
				// First set the value to null, in case we're dealing with a class instance that has setters
				obj[coinMeta.coin] = null;
				delete obj[coinMeta.coin];
			});

		if (opts.isPopulateAllValues) normalized.forEach(coinMeta => obj[coinMeta.coin] = obj[coinMeta.coin] || 0);

		return obj;
	},

	/**
	 * Convert a collection of coins into an equivalent value in copper.
	 * @param obj Object of the form {cp: 123, sp: 456, ...} (values optional)
	 */
	getAsCopper (obj) {
		return Parser.FULL_CURRENCY_CONVERSION_TABLE
			.map(currencyMeta => (obj[currencyMeta.coin] || 0) * (1 / currencyMeta.mult))
			.reduce((a, b) => a + b, 0);
	},
};

// CONVENIENCE/ELEMENTS ================================================================================================
Math.seed = Math.seed || function (s) {
	return function () {
		s = Math.sin(s) * 10000;
		return s - Math.floor(s);
	};
};

JqueryUtil = {
	_isEnhancementsInit: false,
	initEnhancements () {
		if (JqueryUtil._isEnhancementsInit) return;
		JqueryUtil._isEnhancementsInit = true;

		JqueryUtil.addSelectors();

		/**
		 * Template strings which can contain jQuery objects.
		 * Usage: $$`<div>Press this button: ${$btn}</div>`
		 * @return JQuery
		 */
		window.$$ = function (parts, ...args) {
			if (parts instanceof jQuery || parts instanceof HTMLElement) {
				return (...passed) => {
					const parts2 = [...passed[0]];
					const args2 = passed.slice(1);
					parts2[0] = `<div>${parts2[0]}`;
					parts2.last(`${parts2.last()}</div>`);

					const $temp = $$(parts2, ...args2);
					$temp.children().each((i, e) => $(e).appendTo(parts));
					return parts;
				};
			} else {
				const $eles = [];
				let ixArg = 0;

				const handleArg = (arg) => {
					if (arg instanceof $) {
						$eles.push(arg);
						return `<${arg.tag()} data-r="true"></${arg.tag()}>`;
					} else if (arg instanceof HTMLElement) {
						return handleArg($(arg));
					} else return arg
				};

				const raw = parts.reduce((html, p) => {
					const myIxArg = ixArg++;
					if (args[myIxArg] == null) return `${html}${p}`;
					if (args[myIxArg] instanceof Array) return `${html}${args[myIxArg].map(arg => handleArg(arg)).join("")}${p}`;
					else return `${html}${handleArg(args[myIxArg])}${p}`;
				});
				const $res = $(raw);

				if ($res.length === 1) {
					if ($res.attr("data-r") === "true") return $eles[0];
					else $res.find(`[data-r=true]`).replaceWith(i => $eles[i]);
				} else {
					// Handle case where user has passed in a bunch of elements with no outer wrapper
					const $tmp = $(`<div></div>`);
					$tmp.append($res);
					$tmp.find(`[data-r=true]`).replaceWith(i => $eles[i]);
					return $tmp.children();
				}

				return $res;
			}
		};

		$.fn.extend({
			// avoid setting input type to "search" as it visually offsets the contents of the input
			disableSpellcheck: function () { return this.attr("autocomplete", "new-password").attr("autocapitalize", "off").attr("spellcheck", "false"); },
			tag: function () { return this.prop("tagName").toLowerCase(); },
			title: function (...args) { return this.attr("title", ...args); },
			placeholder: function (...args) { return this.attr("placeholder", ...args); },
			disable: function () { return this.attr("disabled", true); },

			/**
			 * Quickly set the innerHTML of the innermost element, without parsing the whole thing with jQuery.
			 * Useful for populating e.g. a table row.
			 */
			fastSetHtml: function (html) {
				if (!this.length) return this;
				let tgt = this[0];
				while (tgt.children.length) {
					tgt = tgt.children[0];
				}
				tgt.innerHTML = html;
				return this;
			},

			blurOnEsc: function () {
				return this.keydown(evt => {
					if (evt.which === 27) this.blur(); // escape
				});
			},

			hideVe: function () { return this.addClass("ve-hidden"); },
			showVe: function () { return this.removeClass("ve-hidden"); },
			toggleVe: function (val) {
				if (val === undefined) return this.toggleClass("ve-hidden", !this.hasClass("ve-hidden"));
				else return this.toggleClass("ve-hidden", !val);
			},
		});

		$.event.special.destroyed = {
			remove: function (o) {
				if (o.handler) o.handler();
			},
		}
	},

	addSelectors () {
		// Add a selector to match exact text (case insensitive) to jQuery's arsenal
		//   Note that the search text should be `trim().toLowerCase()`'d before being passed in
		$.expr[":"].textEquals = (el, i, m) => $(el).text().toLowerCase().trim() === m[3].unescapeQuotes();

		// Add a selector to match contained text (case insensitive)
		$.expr[":"].containsInsensitive = (el, i, m) => {
			const searchText = m[3];
			const textNode = $(el).contents().filter((i, e) => e.nodeType === 3)[0];
			if (!textNode) return false;
			const match = textNode.nodeValue.toLowerCase().trim().match(`${searchText.toLowerCase().trim().escapeRegexp()}`);
			return match && match.length > 0;
		};
	},

	showCopiedEffect (eleOr$Ele, text = "Copied!", bubble) {
		const $ele = eleOr$Ele instanceof $ ? eleOr$Ele : $(eleOr$Ele);

		const top = $(window).scrollTop();
		const pos = $ele.offset();

		const animationOptions = {
			top: "-=8",
			opacity: 0,
		};
		if (bubble) {
			animationOptions.left = `${Math.random() > 0.5 ? "-" : "+"}=${~~(Math.random() * 17)}`;
		}
		const seed = Math.random();
		const duration = bubble ? 250 + seed * 200 : 250;
		const offsetY = bubble ? 16 : 0;

		const $dispCopied = $(`<div class="clp__disp-copied"></div>`);
		$dispCopied
			.html(text)
			.css({
				top: (pos.top - 24) + offsetY - top,
				left: pos.left + ($ele.width() / 2),
			})
			.appendTo(document.body)
			.animate(
				animationOptions,
				{
					duration,
					complete: () => $dispCopied.remove(),
					progress: (_, progress) => { // progress is 0..1
						if (bubble) {
							const diffProgress = 0.5 - progress;
							animationOptions.top = `${diffProgress > 0 ? "-" : "+"}=40`;
							$dispCopied.css("transform", `rotate(${seed > 0.5 ? "-" : ""}${seed * 500 * progress}deg)`);
						}
					},
				},
			);
	},

	_dropdownInit: false,
	bindDropdownButton ($ele) {
		if (!JqueryUtil._dropdownInit) {
			JqueryUtil._dropdownInit = true;
			document.addEventListener("click", () => [...document.querySelectorAll(`.open`)].filter(ele => !(ele.className || "").split(" ").includes(`dropdown--navbar`)).forEach(ele => ele.classList.remove("open")));
		}
		$ele.click(() => setTimeout(() => $ele.parent().addClass("open"), 1)); // defer to allow the above to complete
	},

	_ACTIVE_TOAST: [],
	/**
	 * @param {Object|string} options
	 * @param {(jQuery|string)} options.content Toast contents. Supports jQuery objects.
	 * @param {string} options.type Toast type. Can be any Bootstrap alert type ("success", "info", "warning", or "danger").
	 */
	doToast (options) {
		if (typeof window === "undefined") return;

		if (typeof options === "string") {
			options = {
				content: options,
				type: "info",
			};
		}
		options.type = options.type || "info";

		const doCleanup = ($toast) => {
			$toast.removeClass("toast--animate");
			setTimeout(() => $toast.remove(), 85);
			JqueryUtil._ACTIVE_TOAST.splice(JqueryUtil._ACTIVE_TOAST.indexOf($toast), 1);
		};

		const $btnToastDismiss = $(`<button class="btn toast__btn-close"><span class="glyphicon glyphicon-remove"></span></button>`);

		const $toast = $$`
		<div class="toast toast--type-${options.type}">
			<div class="toast__wrp-content">${options.content}</div>
			<div class="toast__wrp-control">${$btnToastDismiss}</div>
		</div>`
			.prependTo(document.body)
			.data("pos", 0)
			.mousedown(evt => {
				evt.preventDefault();
			})
			.click(evt => {
				evt.preventDefault();
				doCleanup($toast);
			});

		setTimeout(() => $toast.addClass(`toast--animate`), 5);
		setTimeout(() => doCleanup($toast), 5000);

		if (JqueryUtil._ACTIVE_TOAST.length) {
			JqueryUtil._ACTIVE_TOAST.forEach($oldToast => {
				const pos = $oldToast.data("pos");
				$oldToast.data("pos", pos + 1);
				if (pos === 2) doCleanup($oldToast);
			});
		}

		JqueryUtil._ACTIVE_TOAST.push($toast);
	},
};

if (typeof window !== "undefined") window.addEventListener("load", JqueryUtil.initEnhancements);

ElementUtil = {
	getOrModify ({
		tag,
		clazz,
		style,
		click,
		contextmenu,
		change,
		mousedown,
		mouseup,
		mousemove,
		html,
		text,
		ele,
		children,
		outer,

		name,
		title,
		val,
		href,
		type,
		attrs,
	}) {
		ele = ele || (outer ? (new DOMParser()).parseFromString(outer, "text/html").body.childNodes[0] : document.createElement(tag));

		if (clazz) ele.className = clazz;
		if (style) ele.setAttribute("style", style);
		if (click) ele.addEventListener("click", click);
		if (contextmenu) ele.addEventListener("contextmenu", contextmenu);
		if (change) ele.addEventListener("change", change);
		if (mousedown) ele.addEventListener("mousedown", mousedown);
		if (mouseup) ele.addEventListener("mouseup", mouseup);
		if (mousemove) ele.addEventListener("mousemove", mousemove);
		if (html != null) ele.innerHTML = html;
		if (text != null) ele.textContent = text;
		if (name != null) ele.setAttribute("name", name);
		if (title != null) ele.setAttribute("title", title);
		if (href != null) ele.setAttribute("href", href);
		if (val != null) ele.setAttribute("value", val);
		if (type != null) ele.setAttribute("type", type);
		if (attrs != null) { for (const k in attrs) { ele.setAttribute(k, attrs[k]); } }
		if (children) for (let i = 0, len = children.length; i < len; ++i) if (children[i] != null) ele.append(children[i]);

		ele.appends = ele.appends || ElementUtil._appends.bind(ele);
		ele.appendTo = ele.appendTo || ElementUtil._appendTo.bind(ele);
		ele.prependTo = ele.prependTo || ElementUtil._prependTo.bind(ele);
		ele.addClass = ele.addClass || ElementUtil._addClass.bind(ele);
		ele.removeClass = ele.removeClass || ElementUtil._removeClass.bind(ele);
		ele.toggleClass = ele.toggleClass || ElementUtil._toggleClass.bind(ele);
		ele.showVe = ele.showVe || ElementUtil._showVe.bind(ele);
		ele.hideVe = ele.hideVe || ElementUtil._hideVe.bind(ele);
		ele.toggleVe = ele.toggleVe || ElementUtil._toggleVe.bind(ele);
		ele.empty = ele.empty || ElementUtil._empty.bind(ele);
		ele.detach = ele.detach || ElementUtil._detach.bind(ele);
		ele.attr = ele.attr || ElementUtil._attr.bind(ele);
		ele.val = ele.val || ElementUtil._val.bind(ele);
		ele.html = ele.html || ElementUtil._html.bind(ele);
		ele.tooltip = ele.tooltip || ElementUtil._tooltip.bind(ele);
		ele.onClick = ele.onClick || ElementUtil._onClick.bind(ele);
		ele.onContextmenu = ele.onContextmenu || ElementUtil._onContextmenu.bind(ele);
		ele.onChange = ele.onChange || ElementUtil._onChange.bind(ele);

		return ele;
	},

	_appends (child) {
		this.appendChild(child);
		return this;
	},

	_appendTo (parent) {
		parent.appendChild(this);
		return this;
	},

	_prependTo (parent) {
		parent.prepend(this);
		return this;
	},

	_addClass (clazz) {
		this.classList.add(clazz);
		return this;
	},

	_removeClass (clazz) {
		this.classList.remove(clazz);
		return this;
	},

	_toggleClass (clazz, isActive) {
		if (isActive == null) this.classList.toggle(clazz);
		else if (isActive) this.classList.add(clazz);
		else this.classList.remove(clazz);
		return this;
	},

	_showVe () {
		this.classList.remove("ve-hidden");
		return this;
	},

	_hideVe () {
		this.classList.add("ve-hidden");
		return this;
	},

	_toggleVe (isActive) {
		this.toggleClass("ve-hidden", isActive == null ? isActive : !isActive);
		return this;
	},

	_empty () {
		this.innerHTML = "";
		return this;
	},

	_detach () {
		if (this.parentElement) this.parentElement.removeChild(this);
		return this;
	},

	_attr (name, value) {
		this.setAttribute(name, value);
		return this;
	},

	_html (html) {
		this.innerHTML = html;
		return this;
	},

	_tooltip (title) {
		return this.attr("title", title);
	},

	_onClick (fn) { return ElementUtil._onX(this, "click", fn); },
	_onContextmenu (fn) { return ElementUtil._onX(this, "contextmenu", fn); },
	_onChange (fn) { return ElementUtil._onX(this, "change", fn); },

	_onX (ele, evtName, fn) { ele.addEventListener(evtName, fn); return ele; },

	_val (val) {
		if (val !== undefined) {
			switch (this.tagName) {
				case "SELECT": {
					let selectedIndexNxt = -1;
					for (let i = 0, len = this.options.length; i < len; ++i) {
						if (this.options[i]?.value === val) { selectedIndexNxt = i; break; }
					}
					this.selectedIndex = selectedIndexNxt;
					return this;
				}

				default: {
					this.value = val;
					return this;
				}
			}
		}

		switch (this.tagName) {
			case "SELECT": return this.options[this.selectedIndex]?.value;

			default: return this.value;
		}
	},

	// region "Static"
	getIndexPathToParent (parent, child) {
		if (!parent.contains(child)) return null;

		const path = [];

		while (child !== parent) {
			if (!child.parentElement) return null;

			const ix = [...child.parentElement.children].indexOf(child)
			if (!~ix) return null;

			path.push(ix);

			child = child.parentElement;
		}

		return path.reverse();
	},

	getChildByIndexPath (parent, indexPath) {
		for (let i = 0; i < indexPath.length; ++i) {
			const ix = indexPath[i];
			parent = parent.children[ix];
			if (!parent) return null;
		}
		return parent;
	},
	// endregion
}

if (typeof window !== "undefined") window.e_ = ElementUtil.getOrModify;

ObjUtil = {
	async pForEachDeep (source, pCallback, options = {depth: Infinity, callEachLevel: false}) {
		const path = [];
		const pDiveDeep = async function (val, path, depth = 0) {
			if (options.callEachLevel || typeof val !== "object" || options.depth === depth) {
				await pCallback(val, path, depth);
			}
			if (options.depth !== depth && typeof val === "object") {
				for (const key of Object.keys(val)) {
					path.push(key);
					await pDiveDeep(val[key], path, depth + 1);
				}
			}
			path.pop();
		};
		await pDiveDeep(source, path);
	},
};

// TODO refactor other misc utils into this
MiscUtil = {
	COLOR_HEALTHY: "#00bb20",
	COLOR_HURT: "#c5ca00",
	COLOR_BLOODIED: "#f7a100",
	COLOR_DEFEATED: "#cc0000",

	copy (obj) {
		return JSON.parse(JSON.stringify(obj));
	},

	async pCopyTextToClipboard (text) {
		function doCompatibilityCopy () {
			const $iptTemp = $(`<textarea class="clp__wrp-temp"></textarea>`)
				.appendTo(document.body)
				.val(text)
				.select();
			document.execCommand("Copy");
			$iptTemp.remove();
		}

		if (navigator && navigator.permissions) {
			try {
				const access = await navigator.permissions.query({name: "clipboard-write"});
				if (access.state === "granted" || access.state === "prompt") {
					await navigator.clipboard.writeText(text);
				} else doCompatibilityCopy();
			} catch (e) { doCompatibilityCopy(); }
		} else doCompatibilityCopy();
	},

	checkProperty (object, ...path) {
		for (let i = 0; i < path.length; ++i) {
			object = object[path[i]];
			if (object == null) return false;
		}
		return true;
	},

	get (object, ...path) {
		if (object == null) return null;
		for (let i = 0; i < path.length; ++i) {
			object = object[path[i]];
			if (object == null) return object;
		}
		return object;
	},

	set (object, ...pathAndVal) {
		if (object == null) return null;

		const val = pathAndVal.pop();
		if (!pathAndVal.length) return null;

		const len = pathAndVal.length;
		for (let i = 0; i < len; ++i) {
			const pathPart = pathAndVal[i];
			if (i === len - 1) object[pathPart] = val;
			else object = (object[pathPart] = object[pathPart] || {});
		}

		return val;
	},

	getOrSet (object, ...pathAndVal) {
		if (pathAndVal.length < 2) return null;
		const existing = MiscUtil.get(object, ...pathAndVal.slice(0, -1));
		return existing || MiscUtil.set(object, ...pathAndVal);
	},

	delete (object, ...path) {
		if (object == null) return null;
		for (let i = 0; i < path.length - 1; ++i) {
			object = object[path[i]];
			if (object == null) return object;
		}
		return delete object[path.last()];
	},

	merge (obj1, obj2) {
		obj2 = MiscUtil.copy(obj2);

		Object.entries(obj2)
			.forEach(([k, v]) => {
				if (obj1[k] == null) {
					obj1[k] = v;
					return;
				}

				if (
					typeof obj1[k] === "object"
					&& typeof v === "object"
					&& !(obj1[k] instanceof Array)
					&& !(v instanceof Array)
				) {
					MiscUtil.merge(obj1[k], v);
					return;
				}

				obj1[k] = v;
			});

		return obj1;
	},

	mix: (superclass) => new MiscUtil._MixinBuilder(superclass),
	_MixinBuilder: function (superclass) {
		this.superclass = superclass;

		this.with = function (...mixins) {
			return mixins.reduce((c, mixin) => mixin(c), this.superclass);
		};
	},

	clearSelection () {
		if (document.getSelection) {
			document.getSelection().removeAllRanges();
			document.getSelection().addRange(document.createRange());
		} else if (window.getSelection) {
			if (window.getSelection().removeAllRanges) {
				window.getSelection().removeAllRanges();
				window.getSelection().addRange(document.createRange());
			} else if (window.getSelection().empty) {
				window.getSelection().empty();
			}
		} else if (document.selection) {
			document.selection.empty();
		}
	},

	randomColor () {
		let r; let g; let b;
		const h = RollerUtil.randomise(30, 0) / 30;
		const i = ~~(h * 6);
		const f = h * 6 - i;
		const q = 1 - f;
		switch (i % 6) {
			case 0: r = 1; g = f; b = 0; break;
			case 1: r = q; g = 1; b = 0; break;
			case 2: r = 0; g = 1; b = f; break;
			case 3: r = 0; g = q; b = 1; break;
			case 4: r = f; g = 0; b = 1; break;
			case 5: r = 1; g = 0; b = q; break;
		}
		return `#${`00${(~~(r * 255)).toString(16)}`.slice(-2)}${`00${(~~(g * 255)).toString(16)}`.slice(-2)}${`00${(~~(b * 255)).toString(16)}`.slice(-2)}`;
	},

	/**
	 * @param hex Original hex color.
	 * @param [opts] Options object.
	 * @param [opts.bw] True if the color should be returnes as black/white depending on contrast ratio.
	 * @param [opts.dark] Color to return if a "dark" color would contrast best.
	 * @param [opts.light] Color to return if a "light" color would contrast best.
	 */
	invertColor (hex, opts) {
		opts = opts || {};

		hex = hex.slice(1); // remove #

		let r = parseInt(hex.slice(0, 2), 16);
		let g = parseInt(hex.slice(2, 4), 16);
		let b = parseInt(hex.slice(4, 6), 16);

		// http://stackoverflow.com/a/3943023/112731
		const isDark = (r * 0.299 + g * 0.587 + b * 0.114) > 186;
		if (opts.dark && opts.light) return isDark ? opts.dark : opts.light;
		else if (opts.bw) return isDark ? "#000000" : "#FFFFFF";

		r = (255 - r).toString(16); g = (255 - g).toString(16); b = (255 - b).toString(16);
		return `#${[r, g, b].map(it => it.padStart(2, "0")).join("")}`;
	},

	scrollPageTop () {
		document.body.scrollTop = document.documentElement.scrollTop = 0;
	},

	expEval (str) {
		// eslint-disable-next-line no-new-func
		return new Function(`return ${str.replace(/[^-()\d/*+.]/g, "")}`)();
	},

	parseNumberRange (input, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
		function errInvalid (input) {
			throw new Error(`Could not parse range input "${input}"`);
		}

		function errOutOfRange () {
			throw new Error(`Number was out of range! Range was ${min}-${max} (inclusive).`);
		}

		function isOutOfRange (num) {
			return num < min || num > max;
		}

		function addToRangeVal (range, num) {
			range.add(num);
		}

		function addToRangeLoHi (range, lo, hi) {
			for (let i = lo; i <= hi; ++i) range.add(i);
		}

		while (true) {
			if (input && input.trim()) {
				const clean = input.replace(/\s*/g, "");
				if (/^((\d+-\d+|\d+),)*(\d+-\d+|\d+)$/.exec(clean)) {
					const parts = clean.split(",");
					const out = new Set();

					for (const part of parts) {
						if (part.includes("-")) {
							const spl = part.split("-");
							const numLo = Number(spl[0]);
							const numHi = Number(spl[1]);

							if (isNaN(numLo) || isNaN(numHi) || numLo === 0 || numHi === 0 || numLo > numHi) errInvalid();

							if (isOutOfRange(numLo) || isOutOfRange(numHi)) errOutOfRange();

							if (numLo === numHi) addToRangeVal(out, numLo);
							else addToRangeLoHi(out, numLo, numHi);
						} else {
							const num = Number(part);
							if (isNaN(num) || num === 0) errInvalid();
							else {
								if (isOutOfRange(num)) errOutOfRange();
								addToRangeVal(out, num);
							}
						}
					}

					return out;
				} else errInvalid();
			} else return null;
		}
	},

	findCommonPrefix (strArr) {
		let prefix = null;
		strArr.forEach(s => {
			if (prefix == null) {
				prefix = s;
			} else {
				const minLen = Math.min(s.length, prefix.length);
				for (let i = 0; i < minLen; ++i) {
					const cp = prefix[i];
					const cs = s[i];
					if (cp !== cs) {
						prefix = prefix.substring(0, i);
						break;
					}
				}
			}
		});
		return prefix;
	},

	/**
	 * @param fgHexTarget Target/resultant color for the foreground item
	 * @param fgOpacity Desired foreground transparency (0-1 inclusive)
	 * @param bgHex Background color
	 */
	calculateBlendedColor (fgHexTarget, fgOpacity, bgHex) {
		const fgDcTarget = CryptUtil.hex2Dec(fgHexTarget);
		const bgDc = CryptUtil.hex2Dec(bgHex);
		return ((fgDcTarget - ((1 - fgOpacity) * bgDc)) / fgOpacity).toString(16);
	},

	/**
	 * Borrowed from lodash.
	 *
	 * @param func The function to debounce.
	 * @param wait Minimum duration between calls.
	 * @param options Options object.
	 * @return {Function} The debounced function.
	 */
	debounce (func, wait, options) {
		let lastArgs; let lastThis; let maxWait; let result; let timerId; let lastCallTime; let lastInvokeTime = 0; let leading = false; let maxing = false; let trailing = true;

		wait = Number(wait) || 0;
		if (typeof options === "object") {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		function invokeFunc (time) {
			let args = lastArgs; let thisArg = lastThis;

			lastArgs = lastThis = undefined;
			lastInvokeTime = time;
			result = func.apply(thisArg, args);
			return result;
		}

		function leadingEdge (time) {
			lastInvokeTime = time;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time) : result;
		}

		function remainingWait (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime; let result = wait - timeSinceLastCall;
			return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;
		}

		function shouldInvoke (time) {
			let timeSinceLastCall = time - lastCallTime; let timeSinceLastInvoke = time - lastInvokeTime;

			return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		}

		function timerExpired () {
			const time = Date.now();
			if (shouldInvoke(time)) {
				return trailingEdge(time);
			}
			// Restart the timer.
			timerId = setTimeout(timerExpired, remainingWait(time));
		}

		function trailingEdge (time) {
			timerId = undefined;

			if (trailing && lastArgs) return invokeFunc(time);
			lastArgs = lastThis = undefined;
			return result;
		}

		function cancel () {
			if (timerId !== undefined) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = undefined;
		}

		function flush () {
			return timerId === undefined ? result : trailingEdge(Date.now());
		}

		function debounced () {
			let time = Date.now(); let isInvoking = shouldInvoke(time);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time;

			if (isInvoking) {
				if (timerId === undefined) return leadingEdge(lastCallTime);
				if (maxing) {
					// Handle invocations in a tight loop.
					timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
			return result;
		}

		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	},

	// from lodash
	throttle (func, wait, options) {
		let leading = true; let trailing = true;

		if (typeof options === "object") {
			leading = "leading" in options ? !!options.leading : leading;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}

		return this.debounce(func, wait, {leading, maxWait: wait, trailing});
	},

	pDelay (msecs, resolveAs) {
		return new Promise(resolve => setTimeout(() => resolve(resolveAs), msecs));
	},

	GENERIC_WALKER_ENTRIES_KEY_BLACKLIST: new Set(["caption", "type", "colLabels", "name", "colStyles", "style", "shortName", "subclassShortName"]),

	/**
	 * @param [opts]
	 * @param [opts.keyBlacklist]
	 * @param [opts.isAllowDeleteObjects] If returning `undefined` from an object handler should be treated as a delete.
	 * @param [opts.isAllowDeleteArrays] If returning `undefined` from an array handler should be treated as a delete.
	 * @param [opts.isAllowDeleteBooleans] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteNumbers] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteStrings] (Unimplemented) // TODO
	 * @param [opts.isDepthFirst] If array/object recursion should occur before array/object primitive handling.
	 * @param [opts.isNoModification] If the walker should not attempt to modify the data.
	 */
	getWalker (opts) {
		opts = opts || {};
		const keyBlacklist = opts.keyBlacklist || new Set();

		const fn = (obj, primitiveHandlers, lastKey, stack) => {
			if (obj == null) {
				if (primitiveHandlers.null) return MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.null, obj, lastKey, stack});
				return obj;
			}

			const doObjectRecurse = () => {
				Object.keys(obj).forEach(k => {
					const v = obj[k];
					if (!keyBlacklist.has(k)) {
						const out = fn(v, primitiveHandlers, k, stack);
						if (!opts.isNoModification) obj[k] = out;
					}
				});
			};

			const to = typeof obj;
			switch (to) {
				case undefined:
					if (primitiveHandlers.preUndefined) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preUndefined, obj, lastKey, stack});
					if (primitiveHandlers.undefined) {
						const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.undefined, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postUndefined) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postUndefined, obj, lastKey, stack});
					return obj;
				case "boolean":
					if (primitiveHandlers.preBoolean) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preBoolean, obj, lastKey, stack});
					if (primitiveHandlers.boolean) {
						const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.boolean, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postBoolean) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postBoolean, obj, lastKey, stack});
					return obj;
				case "number":
					if (primitiveHandlers.preNumber) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preNumber, obj, lastKey, stack});
					if (primitiveHandlers.number) {
						const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.number, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postNumber) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postNumber, obj, lastKey, stack});
					return obj;
				case "string":
					if (primitiveHandlers.preString) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preString, obj, lastKey, stack});
					if (primitiveHandlers.string) {
						const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.string, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postString) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postString, obj, lastKey, stack});
					return obj;
				case "object": {
					if (obj instanceof Array) {
						if (primitiveHandlers.preArray) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preArray, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							const out = obj.map(it => fn(it, primitiveHandlers, lastKey, stack));
							if (!opts.isNoModification) obj = out;
							if (stack) stack.pop();

							if (primitiveHandlers.array) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.array) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj != null) {
								const out = obj.map(it => fn(it, primitiveHandlers, lastKey, stack));
								if (!opts.isNoModification) obj = out;
							} else {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						}
						if (primitiveHandlers.postArray) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postArray, obj, lastKey, stack});
						return obj;
					} else {
						if (primitiveHandlers.preObject) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.preObject, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							doObjectRecurse();
							if (stack) stack.pop();

							if (primitiveHandlers.object) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.object) {
								const out = MiscUtil._getWalker_applyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							} else {
								doObjectRecurse();
							}
						}
						if (primitiveHandlers.postObject) MiscUtil._getWalker_runHandlers({handlers: primitiveHandlers.postObject, obj, lastKey, stack});
						return obj;
					}
				}
				default: throw new Error(`Unhandled type "${to}"`);
			}
		};

		return {walk: fn};
	},

	_getWalker_applyHandlers ({opts, handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		handlers.forEach(h => {
			const out = h(obj, lastKey, stack);
			if (!opts.isNoModification) obj = out;
		});
		return obj;
	},

	_getWalker_runHandlers ({handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		handlers.forEach(h => h(obj, lastKey, stack));
	},

	/**
	 * @param [opts]
	 * @param [opts.keyBlacklist]
	 * @param [opts.isAllowDeleteObjects] If returning `undefined` from an object handler should be treated as a delete.
	 * @param [opts.isAllowDeleteArrays] If returning `undefined` from an array handler should be treated as a delete.
	 * @param [opts.isAllowDeleteBooleans] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteNumbers] (Unimplemented) // TODO
	 * @param [opts.isAllowDeleteStrings] (Unimplemented) // TODO
	 * @param [opts.isDepthFirst] If array/object recursion should occur before array/object primitive handling.
	 * @param [opts.isNoModification] If the walker should not attempt to modify the data.
	 */
	getAsyncWalker (opts) {
		opts = opts || {};
		const keyBlacklist = opts.keyBlacklist || new Set();

		const pFn = async (obj, primitiveHandlers, lastKey, stack) => {
			if (obj == null) {
				if (primitiveHandlers.null) return MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.null, obj, lastKey, stack});
				return obj;
			}

			const pDoObjectRecurse = async () => {
				await Object.keys(obj).pSerialAwaitMap(async k => {
					const v = obj[k];
					if (keyBlacklist.has(k)) return;
					const out = await pFn(v, primitiveHandlers, k, stack);
					if (!opts.isNoModification) obj[k] = out;
				});
			};

			const to = typeof obj;
			switch (to) {
				case undefined:
					if (primitiveHandlers.preUndefined) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preUndefined, obj, lastKey, stack});
					if (primitiveHandlers.undefined) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.undefined, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postUndefined) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postUndefined, obj, lastKey, stack});
					return obj;
				case "boolean":
					if (primitiveHandlers.preBoolean) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preBoolean, obj, lastKey, stack});
					if (primitiveHandlers.boolean) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.boolean, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postBoolean) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postBoolean, obj, lastKey, stack});
					return obj;
				case "number":
					if (primitiveHandlers.preNumber) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preNumber, obj, lastKey, stack});
					if (primitiveHandlers.number) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.number, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postNumber) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postNumber, obj, lastKey, stack});
					return obj;
				case "string":
					if (primitiveHandlers.preString) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preString, obj, lastKey, stack});
					if (primitiveHandlers.string) {
						const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.string, obj, lastKey, stack});
						if (!opts.isNoModification) obj = out;
					}
					if (primitiveHandlers.postString) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postString, obj, lastKey, stack});
					return obj;
				case "object": {
					if (obj instanceof Array) {
						if (primitiveHandlers.preArray) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preArray, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							const out = await obj.pSerialAwaitMap(it => pFn(it, primitiveHandlers, lastKey, stack));
							if (!opts.isNoModification) obj = out;
							if (stack) stack.pop();

							if (primitiveHandlers.array) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.array) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.array, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj != null) {
								const out = await obj.pSerialAwaitMap(it => pFn(it, primitiveHandlers, lastKey, stack));
								if (!opts.isNoModification) obj = out;
							} else {
								if (!opts.isAllowDeleteArrays) throw new Error(`Array handler(s) returned null!`);
							}
						}
						if (primitiveHandlers.postArray) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postArray, obj, lastKey, stack});
						return obj;
					} else {
						if (primitiveHandlers.preObject) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.preObject, obj, lastKey, stack});
						if (opts.isDepthFirst) {
							if (stack) stack.push(obj);
							await pDoObjectRecurse();
							if (stack) stack.pop();

							if (primitiveHandlers.object) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							}
						} else {
							if (primitiveHandlers.object) {
								const out = await MiscUtil._getAsyncWalker_pApplyHandlers({opts, handlers: primitiveHandlers.object, obj, lastKey, stack});
								if (!opts.isNoModification) obj = out;
							}
							if (obj == null) {
								if (!opts.isAllowDeleteObjects) throw new Error(`Object handler(s) returned null!`);
							} else {
								await pDoObjectRecurse();
							}
						}
						if (primitiveHandlers.postObject) await MiscUtil._getAsyncWalker_pRunHandlers({handlers: primitiveHandlers.postObject, obj, lastKey, stack});
						return obj;
					}
				}
				default: throw new Error(`Unhandled type "${to}"`);
			}
		};

		return {pWalk: pFn};
	},

	async _getAsyncWalker_pApplyHandlers ({opts, handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		await handlers.pSerialAwaitMap(async pH => {
			const out = await pH(obj, lastKey, stack);
			if (!opts.isNoModification) obj = out;
		});
		return obj;
	},

	async _getAsyncWalker_pRunHandlers ({handlers, obj, lastKey, stack}) {
		handlers = handlers instanceof Array ? handlers : [handlers];
		await handlers.pSerialAwaitMap(pH => pH(obj, lastKey, stack));
	},

	pDefer (fn) {
		return (async () => fn())();
	},
};

// EVENT HANDLERS ======================================================================================================
EventUtil = {
	_mouseX: 0,
	_mouseY: 0,

	init () {
		document.addEventListener("mousemove", evt => {
			EventUtil._mouseX = evt.clientX;
			EventUtil._mouseY = evt.clientY;
		});
	},

	getClientX (evt) { return evt.touches && evt.touches.length ? evt.touches[0].clientX : evt.clientX; },
	getClientY (evt) { return evt.touches && evt.touches.length ? evt.touches[0].clientY : evt.clientY; },

	isInInput (evt) {
		return evt.target.nodeName === "INPUT" || evt.target.nodeName === "TEXTAREA"
			|| evt.target.getAttribute("contenteditable") === "true";
	},

	noModifierKeys (evt) { return !evt.ctrlKey && !evt.altKey && !evt.metaKey; },
};

if (typeof window !== "undefined") window.addEventListener("load", EventUtil.init);

// CONTEXT MENUS =======================================================================================================
ContextUtil = {
	_isInit: false,
	_menus: [],

	_init () {
		if (ContextUtil._isInit) return;
		ContextUtil._isInit = true;

		$(document.body).click(() => ContextUtil._menus.forEach(menu => menu.close()));
	},

	getMenu (actions) {
		ContextUtil._init();

		const menu = new ContextUtil.Menu(actions);
		ContextUtil._menus.push(menu);
		return menu;
	},

	deleteMenu (menu) {
		menu.remove();
		const ix = ContextUtil._menus.findIndex(it => it === menu);
		if (~ix) ContextUtil._menus.splice(ix, 1);
	},

	pOpenMenu (evt, menu, userData) {
		evt.preventDefault();
		evt.stopPropagation();

		ContextUtil._init();

		// Close any other open menus
		ContextUtil._menus.filter(it => it !== menu).forEach(it => it.close());

		return menu.pOpen(evt, userData);
	},

	Menu: function (actions) {
		this._actions = actions;
		this._pResult = null;
		this._resolveResult = null;

		this._userData = null;

		this.remove = function () { if (this._$ele) this._$ele.remove(); }

		this.width = function () { return this._$ele ? this._$ele.width() : undefined; }
		this.height = function () { return this._$ele ? this._$ele.height() : undefined; }

		this.pOpen = function (evt, userData) {
			this._initLazy();

			if (this._resolveResult) this._resolveResult(null);
			this._pResult = new Promise(resolve => {
				this._resolveResult = resolve;
			});
			this._userData = userData;

			this._$ele
				.css({
					position: "absolute",
					left: this._getMenuPosition(evt, "x"),
					top: this._getMenuPosition(evt, "y"),
				})
				.showVe();

			return this._pResult;
		}
		this.close = function () { if (this._$ele) this._$ele.hideVe(); }

		this._initLazy = function () {
			if (this._$ele) return;

			const $elesAction = this._actions.map(it => {
				if (it == null) return $(`<div class="my-1 w-100 ui-ctx__divider"></div>`);

				const $row = $$`<div class="py-1 px-5 ui-ctx__row ${it.isDisabled ? "disabled" : ""} ${it.style || ""}">${it.text}</div>`
					.click(async evt => {
						if (it.isDisabled) return;

						evt.preventDefault();
						evt.stopPropagation();

						this.close();

						const result = await it.fnAction(evt, this._userData);
						if (this._resolveResult) this._resolveResult(result);
					});
				if (it.title) $row.title(it.title);

				return $row;
			});

			this._$ele = $$`<div class="flex-col ui-ctx__wrp py-2">${$elesAction}</div>`
				.hideVe()
				.appendTo(document.body);
		};

		this._getMenuPosition = function (evt, axis) {
			const {fnMenuSize, propMousePos, fnWindowSize, fnScrollDir} = axis === "x"
				? {fnMenuSize: "width", propMousePos: "clientX", fnWindowSize: "width", fnScrollDir: "scrollLeft"}
				: {fnMenuSize: "height", propMousePos: "clientY", fnWindowSize: "height", fnScrollDir: "scrollTop"};

			const posMouse = evt[propMousePos];
			const szWin = $(window)[fnWindowSize]();
			const posScroll = $(window)[fnScrollDir]();
			let position = posMouse + posScroll;
			const szMenu = this[fnMenuSize]();
			// opening menu would pass the side of the page
			if (posMouse + szMenu > szWin && szMenu < posMouse) position -= szMenu;
			return position;
		}
	},

	/**
	 * @param text
	 * @param fnAction Action, which is passed its triggering click event as an argument.
	 * @param [opts] Options object.
	 * @param [opts.isDisabled] If this action is disabled.
	 * @param [opts.title] Help (title) text.
	 * @param [opts.style] Additional CSS classes to add (e.g. `ctx-danger`).
	 */
	Action: function (text, fnAction, opts) {
		opts = opts || {};

		this.text = text;
		this.fnAction = fnAction;

		this.isDisabled = opts.isDisabled;
		this.title = opts.title;
		this.style = opts.style;
	},
};

// LIST AND SEARCH =====================================================================================================
SearchUtil = {
	removeStemmer (elasticSearch) {
		const stemmer = elasticlunr.Pipeline.getRegisteredFunction("stemmer");
		elasticSearch.pipeline.remove(stemmer);
	},
};

// ENCODING/DECODING ===================================================================================================
UrlUtil = {
	encodeForHash (toEncode) {
		if (toEncode instanceof Array) return toEncode.map(it => `${it}`.toUrlified()).join(HASH_LIST_SEP);
		else return `${toEncode}`.toUrlified();
	},

	autoEncodeHash (obj) {
		const curPage = UrlUtil.getCurrentPage();
		const encoder = UrlUtil.URL_TO_HASH_BUILDER[curPage];
		if (!encoder) throw new Error(`No encoder found for page ${curPage}`);
		return encoder(obj);
	},

	decodeHash (hash) {
		return hash.split(HASH_LIST_SEP).map(it => decodeURIComponent(it));
	},

	getCurrentPage () {
		if (typeof window === "undefined") return VeCt.PG_NONE;
		const pSplit = window.location.pathname.split("/");
		let out = pSplit[pSplit.length - 1];
		if (!out.toLowerCase().endsWith(".html")) out += ".html";
		return out;
	},

	/**
	 * All internal URL construction should pass through here, to ensure `static.5etools.com` is used when required.
	 *
	 * @param href the link
	 */
	link (href) {
		function addGetParam (curr) {
			if (href.includes("?")) return `${curr}&v=${VERSION_NUMBER}`;
			else return `${curr}?v=${VERSION_NUMBER}`;
		}

		if (!IS_VTT && IS_DEPLOYED) return addGetParam(`${DEPLOYED_STATIC_ROOT}${href}`);
		else if (IS_DEPLOYED) return addGetParam(href);
		return href;
	},

	unpackSubHash (subHash, unencode) {
		// format is "key:value~list~sep~with~tilde"
		if (subHash.includes(HASH_SUB_KV_SEP)) {
			const keyValArr = subHash.split(HASH_SUB_KV_SEP).map(s => s.trim());
			const out = {};
			let k = keyValArr[0].toLowerCase();
			if (unencode) k = decodeURIComponent(k);
			let v = keyValArr[1].toLowerCase();
			if (unencode) v = decodeURIComponent(v);
			out[k] = v.split(HASH_SUB_LIST_SEP).map(s => s.trim());
			if (out[k].length === 1 && out[k] === HASH_SUB_NONE) out[k] = [];
			return out;
		} else {
			throw new Error(`Badly formatted subhash ${subHash}`)
		}
	},

	/**
	 * @param key The subhash key.
	 * @param values The subhash values.
	 * @param [opts] Options object.
	 * @param [opts.isEncodeBoth] If both the key and values should be URl encoded.
	 * @param [opts.isEncodeKey] If the key should be URL encoded.
	 * @param [opts.isEncodeValues] If the values should be URL encoded.
	 * @returns {string}
	 */
	packSubHash (key, values, opts) {
		opts = opts || {};
		if (opts.isEncodeBoth || opts.isEncodeKey) key = key.toUrlified();
		if (opts.isEncodeBoth || opts.isEncodeValues) values = values.map(it => it.toUrlified());
		return `${key}${HASH_SUB_KV_SEP}${values.join(HASH_SUB_LIST_SEP)}`;
	},

	categoryToPage (category) { return UrlUtil.CAT_TO_PAGE[category]; },
	categoryToHoverPage (category) { return UrlUtil.CAT_TO_HOVER_PAGE[category] || UrlUtil.categoryToPage(category); },

	bindLinkExportButton (filterBox, $btn) {
		$btn = $btn || ListUtil.getOrTabRightButton(`btn-link-export`, `magnet`);
		$btn.addClass("btn-copy-effect")
			.off("click")
			.on("click", async evt => {
				let url = window.location.href;

				const parts = filterBox.getSubHashes({isAddSearchTerm: true});
				parts.unshift(url);

				if (evt.shiftKey && ListUtil.sublist) {
					const toEncode = JSON.stringify(ListUtil.getExportableSublist());
					const part2 = UrlUtil.packSubHash(ListUtil.SUB_HASH_PREFIX, [toEncode], {isEncodeBoth: true});
					parts.push(part2);
				}

				await MiscUtil.pCopyTextToClipboard(parts.join(HASH_PART_SEP));
				JqueryUtil.showCopiedEffect($btn);
			})
			.title("Get Link to Filters (SHIFT adds List)")
	},

	mini: {
		compress (primitive) {
			const type = typeof primitive;
			if (primitive == null) return `x`;
			switch (type) {
				case "boolean": return `b${Number(primitive)}`;
				case "number": return `n${primitive}`;
				case "string": return `s${primitive.toUrlified()}`;
				default: throw new Error(`Unhandled type "${type}"`);
			}
		},

		decompress (raw) {
			const [type, data] = [raw.slice(0, 1), raw.slice(1)];
			switch (type) {
				case "x": return null;
				case "b": return !!Number(data);
				case "n": return Number(data);
				case "s": return String(data);
				default: throw new Error(`Unhandled type "${type}"`);
			}
		},
	},

	class: {
		getIndexedClassEntries (cls) {
			const out = [];

			(cls.classFeatures || []).forEach((lvlFeatureList, ixLvl) => {
				lvlFeatureList
					// don't add "you gain a subclass feature" or ASI's
					.filter(feature => !feature.gainSubclassFeature
						&& feature.name !== "Ability Score Improvement"
						&& feature.name !== "Proficiency Versatility")
					.forEach((feature, ixFeature) => {
						const name = Renderer.findName(feature);
						if (!name) { // tolerate missing names in homebrew
							if (BrewUtil.hasSourceJson(cls.source)) return;
							else throw new Error("Class feature had no name!");
						}
						out.push({
							_type: "classFeature",
							source: cls.source.source || cls.source,
							name,
							hash: `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES](cls)}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({feature: {ixLevel: ixLvl, ixFeature: ixFeature}})}`,
							entry: feature,
							level: ixLvl + 1,
						})
					});
			});

			return out;
		},

		getIndexedSubclassEntries (sc) {
			const out = [];

			const lvlFeatures = sc.subclassFeatures || [];
			sc.source = sc.source || sc.classSource; // default to class source if required

			lvlFeatures.forEach(lvlFeature => {
				lvlFeature.forEach((feature, ixFeature) => {
					const subclassFeatureHash = `${UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: sc.className, source: sc.classSource})}${HASH_PART_SEP}${UrlUtil.getClassesPageStatePart({subclass: sc, feature: {ixLevel: feature.level - 1, ixFeature: ixFeature}})}`;

					const name = Renderer.findName(feature);
					if (!name) { // tolerate missing names in homebrew
						if (BrewUtil.hasSourceJson(sc.source)) return;
						else throw new Error("Subclass feature had no name!");
					}
					out.push({
						_type: "subclassFeature",
						name,
						subclassName: sc.name,
						subclassShortName: sc.shortName,
						source: sc.source.source || sc.source,
						hash: subclassFeatureHash,
						entry: feature,
						level: feature.level,
					});

					if (feature.entries) {
						const namedFeatureParts = feature.entries.filter(it => it.name);
						namedFeatureParts.forEach(it => {
							if (out.find(existing => it.name === existing.name && feature.level === existing.level)) return;
							out.push({
								_type: "subclassFeaturePart",
								name: it.name,
								subclassName: sc.name,
								subclassShortName: sc.shortName,
								source: sc.source.source || sc.source,
								hash: subclassFeatureHash,
								entry: feature,
								level: feature.level,
							});
						});
					}
				});
			});

			return out;
		},
	},

	getStateKeySubclass (sc) { return Parser.stringToSlug(`sub ${sc.shortName || sc.name} ${Parser.sourceJsonToAbv(sc.source)}`); },

	/**
	 * @param opts Options object.
	 * @param [opts.subclass] Subclass (or object of the form `{shortName: "str", source: "str"}`)
	 * @param [opts.feature] Object of the form `{ixLevel: 0, ixFeature: 0}`
	 */
	getClassesPageStatePart (opts) {
		const stateParts = [
			opts.subclass ? `${UrlUtil.getStateKeySubclass(opts.subclass)}=${UrlUtil.mini.compress(true)}` : null,
			opts.feature ? `feature=${UrlUtil.mini.compress(`${opts.feature.ixLevel}-${opts.feature.ixFeature}`)}` : "",
		].filter(Boolean);
		return stateParts.length ? UrlUtil.packSubHash("state", stateParts) : "";
	},
};

UrlUtil.PG_BESTIARY = "bestiary.html";
UrlUtil.PG_SPELLS = "spells.html";
UrlUtil.PG_BACKGROUNDS = "backgrounds.html";
UrlUtil.PG_ITEMS = "items.html";
UrlUtil.PG_CLASSES = "classes.html";
UrlUtil.PG_CONDITIONS_DISEASES = "conditionsdiseases.html";
UrlUtil.PG_FEATS = "feats.html";
UrlUtil.PG_OPT_FEATURES = "optionalfeatures.html";
UrlUtil.PG_PSIONICS = "psionics.html";
UrlUtil.PG_RACES = "races.html";
UrlUtil.PG_REWARDS = "rewards.html";
UrlUtil.PG_VARIANTRULES = "variantrules.html";
UrlUtil.PG_ADVENTURE = "adventure.html";
UrlUtil.PG_ADVENTURES = "adventures.html";
UrlUtil.PG_BOOK = "book.html";
UrlUtil.PG_BOOKS = "books.html";
UrlUtil.PG_DEITIES = "deities.html";
UrlUtil.PG_CULTS_BOONS = "cultsboons.html";
UrlUtil.PG_OBJECTS = "objects.html";
UrlUtil.PG_TRAPS_HAZARDS = "trapshazards.html";
UrlUtil.PG_QUICKREF = "quickreference.html";
UrlUtil.PG_MANAGE_BREW = "managebrew.html";
UrlUtil.PG_MAKE_BREW = "makebrew.html";
UrlUtil.PG_DEMO_RENDER = "renderdemo.html";
UrlUtil.PG_TABLES = "tables.html";
UrlUtil.PG_VEHICLES = "vehicles.html";
UrlUtil.PG_CHARACTERS = "characters.html";
UrlUtil.PG_ACTIONS = "actions.html";
UrlUtil.PG_LANGUAGES = "languages.html";
UrlUtil.PG_STATGEN = "statgen.html";
UrlUtil.PG_LIFEGEN = "lifegen.html";
UrlUtil.PG_NAMES = "names.html";
UrlUtil.PG_DM_SCREEN = "dmscreen.html";
UrlUtil.PG_CR_CALCULATOR = "crcalculator.html";
UrlUtil.PG_ENCOUNTERGEN = "encountergen.html";
UrlUtil.PG_LOOTGEN = "lootgen.html";
UrlUtil.PG_TEXT_CONVERTER = "converter.html";
UrlUtil.PG_CHANGELOG = "changelog.html";
UrlUtil.PG_CHAR_CREATION_OPTIONS = "charcreationoptions.html";
UrlUtil.PG_RECIPES = "recipes.html";
UrlUtil.PG_CLASS_SUBCLASS_FEATURES = "classfeatures.html";

UrlUtil.URL_TO_HASH_BUILDER = {};
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BESTIARY] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BACKGROUNDS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ITEMS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CONDITIONS_DISEASES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_FEATS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OPT_FEATURES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_PSIONICS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RACES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_REWARDS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VARIANTRULES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE] = (it) => UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURES] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ADVENTURE];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK] = (it) => UrlUtil.encodeForHash(it.id);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOKS] = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_BOOK];
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_DEITIES] = (it) => UrlUtil.encodeForHash([it.name, it.pantheon, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CULTS_BOONS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_OBJECTS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TRAPS_HAZARDS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_TABLES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_VEHICLES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_ACTIONS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_LANGUAGES] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CHAR_CREATION_OPTIONS] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_RECIPES] = (it) => `${UrlUtil.encodeForHash([it.name, it.source])}${it._scaleFactor ? `${HASH_PART_SEP}${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}${it._scaleFactor}` : ""}`;
UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = (it) => (it.__prop === "subclassFeature" || it.subclassSource) ? UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"](it) : UrlUtil.URL_TO_HASH_BUILDER["classFeature"](it);
// region Fake pages (props)
UrlUtil.URL_TO_HASH_BUILDER["subclass"] = it => {
	const hashParts = [
		UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_CLASSES]({name: it.className, source: it.classSource}),
		UrlUtil.getClassesPageStatePart({subclass: it}),
	].filter(Boolean);
	return Hist.util.getCleanHash(hashParts.join(HASH_PART_SEP));
};
UrlUtil.URL_TO_HASH_BUILDER["classFeature"] = (it) => UrlUtil.encodeForHash([it.name, it.className, it.classSource, it.level, it.source]);
UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"] = (it) => UrlUtil.encodeForHash([it.name, it.className, it.classSource, it.subclassShortName, it.subclassSource, it.level, it.source]);
UrlUtil.URL_TO_HASH_BUILDER["legendaryGroup"] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER["legendarygroup"] = UrlUtil.URL_TO_HASH_BUILDER["legendaryGroup"];
UrlUtil.URL_TO_HASH_BUILDER["itemEntry"] = (it) => UrlUtil.encodeForHash([it.name, it.source]);
UrlUtil.URL_TO_HASH_BUILDER["itementry"] = UrlUtil.URL_TO_HASH_BUILDER["itemEntry"];
// endregion

UrlUtil.PG_TO_NAME = {};
UrlUtil.PG_TO_NAME[UrlUtil.PG_BESTIARY] = "Bestiary";
UrlUtil.PG_TO_NAME[UrlUtil.PG_SPELLS] = "Spells";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BACKGROUNDS] = "Backgrounds";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ITEMS] = "Items";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASSES] = "Classes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CONDITIONS_DISEASES] = "Conditions & Diseases";
UrlUtil.PG_TO_NAME[UrlUtil.PG_FEATS] = "Feats";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OPT_FEATURES] = "Other Options and Features";
UrlUtil.PG_TO_NAME[UrlUtil.PG_PSIONICS] = "Psionics";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RACES] = "Races";
UrlUtil.PG_TO_NAME[UrlUtil.PG_REWARDS] = "Supernatural Gifts & Rewards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VARIANTRULES] = "Optional, Variant, and Expanded Rules";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ADVENTURES] = "Adventures";
UrlUtil.PG_TO_NAME[UrlUtil.PG_BOOKS] = "Books";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEITIES] = "Deities";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CULTS_BOONS] = "Cults & Supernatural Boons";
UrlUtil.PG_TO_NAME[UrlUtil.PG_OBJECTS] = "Objects";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TRAPS_HAZARDS] = "Traps & Hazards";
UrlUtil.PG_TO_NAME[UrlUtil.PG_QUICKREF] = "Quick Reference";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MANAGE_BREW] = "Homebrew Manager";
UrlUtil.PG_TO_NAME[UrlUtil.PG_MAKE_BREW] = "Homebrew Builder";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DEMO_RENDER] = "Renderer Demo";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TABLES] = "Tables";
UrlUtil.PG_TO_NAME[UrlUtil.PG_VEHICLES] = "Vehicles";
// UrlUtil.PG_TO_NAME[UrlUtil.PG_CHARACTERS] = "";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ACTIONS] = "Actions";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LANGUAGES] = "Languages";
UrlUtil.PG_TO_NAME[UrlUtil.PG_STATGEN] = "Stat Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LIFEGEN] = "This Is Your Life";
UrlUtil.PG_TO_NAME[UrlUtil.PG_NAMES] = "Names";
UrlUtil.PG_TO_NAME[UrlUtil.PG_DM_SCREEN] = "DM Screen";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CR_CALCULATOR] = "CR Calculator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_ENCOUNTERGEN] = "Encounter Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_LOOTGEN] = "Loot Generator";
UrlUtil.PG_TO_NAME[UrlUtil.PG_TEXT_CONVERTER] = "Text Converter";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHANGELOG] = "Changelog";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CHAR_CREATION_OPTIONS] = "Other Character Creation Options";
UrlUtil.PG_TO_NAME[UrlUtil.PG_RECIPES] = "Recipes";
UrlUtil.PG_TO_NAME[UrlUtil.PG_CLASS_SUBCLASS_FEATURES] = "Class & Subclass Features";

UrlUtil.CAT_TO_PAGE = {};
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CREATURE] = UrlUtil.PG_BESTIARY;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SPELL] = UrlUtil.PG_SPELLS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BACKGROUND] = UrlUtil.PG_BACKGROUNDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ITEM] = UrlUtil.PG_ITEMS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = UrlUtil.PG_CLASSES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CONDITION] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FEAT] = UrlUtil.PG_FEATS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELDRITCH_INVOCATION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_METAMAGIC] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_BATTLEMASTER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER_CAVALIER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARCANE_SHOT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OPTIONAL_FEATURE_OTHER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_FIGHTING_STYLE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PSIONIC] = UrlUtil.PG_PSIONICS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RACE] = UrlUtil.PG_RACES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OTHER_REWARD] = UrlUtil.PG_REWARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VARIANT_OPTIONAL_RULE] = UrlUtil.PG_VARIANTRULES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ADVENTURE] = UrlUtil.PG_ADVENTURE;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DEITY] = UrlUtil.PG_DEITIES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_OBJECT] = UrlUtil.PG_OBJECTS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TRAP] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_HAZARD] = UrlUtil.PG_TRAPS_HAZARDS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_QUICKREF] = UrlUtil.PG_QUICKREF;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CULT] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOON] = UrlUtil.PG_CULTS_BOONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_DISEASE] = UrlUtil.PG_CONDITIONS_DISEASES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_TABLE_GROUP] = UrlUtil.PG_TABLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_VEHICLE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PACT_BOON] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ELEMENTAL_DISCIPLINE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ARTIFICER_INFUSION] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_SHIP_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_INFERNAL_WAR_MACHINE_UPGRADE] = UrlUtil.PG_VEHICLES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ONOMANCY_RESONANT] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RUNE_KNIGHT_RUNE] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ALCHEMICAL_FORMULA] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_MANEUVER] = UrlUtil.PG_OPT_FEATURES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_ACTION] = UrlUtil.PG_ACTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LANGUAGE] = UrlUtil.PG_LANGUAGES;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_BOOK] = UrlUtil.PG_BOOK;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_PAGE] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_LEGENDARY_GROUP] = null;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_CHAR_CREATION_OPTIONS] = UrlUtil.PG_CHAR_CREATION_OPTIONS;
UrlUtil.CAT_TO_PAGE[Parser.CAT_ID_RECIPES] = UrlUtil.PG_RECIPES;

UrlUtil.CAT_TO_HOVER_PAGE = {};
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_CLASS_FEATURE] = "classfeature";
UrlUtil.CAT_TO_HOVER_PAGE[Parser.CAT_ID_SUBCLASS_FEATURE] = "subclassfeature";

UrlUtil.HASH_START_CREATURE_SCALED = `${VeCt.HASH_SCALED}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_SPELL_SUMMON = `${VeCt.HASH_SCALED_SPELL_SUMMON}${HASH_SUB_KV_SEP}`;
UrlUtil.HASH_START_CREATURE_SCALED_CLASS_SUMMON = `${VeCt.HASH_SCALED_CLASS_SUMMON}${HASH_SUB_KV_SEP}`;

if (!IS_DEPLOYED && !IS_VTT && typeof window !== "undefined") {
	// for local testing, hotkey to get a link to the current page on the main site
	window.addEventListener("keypress", (e) => {
		if (EventUtil.noModifierKeys(e) && typeof d20 === "undefined") {
			if (e.key === "#") {
				const spl = window.location.href.split("/");
				window.prompt("Copy to clipboard: Ctrl+C, Enter", `https://5etools-mirror-1.github.io/${spl[spl.length - 1]}`);
			}
		}
	});
}

// SORTING =============================================================================================================
SortUtil = {
	ascSort: (a, b) => {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		return SortUtil._ascSort(a, b);
	},

	ascSortProp: (prop, a, b) => { return SortUtil.ascSort(a[prop], b[prop]); },

	ascSortLower: (a, b) => {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		a = a ? a.toLowerCase() : a;
		b = b ? b.toLowerCase() : b;

		return SortUtil._ascSort(a, b);
	},

	ascSortLowerProp: (prop, a, b) => { return SortUtil.ascSortLower(a[prop], b[prop]); },

	// warning: slow
	ascSortNumericalSuffix (a, b) {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}

		function popEndNumber (str) {
			const spl = str.split(" ");
			return spl.last().isNumeric() ? [spl.slice(0, -1).join(" "), Number(spl.last().replace(Parser._numberCleanRegexp, ""))] : [spl.join(" "), 0];
		}

		const [aStr, aNum] = popEndNumber(a.item || a);
		const [bStr, bNum] = popEndNumber(b.item || b);
		const initialSort = SortUtil.ascSort(aStr, bStr);
		if (initialSort) return initialSort;
		return SortUtil.ascSort(aNum, bNum);
	},

	_ascSort: (a, b) => {
		if (b === a) return 0;
		return b < a ? 1 : -1;
	},

	ascSortDate (a, b) {
		return b.getTime() - a.getTime();
	},

	ascSortDateString (a, b) {
		return SortUtil.ascSortDate(new Date(a || "1970-01-0"), new Date(b || "1970-01-0"));
	},

	compareListNames (a, b) { return SortUtil._ascSort(a.name.toLowerCase(), b.name.toLowerCase()); },

	listSort (a, b, opts) {
		opts = opts || {sortBy: "name"};
		if (opts.sortBy === "name") return SortUtil.compareListNames(a, b);
		else return SortUtil._compareByOrDefault_compareByOrDefault(a, b, opts.sortBy);
	},

	_listSort_compareBy (a, b, sortBy) {
		const aValue = typeof a.values[sortBy] === "string" ? a.values[sortBy].toLowerCase() : a.values[sortBy];
		const bValue = typeof b.values[sortBy] === "string" ? b.values[sortBy].toLowerCase() : b.values[sortBy];

		return SortUtil._ascSort(aValue, bValue);
	},

	_compareByOrDefault_compareByOrDefault (a, b, sortBy) {
		return SortUtil._listSort_compareBy(a, b, sortBy) || SortUtil.compareListNames(a, b);
	},

	/**
	 * "Special Equipment" first, then alphabetical
	 */
	_MON_TRAIT_ORDER: [
		"special equipment",
		"shapechanger",
	],
	monTraitSort: (a, b) => {
		if (a.sort != null && b.sort != null) return a.sort - b.sort;
		if (a.sort != null && b.sort == null) return -1;
		if (a.sort == null && b.sort != null) return 1;

		if (!a.name && !b.name) return 0;
		const aClean = a.name.toLowerCase().trim();
		const bClean = b.name.toLowerCase().trim();

		const isOnlyA = a.name.endsWith(" Only)");
		const isOnlyB = b.name.endsWith(" Only)");
		if (!isOnlyA && isOnlyB) return -1;
		if (isOnlyA && !isOnlyB) return 1;

		const ixA = SortUtil._MON_TRAIT_ORDER.indexOf(aClean);
		const ixB = SortUtil._MON_TRAIT_ORDER.indexOf(bClean);
		if (~ixA && ~ixB) return ixA - ixB;
		else if (~ixA) return -1;
		else if (~ixB) return 1;
		else return SortUtil.ascSort(aClean, bClean);
	},

	_alignFirst: ["L", "C"],
	_alignSecond: ["G", "E"],
	alignmentSort: (a, b) => {
		if (a === b) return 0;
		if (SortUtil._alignFirst.includes(a)) return -1;
		if (SortUtil._alignSecond.includes(a)) return 1;
		if (SortUtil._alignFirst.includes(b)) return 1;
		if (SortUtil._alignSecond.includes(b)) return -1;
		return 0;
	},

	ascSortCr (a, b) {
		if (typeof FilterItem !== "undefined") {
			if (a instanceof FilterItem) a = a.item;
			if (b instanceof FilterItem) b = b.item;
		}
		// always put unknown values last
		if (a === "Unknown") a = "998";
		if (b === "Unknown") b = "998";
		if (a === "\u2014" || a == null) a = "999";
		if (b === "\u2014" || b == null) b = "999";
		return SortUtil.ascSort(Parser.crToNumber(a), Parser.crToNumber(b));
	},

	ascSortAtts (a, b) {
		const aSpecial = a === "special";
		const bSpecial = b === "special";
		return aSpecial && bSpecial ? 0 : aSpecial ? 1 : bSpecial ? -1 : Parser.ABIL_ABVS.indexOf(a) - Parser.ABIL_ABVS.indexOf(b);
	},

	initBtnSortHandlers ($wrpBtnsSort, list) {
		let $dispCaretInitial = null;
		const $dispCarets = [];

		$wrpBtnsSort.find(".sort").each((i, e) => {
			const $btnSort = $(e);
			const $dispCaret = SortUtil._initBtnSortHandlers_getAddCaret($btnSort);

			$dispCarets.push($dispCaret);

			if ($btnSort.data("sort") === list.sortBy) $dispCaretInitial = $dispCaret;

			$btnSort.click(evt => {
				evt.stopPropagation();
				const direction = list.sortDir === "asc" ? "desc" : "asc";
				SortUtil._initBtnSortHandlers_showCaret({$dispCarets, $dispCaret, direction});
				list.sort($btnSort.data("sort"), direction);
			});
		});

		$dispCaretInitial = $dispCaretInitial || $dispCarets[0]; // Fall back on displaying the first caret

		SortUtil._initBtnSortHandlers_showCaret({$dispCaret: $dispCaretInitial, $dispCarets, direction: list.sortDir});
	},

	_initBtnSortHandlers_getAddCaret ($btnSort) {
		const $existing = $btnSort.find(`.lst__caret`);
		if ($existing.length) return $existing;
		return $(`<span class="lst__caret"></span>`).appendTo($btnSort);
	},

	_initBtnSortHandlers_showCaret (
		{
			$dispCaret,
			$dispCarets,
			direction,
		},
	) {
		$dispCarets.forEach($it => $it.removeClass("lst__caret--active"));
		$dispCaret.addClass("lst__caret--active").toggleClass("lst__caret--reverse", direction === "asc");
	},

	ascSortAdventure (a, b) {
		return SortUtil.ascSortDateString(b.published, a.published)
			|| SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "")
			|| SortUtil.ascSortLower(a.storyline, b.storyline)
			|| SortUtil.ascSort(a.level?.start ?? 20, b.level?.start ?? 20)
			|| SortUtil.ascSortLower(a.name, b.name);
	},

	ascSortBook (a, b) {
		return SortUtil.ascSortDateString(b.published, a.published)
			|| SortUtil.ascSortLower(a.parentSource || "", b.parentSource || "")
			|| SortUtil.ascSortLower(a.name, b.name);
	},

	_ITEM_RARITY_ORDER: ["none", "common", "uncommon", "rare", "very rare", "legendary", "artifact", "varies", "unknown (magic)", "unknown"],
	ascSortItemRarity (a, b) {
		const ixA = SortUtil._ITEM_RARITY_ORDER.indexOf(a);
		const ixB = SortUtil._ITEM_RARITY_ORDER.indexOf(b);
		return (~ixA ? ixA : Number.MAX_SAFE_INTEGER) - (~ixB ? ixB : Number.MAX_SAFE_INTEGER);
	},
};

// JSON LOADING ========================================================================================================
DataUtil = {
	_loading: {},
	_loaded: {},
	_merging: {},
	_merged: {},

	async _pLoad (url) {
		if (DataUtil._loading[url]) {
			await DataUtil._loading[url];
			return DataUtil._loaded[url];
		}

		DataUtil._loading[url] = new Promise((resolve, reject) => {
			const request = new XMLHttpRequest();
			request.open("GET", url, true);
			request.overrideMimeType("application/json");
			request.onload = function () {
				try {
					DataUtil._loaded[url] = JSON.parse(this.response);
					resolve();
				} catch (e) {
					reject(new Error(`Could not parse JSON from ${url}: ${e.message}`));
				}
			};
			request.onerror = (e) => reject(new Error(`Error during JSON request: ${e.target.status}`));
			request.send();
		});

		await DataUtil._loading[url];
		return DataUtil._loaded[url];
	},

	async loadJSON (url, ...otherData) {
		const procUrl = UrlUtil.link(url);

		let ident = procUrl;
		let data;
		try {
			data = await DataUtil._pLoad(procUrl);
		} catch (e) {
			setTimeout(() => { throw e; })
		}

		// Fallback to the un-processed URL
		if (!data) {
			ident = url;
			data = await DataUtil._pLoad(url);
		}

		await DataUtil.pDoMetaMerge(ident, data);

		return data;
	},

	async pDoMetaMerge (ident, data, options) {
		DataUtil._merging[ident] = DataUtil._merging[ident] || DataUtil._pDoMetaMerge(ident, data, options);
		await DataUtil._merging[ident];
		return DataUtil._merged[ident];
	},

	_pDoMetaMerge_handleCopyProp (prop, arr, entry, options) {
		if (!entry._copy) return;
		const fnMergeCopy = DataUtil[prop]?.pMergeCopy;
		if (!fnMergeCopy) throw new Error(`No dependency _copy merge strategy specified for property "${prop}"`);
		return fnMergeCopy(arr, entry, options);
	},

	async _pDoMetaMerge (ident, data, options) {
		if (data._meta) {
			const loadedSourceIds = new Set();

			if (data._meta.dependencies) {
				await Promise.all(Object.entries(data._meta.dependencies).map(async ([dataProp, sourceIds]) => {
					sourceIds.forEach(sourceId => loadedSourceIds.add(sourceId));

					if (!data[dataProp]) return; // if e.g. monster dependencies are declared, but there are no monsters to merge with, bail out

					const isHasInternalCopies = (data._meta.internalCopies || []).includes(dataProp);

					const dependencyData = await Promise.all(sourceIds.map(sourceId => DataUtil.pLoadByMeta(dataProp, sourceId)));

					const flatDependencyData = dependencyData.map(dd => dd[dataProp]).flat();
					await Promise.all(data[dataProp].map(entry => DataUtil._pDoMetaMerge_handleCopyProp(dataProp, flatDependencyData, entry, {...options, isErrorOnMissing: !isHasInternalCopies})));
				}));
				delete data._meta.dependencies;
			}

			if (data._meta.internalCopies) {
				for (const prop of data._meta.internalCopies) {
					if (!data[prop]) continue;
					for (const entry of data[prop]) {
						await DataUtil._pDoMetaMerge_handleCopyProp(prop, data[prop], entry, {...options, isErrorOnMissing: true});
					}
				}
				delete data._meta.internalCopies;
			}

			// Load any other included data
			if (data._meta.includes) {
				const includesData = await Promise.all(Object.entries(data._meta.includes).map(async ([dataProp, sourceIds]) => {
					// Avoid re-loading any sources we already loaded as dependencies
					sourceIds = sourceIds.filter(it => !loadedSourceIds.has(it));

					sourceIds.forEach(sourceId => loadedSourceIds.add(sourceId));

					// This loads the brew as a side-effect
					const includesData = await Promise.all(sourceIds.map(sourceId => DataUtil.pLoadByMeta(dataProp, sourceId)));

					const flatIncludesData = includesData.map(dd => dd[dataProp]).flat();
					return {dataProp, flatIncludesData};
				}));
				delete data._meta.includes;

				// Add the includes data to our current data
				includesData.forEach(({dataProp, flatIncludesData}) => {
					data[dataProp] = [...data[dataProp] || [], ...flatIncludesData];
				});
			}
		}

		if (data._meta && data._meta.otherSources) {
			await Promise.all(Object.entries(data._meta.otherSources).map(async ([dataProp, sourceIds]) => {
				const additionalData = await Promise.all(Object.entries(sourceIds).map(async ([sourceId, findWith]) => ({
					findWith,
					dataOther: await DataUtil.pLoadByMeta(dataProp, sourceId),
				})));

				additionalData.forEach(({findWith, dataOther}) => {
					const toAppend = dataOther[dataProp].filter(it => it.otherSources && it.otherSources.find(os => os.source === findWith));
					if (toAppend.length) data[dataProp] = (data[dataProp] || []).concat(toAppend);
				});
			}));
			delete data._meta.otherSources;
		}

		const props = Object.keys(data);
		for (const prop of props) {
			if (!data[prop] || !(data[prop] instanceof Array) || !data[prop].length) continue;

			if (DataUtil[prop]?.pPostProcess) await DataUtil[prop]?.pPostProcess(data);
		}

		DataUtil._merged[ident] = data;
	},

	getCleanFilename (filename) {
		return filename.replace(/[^-_a-zA-Z0-9]/g, "_");
	},

	getCsv (headers, rows) {
		function escapeCsv (str) {
			return `"${str.replace(/"/g, `""`).replace(/ +/g, " ").replace(/\n\n+/gi, "\n\n")}"`;
		}

		function toCsv (row) {
			return row.map(str => escapeCsv(str)).join(",");
		}

		return `${toCsv(headers)}\n${rows.map(r => toCsv(r)).join("\n")}`;
	},

	userDownload (filename, data, {fileType = null, isSipAdditionalMetadata = false, propVersion = "siteVersion", valVersion = VERSION_NUMBER} = {}) {
		filename = `${filename}.json`
		if (isSipAdditionalMetadata || data instanceof Array) return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");

		data = {[propVersion]: valVersion, ...data};
		if (fileType != null) data = {fileType, ...data};
		return DataUtil._userDownload(filename, JSON.stringify(data, null, "\t"), "text/json");
	},

	userDownloadText (filename, string) {
		return DataUtil._userDownload(filename, string, "text/plain");
	},

	_userDownload (filename, data, mimeType) {
		const a = document.createElement("a");
		const t = new Blob([data], {type: mimeType});
		a.href = window.URL.createObjectURL(t);
		a.download = filename;
		a.dispatchEvent(new MouseEvent("click", {bubbles: true, cancelable: true, view: window}));
		setTimeout(() => window.URL.revokeObjectURL(a.href), 100);
	},

	/** Always returns an array of files, even in "single" mode. */
	pUserUpload ({isMultiple = false, expectedFileType = null, propVersion = "siteVersion"} = {}) {
		return new Promise(resolve => {
			const $iptAdd = $(`<input type="file" ${isMultiple ? "multiple" : ""} accept=".json" style="position: fixed; top: -100px; left: -100px; display: none;">`).on("change", (evt) => {
				const input = evt.target;

				const reader = new FileReader();
				let readIndex = 0;
				const out = [];
				const errs = [];
				reader.onload = async () => {
					const name = input.files[readIndex - 1].name;
					const text = reader.result;

					try {
						const json = JSON.parse(text);

						const isSkipFile = expectedFileType != null && json.fileType && json.fileType !== expectedFileType && !(await InputUiUtil.pGetUserBoolean({
							textYes: "Yes",
							textNo: "Cancel",
							title: "File Type Mismatch",
							htmlDescription: `The file "${name}" has the type "${json.fileType}" when the expected file type was "${expectedFileType}".<br>Are you sure you want to upload this file?`,
						}));

						if (!isSkipFile) {
							delete json.fileType;
							delete json[propVersion];

							out.push(json);
						}
					} catch (e) {
						errs.push({filename: name, message: e.message});
					}

					if (input.files[readIndex]) reader.readAsText(input.files[readIndex++]);
					else resolve({jsons: out, errors: errs});
				};

				reader.readAsText(input.files[readIndex++]);
			}).appendTo(document.body);
			$iptAdd.click();
		});
	},

	doHandleFileLoadErrorsGeneric (errors) {
		if (!errors) return;
		errors.forEach(err => {
			JqueryUtil.doToast({
				content: `Could not load file "${err.filename}": <code>${err.message}</code>. ${VeCt.STR_SEE_CONSOLE}`,
				type: "danger",
			});
		});
	},

	cleanJson (cpy) {
		cpy.name = cpy._displayName || cpy.name;
		delete cpy.uniqueId;
		DataUtil.__cleanJsonObject(cpy);
		return cpy;
	},

	__cleanJsonObject (obj) {
		if (obj == null) return obj;
		if (typeof obj === "object") {
			if (obj instanceof Array) {
				obj.forEach(it => DataUtil.__cleanJsonObject(it));
			} else {
				Object.entries(obj).forEach(([k, v]) => {
					if ((k.startsWith("_") && k !== "_") || k === "customHashId") delete obj[k];
					else DataUtil.__cleanJsonObject(v);
				});
			}
		}
	},

	_MULTI_SOURCE_PROP_TO_DIR: {
		"monster": "bestiary",
		"monsterFluff": "bestiary",
		"spell": "spells",
		"spellFluff": "spells",
		"class": "class",
		"subclass": "class",
	},
	_MULTI_SOURCE_PROP_TO_INDEX_NAME: {
		"monster": "index.json",
		"spell": "index.json",
		"monsterFluff": "fluff-index.json",
		"spellFluff": "fluff-index.json",
		"class": "index.json",
		"subclass": "index.json",
	},
	async pLoadByMeta (prop, source) {
		// TODO(future) expand support

		switch (prop) {
			// region Multi-source
			case "monster":
			case "spell":
			case "monsterFluff":
			case "spellFluff":
			case "class":
			case "subclass": {
				const baseUrlPart = `${Renderer.get().baseUrl}data/${DataUtil._MULTI_SOURCE_PROP_TO_DIR[prop]}`;
				const index = await DataUtil.loadJSON(`${baseUrlPart}/${DataUtil._MULTI_SOURCE_PROP_TO_INDEX_NAME[prop]}`);
				if (index[source]) return DataUtil.loadJSON(`${baseUrlPart}/${index[source]}`);

				return DataUtil.pLoadBrewBySource(source);
			}
			// endregion

			// region Special
			case "item":
			case "itemGroup": {
				const data = await DataUtil.item.loadRawJSON();
				if (data[prop] && data[prop].some(it => it.source === source)) return data;
				return DataUtil.pLoadBrewBySource(source);
			}
			case "race": {
				const data = await DataUtil.race.loadJSON({isAddBaseRaces: true});
				if (data[prop] && data[prop].some(it => it.source === source)) return data;
				return DataUtil.pLoadBrewBySource(source);
			}
			// endregion

			// region Standard
			default: {
				const impl = DataUtil[prop];
				if (impl && impl.getDataUrl) {
					const data = await DataUtil.loadJSON(impl.getDataUrl());
					if (data[prop] && data[prop].some(it => it.source === source)) return data;

					return DataUtil.pLoadBrewBySource(source);
				}

				throw new Error(`Could not get loadable URL for \`${JSON.stringify({key: prop, value: source})}\``);
			}
			// endregion
		}
	},

	// TODO(Future) Note that a case-insensitive variant of this is built into the renderer, which could be factored out
	//   to this level if required.
	async pLoadBrewBySource (source, {isSilent = true} = {}) {
		const brewIndex = await DataUtil.brew.pLoadSourceIndex();
		if (!brewIndex[source]) {
			if (isSilent) return null;
			throw new Error(`Neither base nor brew index contained source "${source}"`);
		}

		const urlRoot = await StorageUtil.pGet(`HOMEBREW_CUSTOM_REPO_URL`);
		const brewUrl = DataUtil.brew.getFileUrl(brewIndex[source], urlRoot);
		await BrewUtil.pDoHandleBrewJson((await DataUtil.loadJSON(brewUrl)), UrlUtil.getCurrentPage());
		return DataUtil.loadJSON(brewUrl);
	},

	// region Dbg
	dbg: {
		isTrackCopied: false,
	},
	// endregion

	generic: {
		_MERGE_REQUIRES_PRESERVE_BASE: {
			page: true,
			otherSources: true,
			srd: true,
			hasFluff: true,
			hasFluffImages: true,
			hasToken: true,
		},

		_walker_replaceTxt: null,

		/**
		 * @param uid
		 * @param tag
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		unpackUid (uid, tag, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, source, displayText, ...others] = uid.split("|").map(it => it.trim());

			source = source || Parser.getTagSource(tag, source);
			if (opts.isLower) source = source.toLowerCase();

			return {
				name,
				source,
				displayText,
				others,
			};
		},

		async _pMergeCopy (impl, page, entryList, entry, options) {
			if (!entry._copy) return;

			const hash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);
			const it = impl._mergeCache[hash] || DataUtil.generic._pMergeCopy_search(impl, page, entryList, entry, options);

			if (!it) {
				if (options.isErrorOnMissing) {
					// In development/script mode, throw an exception
					if (!IS_DEPLOYED && !IS_VTT) throw new Error(`Could not find "${page}" entity "${entry._copy.name}" ("${entry._copy.source}") to copy in copier "${entry.name}" ("${entry.source}")`);
				}
				return;
			}

			if (DataUtil.dbg.isTrackCopied) it.dbg_isCopied = true;
			// Handle recursive copy
			if (it._copy) await DataUtil.generic._pMergeCopy(impl, page, entryList, it, options);
			return DataUtil.generic._pApplyCopy(impl, MiscUtil.copy(it), entry, options);
		},

		_pMergeCopy_search (impl, page, entryList, entry, options) {
			const entryHash = UrlUtil.URL_TO_HASH_BUILDER[page](entry._copy);
			return entryList.find(it => {
				const hash = UrlUtil.URL_TO_HASH_BUILDER[page](it);
				impl._mergeCache[hash] = it;
				return hash === entryHash;
			});
		},

		async _pApplyCopy (impl, copyFrom, copyTo, options = {}) {
			if (options.doKeepCopy) copyTo.__copy = MiscUtil.copy(copyFrom);

			// convert everything to arrays
			function normaliseMods (obj) {
				Object.entries(obj._mod).forEach(([k, v]) => {
					if (!(v instanceof Array)) obj._mod[k] = [v];
				});
			}

			const copyMeta = copyTo._copy || {};

			if (copyMeta._mod) normaliseMods(copyMeta);

			// fetch and apply any external traits -- append them to existing copy mods where available
			let racials = null;
			if (copyMeta._trait) {
				const traitData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/traits.json`);
				racials = traitData.trait.find(t => t.name.toLowerCase() === copyMeta._trait.name.toLowerCase() && t.source.toLowerCase() === copyMeta._trait.source.toLowerCase());
				if (!racials) throw new Error(`Could not find traits to apply with name "${copyMeta._trait.name}" and source "${copyMeta._trait.source}"`);
				racials = MiscUtil.copy(racials);

				if (racials.apply._mod) {
					normaliseMods(racials.apply);

					if (copyMeta._mod) {
						Object.entries(racials.apply._mod).forEach(([k, v]) => {
							if (copyMeta._mod[k]) copyMeta._mod[k] = copyMeta._mod[k].concat(v);
							else copyMeta._mod[k] = v;
						});
					} else copyMeta._mod = racials.apply._mod;
				}

				delete copyMeta._trait;
			}

			const copyToRootProps = new Set(Object.keys(copyTo));

			// copy over required values
			Object.keys(copyFrom).forEach(k => {
				if (copyTo[k] === null) return delete copyTo[k];
				if (copyTo[k] == null) {
					if (DataUtil.generic._MERGE_REQUIRES_PRESERVE_BASE[k] || impl._MERGE_REQUIRES_PRESERVE[k]) {
						if (copyTo._copy._preserve && copyTo._copy._preserve[k]) copyTo[k] = copyFrom[k];
					} else copyTo[k] = copyFrom[k];
				}
			});

			// apply any root racial properties after doing base copy
			if (racials && racials.apply._root) {
				Object.entries(racials.apply._root)
					.filter(([k, v]) => !copyToRootProps.has(k)) // avoid overwriting any real root properties
					.forEach(([k, v]) => copyTo[k] = v);
			}

			// mod helpers /////////////////
			function doEnsureArray (obj, prop) {
				if (!(obj[prop] instanceof Array)) obj[prop] = [obj[prop]];
			}

			function getRegexFromReplaceModInfo (replace, flags) {
				return new RegExp(replace, `g${flags || ""}`);
			}

			function doReplaceStringHandler (re, withStr, str) {
				// TODO(Future) may need to have this handle replaces inside _some_ tags
				const split = Renderer.splitByTags(str);
				const len = split.length;
				for (let i = 0; i < len; ++i) {
					if (split[i].startsWith("{@")) continue;
					split[i] = split[i].replace(re, withStr);
				}
				return split.join("");
			}

			function doMod_appendStr (modInfo, prop) {
				if (copyTo[prop]) copyTo[prop] = `${copyTo[prop]}${modInfo.joiner || ""}${modInfo.str}`;
				else copyTo[prop] = modInfo.str;
			}

			function doMod_replaceName (modInfo, prop) {
				if (!copyTo[prop]) return;

				DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
				const re = getRegexFromReplaceModInfo(modInfo.replace, modInfo.flags);
				const handlers = {string: doReplaceStringHandler.bind(null, re, modInfo.with)};

				copyTo[prop].forEach(it => {
					if (it.name) it.name = DataUtil.generic._walker_replaceTxt.walk(it.name, handlers);
				});
			}

			function doMod_replaceTxt (modInfo, prop) {
				if (!copyTo[prop]) return;

				DataUtil.generic._walker_replaceTxt = DataUtil.generic._walker_replaceTxt || MiscUtil.getWalker();
				const re = getRegexFromReplaceModInfo(modInfo.replace, modInfo.flags);
				const handlers = {string: doReplaceStringHandler.bind(null, re, modInfo.with)};

				const props = modInfo.props || [null, "entries", "headerEntries", "footerEntries"];
				if (!props.length) return;

				if (props.includes(null)) {
					// Handle any pure strings, e.g. `"legendaryHeader"`
					copyTo[prop] = copyTo[prop].map(it => {
						if (typeof it !== "string") return it;
						return DataUtil.generic._walker_replaceTxt.walk(it, handlers);
					});
				}

				copyTo[prop].forEach(it => {
					props.forEach(prop => {
						if (prop == null) return;
						if (it[prop]) it[prop] = DataUtil.generic._walker_replaceTxt.walk(it[prop], handlers);
					});
				});
			}

			function doMod_prependArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				copyTo[prop] = copyTo[prop] ? modInfo.items.concat(copyTo[prop]) : modInfo.items
			}

			function doMod_appendArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				copyTo[prop] = copyTo[prop] ? copyTo[prop].concat(modInfo.items) : modInfo.items
			}

			function doMod_appendIfNotExistsArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				if (!copyTo[prop]) return copyTo[prop] = modInfo.items;
				copyTo[prop] = copyTo[prop].concat(modInfo.items.filter(it => !copyTo[prop].some(x => CollectionUtil.deepEquals(it, x))));
			}

			function doMod_replaceArr (modInfo, prop, isThrow = true) {
				doEnsureArray(modInfo, "items");

				if (!copyTo[prop]) {
					if (isThrow) throw new Error(`Could not find "${prop}" array`);
					return false;
				}

				let ixOld;
				if (modInfo.replace.regex) {
					const re = new RegExp(modInfo.replace.regex, modInfo.replace.flags || "");
					ixOld = copyTo[prop].findIndex(it => it.name ? re.test(it.name) : typeof it === "string" ? re.test(it) : false);
				} else if (modInfo.replace.index != null) {
					ixOld = modInfo.replace.index;
				} else {
					ixOld = copyTo[prop].findIndex(it => it.name ? it.name === modInfo.replace : it === modInfo.replace);
				}

				if (~ixOld) {
					copyTo[prop].splice(ixOld, 1, ...modInfo.items);
					return true;
				} else if (isThrow) throw new Error(`Could not find "${prop}" item with name "${modInfo.replace}" to replace`);
				return false;
			}

			function doMod_replaceOrAppendArr (modInfo, prop) {
				const didReplace = doMod_replaceArr(modInfo, prop, false);
				if (!didReplace) doMod_appendArr(modInfo, prop);
			}

			function doMod_insertArr (modInfo, prop) {
				doEnsureArray(modInfo, "items");
				if (!copyTo[prop]) throw new Error(`Could not find "${prop}" array`);
				copyTo[prop].splice(modInfo.index, 0, ...modInfo.items);
			}

			function doMod_removeArr (modInfo, prop) {
				if (modInfo.names) {
					doEnsureArray(modInfo, "names");
					modInfo.names.forEach(nameToRemove => {
						const ixOld = copyTo[prop].findIndex(it => it.name === nameToRemove);
						if (~ixOld) copyTo[prop].splice(ixOld, 1);
						else {
							if (!modInfo.force) throw new Error(`Could not find "${prop}" item with name "${nameToRemove}" to remove`);
						}
					});
				} else if (modInfo.items) {
					doEnsureArray(modInfo, "items");
					modInfo.items.forEach(itemToRemove => {
						const ixOld = copyTo[prop].findIndex(it => it === itemToRemove);
						if (~ixOld) copyTo[prop].splice(ixOld, 1);
						else throw new Error(`Could not find "${prop}" item "${itemToRemove}" to remove`);
					});
				} else throw new Error(`One of "names" or "items" must be provided!`)
			}

			function doMod_calculateProp (modInfo, prop) {
				copyTo[prop] = copyTo[prop] || {};
				const toExec = modInfo.formula.replace(/<\$([^$]+)\$>/g, (...m) => {
					switch (m[1]) {
						case "prof_bonus": return Parser.crToPb(copyTo.cr);
						case "dex_mod": return Parser.getAbilityModNumber(copyTo.dex);
						default: throw new Error(`Unknown variable "${m[1]}"`);
					}
				});
				// eslint-disable-next-line no-eval
				copyTo[prop][modInfo.prop] = eval(toExec);
			}

			function doMod_scalarAddProp (modInfo, prop) {
				function applyTo (k) {
					const out = Number(copyTo[prop][k]) + modInfo.scalar;
					const isString = typeof copyTo[prop][k] === "string";
					copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
				}

				if (!copyTo[prop]) return;
				if (modInfo.prop === "*") Object.keys(copyTo[prop]).forEach(k => applyTo(k));
				else applyTo(modInfo.prop);
			}

			function doMod_scalarMultProp (modInfo, prop) {
				function applyTo (k) {
					let out = Number(copyTo[prop][k]) * modInfo.scalar;
					if (modInfo.floor) out = Math.floor(out);
					const isString = typeof copyTo[prop][k] === "string";
					copyTo[prop][k] = isString ? `${out >= 0 ? "+" : ""}${out}` : out;
				}

				if (!copyTo[prop]) return;
				if (modInfo.prop === "*") Object.keys(copyTo[prop]).forEach(k => applyTo(k));
				else applyTo(modInfo.prop);
			}

			function doMod_addSenses (modInfo) {
				doEnsureArray(modInfo, "senses");
				copyTo.senses = copyTo.senses || [];
				modInfo.senses.forEach(sense => {
					let found = false;
					for (let i = 0; i < copyTo.senses.length; ++i) {
						const m = new RegExp(`${sense.type} (\\d+)`, "i").exec(copyTo.senses[i]);
						if (m) {
							found = true;
							// if the creature already has a greater sense of this type, do nothing
							if (Number(m[1]) < sense.type) {
								copyTo.senses[i] = `${sense.type} ${sense.range} ft.`;
							}
							break;
						}
					}

					if (!found) copyTo.senses.push(`${sense.type} ${sense.range} ft.`);
				});
			}

			function doMod_addSaves (modInfo) {
				copyTo.save = copyTo.save || {};
				Object.entries(modInfo.saves).forEach(([save, mode]) => {
					// mode: 1 = proficient; 2 = expert
					const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[save]);
					const asText = total >= 0 ? `+${total}` : total;
					if (copyTo.save && copyTo.save[save]) {
						// update only if ours is larger (prevent reduction in save)
						if (Number(copyTo.save[save]) < total) copyTo.save[save] = asText;
					} else copyTo.save[save] = asText;
				});
			}

			function doMod_addSkills (modInfo) {
				copyTo.skill = copyTo.skill || {};
				Object.entries(modInfo.skills).forEach(([skill, mode]) => {
					// mode: 1 = proficient; 2 = expert
					const total = mode * Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(copyTo[Parser.skillToAbilityAbv(skill)]);
					const asText = total >= 0 ? `+${total}` : total;
					if (copyTo.skill && copyTo.skill[skill]) {
						// update only if ours is larger (prevent reduction in skill score)
						if (Number(copyTo.skill[skill]) < total) copyTo.skill[skill] = asText;
					} else copyTo.skill[skill] = asText;
				});
			}

			function doMod_addAllSaves (modInfo) {
				// debugger
				return doMod_addSaves({
					mode: "addSaves",
					saves: Object.keys(Parser.ATB_ABV_TO_FULL).mergeMap(it => ({[it]: modInfo.saves})),
				});
			}

			function doMod_addAllSkills (modInfo) {
				// debugger
				return doMod_addSkills({
					mode: "addSkills",
					skills: Object.keys(Parser.SKILL_TO_ATB_ABV).mergeMap(it => ({[it]: modInfo.skills})),
				});
			}

			function doMod_addSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`Creature did not have a spellcasting property!`);

				// TODO could accept a "position" or "name" parameter should spells need to be added to other spellcasting traits
				const spellcasting = copyTo.spellcasting[0];

				if (modInfo.spells) {
					const spells = spellcasting.spells;

					Object.keys(modInfo.spells).forEach(k => {
						if (!spells[k]) spells[k] = modInfo.spells[k];
						else {
							// merge the objects
							const spellCategoryNu = modInfo.spells[k];
							const spellCategoryOld = spells[k];
							Object.keys(spellCategoryNu).forEach(kk => {
								if (!spellCategoryOld[kk]) spellCategoryOld[kk] = spellCategoryNu[kk];
								else {
									if (typeof spellCategoryOld[kk] === "object") {
										if (spellCategoryOld[kk] instanceof Array) spellCategoryOld[kk] = spellCategoryOld[kk].concat(spellCategoryNu[kk]).sort(SortUtil.ascSortLower);
										else throw new Error(`Object at key ${kk} not an array!`);
									} else spellCategoryOld[kk] = spellCategoryNu[kk];
								}
							});
						}
					});
				}

				if (modInfo.will) {
					modInfo.will.forEach(sp => (modInfo.will = modInfo.will || []).push(sp));
				}

				if (modInfo.daily) {
					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						spellcasting.daily = spellcasting.daily || {};

						if (modInfo.daily[i]) {
							modInfo.daily[i].forEach(sp => (spellcasting.daily[i] = spellcasting.daily[i] || []).push(sp));
						}

						if (modInfo.daily[e]) {
							modInfo.daily[e].forEach(sp => (spellcasting.daily[e] = spellcasting.daily[e] || []).push(sp));
						}
					}
				}
			}

			function doMod_replaceSpells (modInfo) {
				if (!copyTo.spellcasting) throw new Error(`Creature did not have a spellcasting property!`);

				// TODO could accept a "position" or "name" parameter should spells need to be added to other spellcasting traits
				const spellcasting = copyTo.spellcasting[0];

				const handleReplace = (curSpells, replaceMeta, k) => {
					doEnsureArray(replaceMeta, "with");

					const ix = curSpells[k].indexOf(replaceMeta.replace);
					if (~ix) {
						curSpells[k].splice(ix, 1, ...replaceMeta.with);
						curSpells[k].sort(SortUtil.ascSortLower);
					} else throw new Error(`Could not find spell "${replaceMeta.replace}" to replace`);
				};

				if (modInfo.spells) {
					const trait0 = spellcasting.spells;
					Object.keys(modInfo.spells).forEach(k => { // k is e.g. "4"
						if (trait0[k]) {
							const replaceMetas = modInfo.spells[k];
							const curSpells = trait0[k];
							replaceMetas.forEach(replaceMeta => handleReplace(curSpells, replaceMeta, "spells"));
						}
					});
				}

				// TODO should be extended  to handle all non-slot-based spellcasters
				if (modInfo.daily) {
					for (let i = 1; i <= 9; ++i) {
						const e = `${i}e`;

						if (modInfo.daily[i]) {
							modInfo.daily[i].forEach(replaceMeta => handleReplace(spellcasting.daily, replaceMeta, i));
						}

						if (modInfo.daily[e]) {
							modInfo.daily[e].forEach(replaceMeta => handleReplace(spellcasting.daily, replaceMeta, e));
						}
					}
				}
			}

			function doMod_scalarAddHit (modInfo, prop) {
				if (!copyTo[prop]) return;
				copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@hit ([-+]?\d+)}/g, (m0, m1) => `{@hit ${Number(m1) + modInfo.scalar}}`))
			}

			function doMod_scalarAddDc (modInfo, prop) {
				if (!copyTo[prop]) return;
				copyTo[prop] = JSON.parse(JSON.stringify(copyTo[prop]).replace(/{@dc (\d+)}/g, (m0, m1) => `{@dc ${Number(m1) + modInfo.scalar}}`));
			}

			function doMod_maxSize (modInfo) {
				const ixCur = Parser.SIZE_ABVS.indexOf(copyTo.size);
				const ixMax = Parser.SIZE_ABVS.indexOf(modInfo.max);
				if (ixCur < 0 || ixMax < 0) throw new Error(`Unhandled size!`);
				copyTo.size = Parser.SIZE_ABVS[Math.min(ixCur, ixMax)]
			}

			function doMod_scalarMultXp (modInfo) {
				function getOutput (input) {
					let out = input * modInfo.scalar;
					if (modInfo.floor) out = Math.floor(out);
					return out;
				}

				if (copyTo.cr.xp) copyTo.cr.xp = getOutput(copyTo.cr.xp);
				else {
					const curXp = Parser.crToXpNumber(copyTo.cr);
					if (!copyTo.cr.cr) copyTo.cr = {cr: copyTo.cr};
					copyTo.cr.xp = getOutput(curXp);
				}
			}

			function doMod (modInfos, ...properties) {
				function handleProp (prop) {
					modInfos.forEach(modInfo => {
						if (typeof modInfo === "string") {
							switch (modInfo) {
								case "remove": return delete copyTo[prop];
								default: throw new Error(`Unhandled mode: ${modInfo}`);
							}
						} else {
							switch (modInfo.mode) {
								case "appendStr": return doMod_appendStr(modInfo, prop);
								case "replaceName": return doMod_replaceName(modInfo, prop);
								case "replaceTxt": return doMod_replaceTxt(modInfo, prop);
								case "prependArr": return doMod_prependArr(modInfo, prop);
								case "appendArr": return doMod_appendArr(modInfo, prop);
								case "replaceArr": return doMod_replaceArr(modInfo, prop);
								case "replaceOrAppendArr": return doMod_replaceOrAppendArr(modInfo, prop);
								case "appendIfNotExistsArr": return doMod_appendIfNotExistsArr(modInfo, prop);
								case "insertArr": return doMod_insertArr(modInfo, prop);
								case "removeArr": return doMod_removeArr(modInfo, prop);
								case "calculateProp": return doMod_calculateProp(modInfo, prop);
								case "scalarAddProp": return doMod_scalarAddProp(modInfo, prop);
								case "scalarMultProp": return doMod_scalarMultProp(modInfo, prop);
								// region Bestiary specific
								case "addSenses": return doMod_addSenses(modInfo);
								case "addSaves": return doMod_addSaves(modInfo);
								case "addSkills": return doMod_addSkills(modInfo);
								case "addAllSaves": return doMod_addAllSaves(modInfo);
								case "addAllSkills": return doMod_addAllSkills(modInfo);
								case "addSpells": return doMod_addSpells(modInfo);
								case "replaceSpells": return doMod_replaceSpells(modInfo);
								case "scalarAddHit": return doMod_scalarAddHit(modInfo, prop);
								case "scalarAddDc": return doMod_scalarAddDc(modInfo, prop);
								case "maxSize": return doMod_maxSize(modInfo);
								case "scalarMultXp": return doMod_scalarMultXp(modInfo);
								// endregion
								default: throw new Error(`Unhandled mode: ${modInfo.mode}`);
							}
						}
					});
				}

				properties.forEach(prop => handleProp(prop));
				// special case for "no property" modifications, i.e. underscore-key'd
				if (!properties.length) handleProp();
			}

			// apply mods
			if (copyMeta._mod) {
				// pre-convert any dynamic text
				Object.entries(copyMeta._mod).forEach(([k, v]) => {
					copyMeta._mod[k] = JSON.parse(
						JSON.stringify(v)
							.replace(/<\$([^$]+)\$>/g, (...m) => {
								const parts = m[1].split("__");

								switch (parts[0]) {
									case "name": return copyTo.name;
									case "short_name":
									case "title_short_name": {
										return Renderer.monster.getShortName(copyTo, parts[0] === "title_short_name");
									}
									case "spell_dc": {
										if (!Parser.ABIL_ABVS.includes(parts[1])) throw new Error(`Unknown ability score "${parts[1]}"`);
										return 8 + Parser.getAbilityModNumber(Number(copyTo[parts[1]])) + Parser.crToPb(copyTo.cr);
									}
									case "to_hit": {
										if (!Parser.ABIL_ABVS.includes(parts[1])) throw new Error(`Unknown ability score "${parts[1]}"`);
										const total = Parser.crToPb(copyTo.cr) + Parser.getAbilityModNumber(Number(copyTo[parts[1]]));
										return total >= 0 ? `+${total}` : total;
									}
									case "damage_mod": {
										if (!Parser.ABIL_ABVS.includes(parts[1])) throw new Error(`Unknown ability score "${parts[1]}"`);
										const total = Parser.getAbilityModNumber(Number(copyTo[parts[1]]));
										return total === 0 ? "" : total > 0 ? ` +${total}` : ` ${total}`;
									}
									case "damage_avg": {
										const replaced = parts[1].replace(/(str|dex|con|int|wis|cha)/gi, (...m2) => Parser.getAbilityModNumber(Number(copyTo[m2[0]])));
										const clean = replaced.replace(/[^-+/*0-9.,]+/g, "");
										// eslint-disable-next-line no-eval
										return Math.floor(eval(clean));
									}
									default: return m[0];
								}
							}),
					);
				});

				Object.entries(copyMeta._mod).forEach(([prop, modInfos]) => {
					if (prop === "*") doMod(modInfos, "action", "bonus", "reaction", "trait", "legendary", "mythic", "variant", "spellcasting", "legendaryHeader");
					else if (prop === "_") doMod(modInfos);
					else doMod(modInfos, prop);
				});
			}

			// add filter tag
			copyTo._isCopy = true;

			// cleanup
			delete copyTo._copy;
		},
	},

	monster: {
		_MERGE_REQUIRES_PRESERVE: {
			legendaryGroup: true,
			environment: true,
			soundClip: true,
			altArt: true,
			variant: true,
			dragonCastingColor: true,
		},
		_mergeCache: {},
		async pMergeCopy (monList, mon, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.monster, UrlUtil.PG_BESTIARY, monList, mon, options);
		},

		async pPreloadMeta () {
			DataUtil.monster._pLoadMeta = DataUtil.monster._pLoadMeta || ((async () => {
				const legendaryGroups = await DataUtil.legendaryGroup.pLoadAll();
				DataUtil.monster.populateMetaReference({legendaryGroup: legendaryGroups});
			})());
			await DataUtil.monster._pLoadMeta;
		},

		async pLoadAll () {
			const [index] = await Promise.all([
				DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/index.json`),
				DataUtil.monster.pPreloadMeta(),
			]);

			const allData = await Promise.all(Object.entries(index).map(async ([source, file]) => {
				const data = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/${file}`);
				return data.monster.filter(it => it.source === source);
			}));
			return allData.flat();
		},

		_pLoadMeta: null,
		metaGroupMap: {},
		getMetaGroup (mon) {
			if (!mon.legendaryGroup || !mon.legendaryGroup.source || !mon.legendaryGroup.name) return null;
			return (DataUtil.monster.metaGroupMap[mon.legendaryGroup.source] || {})[mon.legendaryGroup.name];
		},
		populateMetaReference (data) {
			(data.legendaryGroup || []).forEach(it => {
				(DataUtil.monster.metaGroupMap[it.source] =
					DataUtil.monster.metaGroupMap[it.source] || {})[it.name] = it;
			});
		},

		async pPostProcess (data) {
			if (!data?.monster?.length) return;

			// Load "summoned by spell" info
			for (const mon of data.monster) {
				if (!mon.summonedBySpell) continue;
				let [name, source] = mon.summonedBySpell.split("|");
				source = source || SRC_PHB;
				const hash = UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS]({name, source});

				let spell = null;
				if (data.spell?.length) spell = data.spell.find(sp => UrlUtil.URL_TO_HASH_BUILDER[UrlUtil.PG_SPELLS](sp) === hash);
				if (!spell) spell = await Renderer.hover.pCacheAndGetHash(UrlUtil.PG_SPELLS, hash);
				if (!spell) {
					setTimeout(() => { throw new Error(`Could not load "${mon.name} (${mon.source})" "summonedBySpell" "${mon.summonedBySpell}"`); })
					continue;
				}
				mon._summonedBySpell_levelBase = spell.level;
			}
		},
	},

	monsterFluff: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (monFlfList, monFlf, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.monsterFluff, UrlUtil.PG_BESTIARY, monFlfList, monFlf, options);
		},
	},

	spell: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (spellList, spell, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.spell, UrlUtil.PG_SPELLS, spellList, spell, options);
		},

		async pLoadAll () {
			const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/spells/index.json`);
			const allData = await Promise.all(Object.entries(index).map(async ([source, file]) => {
				const data = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/spells/${file}`);
				return data.spell.filter(it => it.source === source);
			}));
			return allData.flat();
		},
	},

	spellFluff: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (spellFlfList, spellFlf, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.spellFluff, UrlUtil.PG_SPELLS, spellFlfList, spellFlf, options);
		},
	},

	item: {
		_MERGE_REQUIRES_PRESERVE: {
			lootTables: true,
			tier: true,
		},
		_mergeCache: {},
		async pMergeCopy (itemList, item, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.item, UrlUtil.PG_ITEMS, itemList, item, options);
		},

		async loadRawJSON () {
			if (DataUtil.item._loadedRawJson) return DataUtil.item._loadedRawJson;

			DataUtil.item._pLoadingRawJson = (async () => {
				const urlItems = `${Renderer.get().baseUrl}data/items.json`;
				const urlItemsBase = `${Renderer.get().baseUrl}data/items-base.json`;
				const urlVariants = `${Renderer.get().baseUrl}data/magicvariants.json`;

				const [dataItems, dataItemsBase, dataVariants] = await Promise.all([
					DataUtil.loadJSON(urlItems),
					DataUtil.loadJSON(urlItemsBase),
					DataUtil.loadJSON(urlVariants),
				]);

				DataUtil.item._loadedRawJson = {
					item: MiscUtil.copy(dataItems.item),
					itemGroup: MiscUtil.copy(dataItems.itemGroup),
					variant: MiscUtil.copy(dataVariants.variant),
					baseitem: MiscUtil.copy(dataItemsBase.baseitem),
				};
			})();
			await DataUtil.item._pLoadingRawJson;

			return DataUtil.item._loadedRawJson;
		},
	},

	itemGroup: {
		_MERGE_REQUIRES_PRESERVE: {
			lootTables: true,
			tier: true,
		},
		_mergeCache: {},
		async pMergeCopy (...args) { return DataUtil.item.pMergeCopy(...args); },
		async loadRawJSON (...args) { return DataUtil.item.loadRawJSON(...args); },
	},

	itemFluff: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (itemFlfList, itemFlf, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.itemFluff, UrlUtil.PG_ITEMS, itemFlfList, itemFlf, options);
		},

		getDataUrl () { return `${Renderer.get().baseUrl}data/fluff-items.json`; },
	},

	background: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (bgList, bg, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.background, UrlUtil.PG_BACKGROUNDS, bgList, bg, options);
		},

		getDataUrl () { return `${Renderer.get().baseUrl}data/backgrounds.json`; },
	},

	optionalfeature: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (lst, it, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.optionalfeature, UrlUtil.PG_OPT_FEATURES, lst, it, options);
		},

		getDataUrl () { return `${Renderer.get().baseUrl}data/optionalfeatures.json`; },
	},

	race: {
		_MERGE_REQUIRES_PRESERVE: {
			subraces: true,
		},
		_mergeCache: {},
		async pMergeCopy (raceList, race, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.race, UrlUtil.PG_RACES, raceList, race, options);
		},

		_loadCache: {},
		_pIsLoadings: {},
		async loadJSON ({isAddBaseRaces = false} = {}) {
			if (!DataUtil.race._pIsLoadings[isAddBaseRaces]) {
				DataUtil.race._pIsLoadings[isAddBaseRaces] = (async () => {
					const rawRaceData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/races.json`);
					const raceData = Renderer.race.mergeSubraces(rawRaceData.race, {isAddBaseRaces});
					DataUtil.race._loadCache[isAddBaseRaces] = {race: raceData};
				})();
			}
			await DataUtil.race._pIsLoadings[isAddBaseRaces];
			return DataUtil.race._loadCache[isAddBaseRaces];
		},

		async loadBrew ({isAddBaseRaces = true} = {}) {
			const brew = await BrewUtil.pAddBrewData();
			let fromBrew = MiscUtil.copy(brew.race || []);
			fromBrew = Renderer.race.mergeSubraces(fromBrew, {isAddBaseRaces});
			return {race: fromBrew};
		},
	},

	raceFluff: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (raceFlfList, raceFlf, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.raceFluff, UrlUtil.PG_RACES, raceFlfList, raceFlf, options);
		},

		getDataUrl () { return `${Renderer.get().baseUrl}data/fluff-races.json`; },
	},

	class: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (classList, cls, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.class, UrlUtil.PG_CLASSES, classList, cls, options);
		},

		_pLoadingJson: null,
		_pLoadingRawJson: null,
		_loadedJson: null,
		_loadedRawJson: null,
		async loadJSON () {
			if (DataUtil.class._loadedJson) return DataUtil.class._loadedJson;

			DataUtil.class._pLoadingJson = (async () => {
				const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/index.json`);

				const allData = (
					await Object.values(index)
						.pSerialAwaitMap(it => DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/${it}`))
				)
					.map(it => MiscUtil.copy(it));

				const allDereferencedClassData = (await Promise.all(allData.map(json => Promise.all((json.class || []).map(cls => DataUtil.class.pGetDereferencedClassData(cls)))))).flat();

				const allDereferencedSubclassData = (await Promise.all(allData.map(json => Promise.all((json.subclass || []).map(sc => DataUtil.class.pGetDereferencedSubclassData(sc)))))).flat();

				DataUtil.class._loadedJson = {class: allDereferencedClassData, subclass: allDereferencedSubclassData};
			})();
			await DataUtil.class._pLoadingJson;

			return DataUtil.class._loadedJson;
		},

		async loadRawJSON () {
			if (DataUtil.class._loadedRawJson) return DataUtil.class._loadedRawJson;

			DataUtil.class._pLoadingRawJson = (async () => {
				const index = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/index.json`);
				const allData = await Promise.all(Object.values(index).map(it => DataUtil.loadJSON(`${Renderer.get().baseUrl}data/class/${it}`)));

				DataUtil.class._loadedRawJson = {
					class: MiscUtil.copy(allData.map(it => it.class || []).flat()),
					subclass: MiscUtil.copy(allData.map(it => it.subclass || []).flat()),
					classFeature: allData.map(it => it.classFeature || []).flat(),
					subclassFeature: allData.map(it => it.subclassFeature || []).flat(),
				};
			})();
			await DataUtil.class._pLoadingRawJson;

			return DataUtil.class._loadedRawJson;
		},

		/**
		 * @param uid
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		unpackUidClassFeature (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, className, classSource, level, source, displayText] = uid.split("|").map(it => it.trim());
			classSource = classSource || (opts.isLower ? SRC_PHB.toLowerCase() : SRC_PHB);
			source = source || classSource;
			level = Number(level)
			return {
				name,
				className,
				classSource,
				level,
				source,
				displayText,
			};
		},

		isValidClassFeatureUid (uid) {
			const {name, className, level} = DataUtil.class.unpackUidClassFeature(uid);
			return !(!name || !className || isNaN(level));
		},

		packUidClassFeature (f) {
			// <name>|<className>|<classSource>|<level>|<source>
			return [
				f.name,
				f.className,
				f.classSource === SRC_PHB ? "" : f.classSource, // assume the class has PHB source
				f.level,
				f.source === f.classSource ? "" : f.source, // assume the class feature has the class source
			].join("|").replace(/\|+$/, ""); // Trim trailing pipes
		},

		/**
		 * @param uid
		 * @param [opts]
		 * @param [opts.isLower] If the returned values should be lowercase.
		 */
		unpackUidSubclassFeature (uid, opts) {
			opts = opts || {};
			if (opts.isLower) uid = uid.toLowerCase();
			let [name, className, classSource, subclassShortName, subclassSource, level, source, displayText] = uid.split("|").map(it => it.trim());
			classSource = classSource || (opts.isLower ? SRC_PHB.toLowerCase() : SRC_PHB);
			subclassSource = subclassSource || (opts.isLower ? SRC_PHB.toLowerCase() : SRC_PHB);
			source = source || subclassSource;
			level = Number(level)
			return {
				name,
				className,
				classSource,
				subclassShortName,
				subclassSource,
				level,
				source,
				displayText,
			};
		},

		isValidSubclassFeatureUid (uid) {
			const {name, className, subclassShortName, level} = DataUtil.class.unpackUidSubclassFeature(uid);
			return !(!name || !className || !subclassShortName || isNaN(level));
		},

		packUidSubclassFeature (f) {
			// <name>|<className>|<classSource>|<subclassShortName>|<subclassSource>|<level>|<source>
			return [
				f.name,
				f.className,
				f.classSource === SRC_PHB ? "" : f.classSource, // assume the class has the PHB source
				f.subclassShortName,
				f.subclassSource === SRC_PHB ? "" : f.subclassSource, // assume the subclass has the PHB source
				f.level,
				f.source === f.subclassSource ? "" : f.source, // assume the feature has the same source as the subclass
			].join("|").replace(/\|+$/, ""); // Trim trailing pipes
		},

		_mutEntryNestLevel (feature) {
			const depth = (feature.header == null ? 1 : feature.header) - 1;
			for (let i = 0; i < depth; ++i) {
				const nxt = MiscUtil.copy(feature);
				feature.entries = [nxt];
				delete feature.name;
				delete feature.page;
				delete feature.source;
			}
		},

		async pGetDereferencedClassData (cls) {
			// Gracefully handle legacy class data
			if (cls.classFeatures && cls.classFeatures.every(it => typeof it !== "string" && !it.classFeature)) return cls;

			cls = MiscUtil.copy(cls);

			const byLevel = {}; // Build a map of `level: [classFeature]`
			for (const classFeatureRef of (cls.classFeatures || [])) {
				const uid = classFeatureRef.classFeature ? classFeatureRef.classFeature : classFeatureRef;
				const {name, className, classSource, level, source} = DataUtil.class.unpackUidClassFeature(uid);
				if (!name || !className || !level || isNaN(level)) continue; // skip over broken links

				if (source === SRC_5ETOOLS_TMP) continue; // Skip over temp/nonexistent links

				const hash = UrlUtil.URL_TO_HASH_BUILDER["classFeature"]({name, className, classSource, level, source});

				// Skip blacklisted
				if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(hash, "classFeature", source, {isNoCount: true})) continue;

				const classFeature = await Renderer.hover.pCacheAndGet("classFeature", source, hash, {isCopy: true});
				// skip over missing links
				if (!classFeature) {
					JqueryUtil.doToast({type: "danger", content: `Failed to find <code>classFeature</code> <code>${uid}</code>`});
					continue;
				}

				if (classFeatureRef.gainSubclassFeature) classFeature.gainSubclassFeature = true;

				if (cls.otherSources && cls.source === classFeature.source) classFeature.otherSources = MiscUtil.copy(cls.otherSources);

				DataUtil.class._mutEntryNestLevel(classFeature);

				const key = `${classFeature.level || 1}`;
				(byLevel[key] = byLevel[key] || []).push(classFeature);
			}

			const outClassFeatures = [];
			const maxLevel = Math.max(...Object.keys(byLevel).map(it => Number(it)));
			for (let i = 1; i <= maxLevel; ++i) {
				outClassFeatures[i - 1] = byLevel[i] || [];
			}
			cls.classFeatures = outClassFeatures;

			return cls;
		},

		async pGetDereferencedSubclassData (sc) {
			// Gracefully handle legacy class data
			if (sc.subclassFeatures && sc.subclassFeatures.every(it => typeof it !== "string" && !it.subclassFeature)) return sc;

			sc = MiscUtil.copy(sc);

			const byLevel = {}; // Build a map of `level: [subclassFeature]`

			for (const subclassFeatureRef of (sc.subclassFeatures || [])) {
				const uid = subclassFeatureRef.subclassFeature ? subclassFeatureRef.subclassFeature : subclassFeatureRef;
				const {name, className, classSource, subclassShortName, subclassSource, level, source} = DataUtil.class.unpackUidSubclassFeature(uid);
				if (!name || !className || !subclassShortName || !level || isNaN(level)) continue; // skip over broken links
				const hash = UrlUtil.URL_TO_HASH_BUILDER["subclassFeature"]({name, className, classSource, subclassShortName, subclassSource, level, source});

				// Skip blacklisted
				if (ExcludeUtil.isInitialised && ExcludeUtil.isExcluded(hash, "subclassFeature", source, {isNoCount: true})) continue;

				const subclassFeature = await Renderer.hover.pCacheAndGet("subclassFeature", source, hash, {isCopy: true});
				// skip over missing links
				if (!subclassFeature) {
					JqueryUtil.doToast({type: "danger", content: `Failed to find <code>subclassFeature</code> <code>${uid}</code>`});
					continue;
				}

				if (sc.otherSources && sc.source === subclassFeature.source) subclassFeature.otherSources = MiscUtil.copy(sc.otherSources);

				DataUtil.class._mutEntryNestLevel(subclassFeature);

				const key = `${subclassFeature.level || 1}`;
				(byLevel[key] = byLevel[key] || []).push(subclassFeature);
			}

			sc.subclassFeatures = Object.keys(byLevel)
				.map(it => Number(it))
				.sort(SortUtil.ascSort)
				.map(k => byLevel[k]);

			return sc;
		},

		// region Subclass lookup
		_CACHE_SUBCLASS_LOOKUP_PROMISE: null,
		_CACHE_SUBCLASS_LOOKUP: null,
		async pGetSubclassLookup () {
			DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE = DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE || (async () => {
				const subclassLookup = {};
				Object.assign(subclassLookup, await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-subclass-lookup.json`));
				const homebrew = await BrewUtil.pAddBrewData();
				DataUtil.class.mergeHomebrewSubclassLookup(subclassLookup, homebrew);
				DataUtil.class._CACHE_SUBCLASS_LOOKUP = subclassLookup;
			})();
			await DataUtil.class._CACHE_SUBCLASS_LOOKUP_PROMISE;
			return DataUtil.class._CACHE_SUBCLASS_LOOKUP;
		},

		mergeHomebrewSubclassLookup (subclassLookup, homebrew) {
			(homebrew.subclass || [])
				.forEach(sc => {
					const clSrc = sc.classSource || SRC_PHB;
					sc.shortName = sc.shortName || sc.name;
					const target = MiscUtil.getOrSet(subclassLookup, clSrc, sc.className, {});
					MiscUtil.set(target, sc.source, sc.shortName, {name: sc.name});
				});
		},
		// endregion
	},

	subclass: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (subclassList, subclass, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.subclass, "subclass", subclassList, subclass, options);
		},
	},

	deity: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (deityList, deity, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.deity, UrlUtil.PG_DEITIES, deityList, deity, options);
		},

		doPostLoad: function (data) {
			const PRINT_ORDER = [
				SRC_PHB,
				SRC_DMG,
				SRC_SCAG,
				SRC_VGM,
				SRC_MTF,
				SRC_ERLW,
			];

			const inSource = {};
			PRINT_ORDER.forEach(src => {
				inSource[src] = {};
				data.deity.filter(it => it.source === src).forEach(it => inSource[src][it.reprintAlias || it.name] = it); // TODO need to handle similar names
			});

			const laterPrinting = [PRINT_ORDER.last()];
			[...PRINT_ORDER].reverse().slice(1).forEach(src => {
				laterPrinting.forEach(laterSrc => {
					Object.keys(inSource[src]).forEach(name => {
						const newer = inSource[laterSrc][name];
						if (newer) {
							const old = inSource[src][name];
							old.reprinted = true;
							if (!newer._isEnhanced) {
								newer.previousVersions = newer.previousVersions || [];
								newer.previousVersions.push(old);
							}
						}
					});
				});

				laterPrinting.push(src);
			});
			data.deity.forEach(g => g._isEnhanced = true);
		},

		loadJSON: async function () {
			const data = await DataUtil.loadJSON(DataUtil.deity.getDataUrl());
			DataUtil.deity.doPostLoad(data);
			return data;
		},

		getDataUrl () { return `${Renderer.get().baseUrl}data/deities.json`; },
	},

	table: {
		async loadJSON () {
			const [dataEncounters, dataNames, ...datas] = await Promise.all([
				`${Renderer.get().baseUrl}data/encounters.json`,
				`${Renderer.get().baseUrl}data/names.json`,
				`${Renderer.get().baseUrl}data/generated/gendata-tables.json`,
				`${Renderer.get().baseUrl}data/tables.json`,
			].map(url => DataUtil.loadJSON(url)));
			const combined = {};
			datas.forEach(data => {
				Object.entries(data).forEach(([k, v]) => {
					if (combined[k] && combined[k] instanceof Array && v instanceof Array) combined[k] = combined[k].concat(v);
					else if (combined[k] == null) combined[k] = v;
					else throw new Error(`Could not merge keys for key "${k}"`);
				});
			});

			dataEncounters.encounter.forEach(group => {
				group.tables.forEach(tableRaw => {
					combined.table.push(DataUtil.table._getConvertedEncounterOrNamesTable({
						group,
						tableRaw,
						fnGetNameCaption: DataUtil.table._getConvertedEncounterTableName,
						colLabel1: "Encounter",
					}));
				});
			});

			dataNames.name.forEach(group => {
				group.tables.forEach(tableRaw => {
					combined.table.push(DataUtil.table._getConvertedEncounterOrNamesTable({
						group,
						tableRaw,
						fnGetNameCaption: DataUtil.table._getConvertedNameTableName,
						colLabel1: "Name",
					}));
				});
			});

			return combined;
		},

		_getConvertedEncounterTableName (group, tableRaw) { return `${group.name} Encounters (Levels ${tableRaw.minlvl}\u2014${tableRaw.maxlvl})`; },
		_getConvertedNameTableName (group, tableRaw) { return `${group.name} Names - ${tableRaw.option}`; },

		_getConvertedEncounterOrNamesTable ({group, tableRaw, fnGetNameCaption, colLabel1}) {
			const nameCaption = fnGetNameCaption(group, tableRaw);
			return {
				name: nameCaption,
				source: group.source,
				page: group.page,
				caption: nameCaption,
				colLabels: [
					`d${tableRaw.diceType}`,
					colLabel1,
				],
				colStyles: [
					"col-2 text-center",
					"col-10",
				],
				rows: tableRaw.table.map(it => [
					`${it.min}${it.max && it.max !== it.min ? `-${it.max}` : ""}`,
					it.result.replace(RollerUtil.DICE_REGEX, (...m) => `{@dice ${m[0]}}`),
				]),
			};
		},
	},

	legendaryGroup: {
		_MERGE_REQUIRES_PRESERVE: {},
		_mergeCache: {},
		async pMergeCopy (lgList, lg, options) {
			return DataUtil.generic._pMergeCopy(DataUtil.legendaryGroup, UrlUtil.PG_BESTIARY, lgList, lg, options);
		},

		async pLoadAll () {
			return (await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/bestiary/legendarygroups.json`)).legendaryGroup;
		},
	},

	language: {
		async loadJSON () {
			const rawData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/languages.json`);

			// region Populate fonts, based on script
			const scriptLookup = {};
			(rawData.languageScript || []).forEach(script => scriptLookup[script.name] = script);

			const out = {language: MiscUtil.copy(rawData.language)};
			out.language.forEach(lang => {
				if (!lang.script || lang.fonts === false) return;

				const script = scriptLookup[lang.script];
				if (!script) return;

				lang._fonts = [...script.fonts];
			});
			// endregion

			return out;
		},
	},

	recipe: {
		async loadJSON () {
			const out = [];

			const rawData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/recipes.json`);

			DataUtil.recipe.postProcessData(rawData);

			// region Merge together main data and fluff, as we render the fluff in the main tab
			for (const r of rawData.recipe) {
				const fluff = await Renderer.utils.pGetFluff({
					entity: r,
					fluffUrl: `data/fluff-recipes.json`,
					fluffProp: "recipeFluff",
				});

				if (!fluff) {
					out.push(r);
					continue;
				}

				const cpyR = MiscUtil.copy(r);
				cpyR.fluff = MiscUtil.copy(fluff);
				delete cpyR.fluff.name;
				delete cpyR.fluff.source;
				out.push(cpyR);
			}
			// endregion

			return {recipe: out};
		},

		postProcessData (data) {
			if (!data.recipe || !data.recipe.length) return;

			// Apply ingredient properties
			data.recipe.forEach(r => Renderer.recipe.populateFullIngredients(r));
		},

		async loadBrew () {
			const brew = await BrewUtil.pAddBrewData();
			DataUtil.recipe.postProcessData(brew);
			return brew;
		},
	},

	variantrule: {
		async loadJSON () {
			const rawData = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/variantrules.json`);
			const rawDataGenerated = await DataUtil.loadJSON(`${Renderer.get().baseUrl}data/generated/gendata-variantrules.json`);

			return {variantrule: [...rawData.variantrule, ...rawDataGenerated.variantrule]};
		},
	},

	brew: {
		_getCleanUrlRoot (urlRoot) {
			if (urlRoot && urlRoot.trim()) {
				urlRoot = urlRoot.trim();
				if (!urlRoot.endsWith("/")) urlRoot = `${urlRoot}/`;
			} else urlRoot = `https://raw.githubusercontent.com/TheGiddyLimit/homebrew/master/`;
			return urlRoot;
		},

		async pLoadTimestamps (urlRoot) {
			urlRoot = DataUtil.brew._getCleanUrlRoot(urlRoot);
			return DataUtil.loadJSON(`${urlRoot}_generated/index-timestamps.json`);
		},

		async pLoadPropIndex (urlRoot) {
			urlRoot = DataUtil.brew._getCleanUrlRoot(urlRoot);
			return DataUtil.loadJSON(`${urlRoot}_generated/index-props.json`);
		},

		async pLoadNameIndex (urlRoot) {
			urlRoot = DataUtil.brew._getCleanUrlRoot(urlRoot);
			return DataUtil.loadJSON(`${urlRoot}_generated/index-names.json`);
		},

		async pLoadAbbreviationIndex (urlRoot) {
			urlRoot = DataUtil.brew._getCleanUrlRoot(urlRoot);
			return DataUtil.loadJSON(`${urlRoot}_generated/index-abbreviations.json`);
		},

		async pLoadSourceIndex (urlRoot) {
			urlRoot = DataUtil.brew._getCleanUrlRoot(urlRoot);
			return DataUtil.loadJSON(`${urlRoot}_generated/index-sources.json`);
		},

		getFileUrl (path, urlRoot) {
			urlRoot = DataUtil.brew._getCleanUrlRoot(urlRoot);
			return `${urlRoot}${path}`;
		},
	},
};

// ROLLING =============================================================================================================
RollerUtil = {
	isCrypto () {
		return typeof window !== "undefined" && typeof window.crypto !== "undefined";
	},

	randomise (max, min = 1) {
		if (min > max) return 0;
		if (max === min) return max;
		if (RollerUtil.isCrypto()) {
			return RollerUtil._randomise(min, max + 1);
		} else {
			return RollerUtil.roll(max) + min;
		}
	},

	rollOnArray (array) {
		return array[RollerUtil.randomise(array.length) - 1]
	},

	/**
	 * Cryptographically secure RNG
	 */
	_randomise: (min, max) => {
		const range = max - min;
		const bytesNeeded = Math.ceil(Math.log2(range) / 8);
		const randomBytes = new Uint8Array(bytesNeeded);
		const maximumRange = (2 ** 8) ** bytesNeeded;
		const extendedRange = Math.floor(maximumRange / range) * range;
		let i;
		let randomInteger;
		while (true) {
			window.crypto.getRandomValues(randomBytes);
			randomInteger = 0;
			for (i = 0; i < bytesNeeded; i++) {
				randomInteger <<= 8;
				randomInteger += randomBytes[i];
			}
			if (randomInteger < extendedRange) {
				randomInteger %= range;
				return min + randomInteger;
			}
		}
	},

	/**
	 * Result in range: 0 to (max-1); inclusive
	 * e.g. roll(20) gives results ranging from 0 to 19
	 * @param max range max (exclusive)
	 * @param fn funciton to call to generate random numbers
	 * @returns {number} rolled
	 */
	roll (max, fn = Math.random) {
		return Math.floor(fn() * max);
	},

	addListRollButton (isCompact) {
		const $btnRoll = $(`<button class="btn btn-default ${isCompact ? "px-2" : ""}" id="feelinglucky" title="Feeling Lucky?"><span class="glyphicon glyphicon-random"></span></button>`);
		$btnRoll.on("click", () => {
			const primaryLists = ListUtil.getPrimaryLists();
			if (primaryLists && primaryLists.length) {
				const allLists = primaryLists.filter(l => l.visibleItems.length);
				if (allLists.length) {
					const rollX = RollerUtil.roll(allLists.length);
					const list = allLists[rollX];
					const rollY = RollerUtil.roll(list.visibleItems.length);
					window.location.hash = $(list.visibleItems[rollY].ele).find(`a`).prop("hash");
				}
			}
		});

		$(`#filter-search-group`).find(`#reset`).before($btnRoll);
	},

	getColRollType (colLabel) {
		if (typeof colLabel !== "string") return false;
		if (/^{@dice [^}]+}$/.test(colLabel.trim())) return true;
		colLabel = Renderer.stripTags(colLabel);

		if (Renderer.dice.lang.getTree3(colLabel)) return RollerUtil.ROLL_COL_STANDARD;

		// Remove trailing variables, if they exist
		colLabel = colLabel.replace(RollerUtil._REGEX_ROLLABLE_COL_LABEL, "$1");
		if (Renderer.dice.lang.getTree3(colLabel)) return RollerUtil.ROLL_COL_VARIABLE;

		return 0;
	},

	getFullRollCol (lbl) {
		if (lbl.includes("@dice")) return lbl;

		if (Renderer.dice.lang.getTree3(lbl)) return `{@dice ${lbl}}`;

		// Try to split off any trailing variables, e.g. `d100 + Level` -> `d100`, `Level`
		const m = RollerUtil._REGEX_ROLLABLE_COL_LABEL.exec(lbl);
		if (!m) return lbl;

		return `{@dice ${m[1]}${m[2]}#$prompt_number:title=Enter a ${m[3].trim()}$#|${lbl}}`;
	},

	_DICE_REGEX_STR: "((([1-9]\\d*)?d([1-9]\\d*)(\\s*?[-+×x*÷/]\\s*?(\\d,\\d|\\d)+(\\.\\d+)?)?))+?",
};
RollerUtil.DICE_REGEX = new RegExp(RollerUtil._DICE_REGEX_STR, "g");
RollerUtil.REGEX_DAMAGE_DICE = /(\d+)( \((?:{@dice |{@damage ))([-+0-9d ]*)(}\)(?:\s*\+\s*the spell's level)? [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil.REGEX_DAMAGE_FLAT = /(Hit: |{@h})([0-9]+)( [a-z]+( \([-a-zA-Z0-9 ]+\))?( or [a-z]+( \([-a-zA-Z0-9 ]+\))?)? damage)/gi;
RollerUtil._REGEX_ROLLABLE_COL_LABEL = /^(.*?\d)(\s*[-+/*^×÷]\s*)([a-zA-Z0-9 ]+)$/;
RollerUtil.ROLL_COL_NONE = 0;
RollerUtil.ROLL_COL_STANDARD = 1;
RollerUtil.ROLL_COL_VARIABLE = 2;

// STORAGE =============================================================================================================
// Dependency: localforage
StorageUtil = {
	_init: false,
	_initAsync: false,
	_fakeStorage: {},
	_fakeStorageAsync: {},

	_getSyncStorage () {
		if (StorageUtil._init) {
			if (StorageUtil.__fakeStorage) return StorageUtil._fakeStorage;
			else return window.localStorage;
		}

		StorageUtil._init = true;
		try {
			window.localStorage.setItem("_test_storage", true);
			return window.localStorage;
		} catch (e) {
			// if the user has disabled cookies, build a fake version
			StorageUtil.__fakeStorage = true;
			StorageUtil._fakeStorage = {
				isSyncFake: true,
				getItem: k => StorageUtil.__fakeStorage[k],
				removeItem: k => delete StorageUtil.__fakeStorage[k],
				setItem: (k, v) => StorageUtil.__fakeStorage[k] = v,
			};
			return StorageUtil._fakeStorage;
		}
	},

	async _getAsyncStorage () {
		if (StorageUtil._initAsync) {
			if (StorageUtil.__fakeStorageAsync) return StorageUtil._fakeStorageAsync;
			else return localforage;
		}

		const getInitFakeStorage = () => {
			StorageUtil.__fakeStorageAsync = {};
			StorageUtil._fakeStorageAsync = {
				pIsAsyncFake: true,
				async setItem (k, v) { StorageUtil.__fakeStorageAsync[k] = v; },
				async getItem (k) { return StorageUtil.__fakeStorageAsync[k]; },
				async removeItem (k) { delete StorageUtil.__fakeStorageAsync[k]; },
			};
			return StorageUtil._fakeStorageAsync;
		};

		if (typeof window !== "undefined") {
			try {
				// check if IndexedDB is available (i.e. not in Firefox private browsing)
				await new Promise((resolve, reject) => {
					const request = window.indexedDB.open("_test_db", 1);
					request.onerror = reject;
					request.onsuccess = resolve;
				});
				await localforage.setItem("_storage_check", true);
				return localforage;
			} catch (e) {
				return getInitFakeStorage();
			} finally {
				StorageUtil._initAsync = true;
			}
		} else return getInitFakeStorage();
	},

	// region Synchronous
	syncGet (key) {
		const rawOut = StorageUtil._getSyncStorage().getItem(key);
		if (rawOut && rawOut !== "undefined" && rawOut !== "null") return JSON.parse(rawOut);
		return null;
	},

	syncSet (key, value) {
		StorageUtil._getSyncStorage().setItem(key, JSON.stringify(value));
		StorageUtil._syncTrackKey(key)
	},

	syncRemove (key) {
		StorageUtil._getSyncStorage().removeItem(key);
		StorageUtil._syncTrackKey(key, true);
	},

	syncGetForPage (key) { return StorageUtil.syncGet(`${key}_${UrlUtil.getCurrentPage()}`); },
	syncSetForPage (key, value) { StorageUtil.syncSet(`${key}_${UrlUtil.getCurrentPage()}`, value); },

	isSyncFake () {
		return !!StorageUtil._getSyncStorage().isSyncFake
	},

	_syncTrackKey (key, isRemove) {
		const meta = StorageUtil.syncGet(StorageUtil._META_KEY) || {};
		if (isRemove) delete meta[key];
		else meta[key] = 1;
		StorageUtil._getSyncStorage().setItem(StorageUtil._META_KEY, JSON.stringify(meta));
	},

	syncGetDump () {
		const out = {};
		const meta = StorageUtil.syncGet(StorageUtil._META_KEY) || {};
		Object.entries(meta).filter(([key, isPresent]) => isPresent).forEach(([key]) => out[key] = StorageUtil.syncGet(key));
		return out;
	},

	syncSetFromDump (dump) {
		Object.entries(dump).forEach(([k, v]) => StorageUtil.syncSet(k, v));
	},
	// endregion

	// region Asynchronous
	async pIsAsyncFake () {
		const storage = await StorageUtil._getAsyncStorage();
		return !!storage.pIsAsyncFake;
	},

	async pSet (key, value) {
		StorageUtil._pTrackKey(key);
		const storage = await StorageUtil._getAsyncStorage();
		return storage.setItem(key, value);
	},

	async pGet (key) {
		const storage = await StorageUtil._getAsyncStorage();
		return storage.getItem(key);
	},

	async pRemove (key) {
		StorageUtil._pTrackKey(key, true);
		const storage = await StorageUtil._getAsyncStorage();
		return storage.removeItem(key);
	},

	getPageKey (key, page) { return `${key}_${page || UrlUtil.getCurrentPage()}`; },
	async pGetForPage (key) { return StorageUtil.pGet(StorageUtil.getPageKey(key)); },
	async pSetForPage (key, value) { return StorageUtil.pSet(StorageUtil.getPageKey(key), value); },
	async pRemoveForPage (key) { return StorageUtil.pRemove(StorageUtil.getPageKey(key)); },

	async _pTrackKey (key, isRemove) {
		const storage = await StorageUtil._getAsyncStorage();
		const meta = (await StorageUtil.pGet(StorageUtil._META_KEY)) || {};
		if (isRemove) delete meta[key];
		else meta[key] = 1;
		return storage.setItem(StorageUtil._META_KEY, meta);
	},

	async pGetDump () {
		const out = {};
		const meta = (await StorageUtil.pGet(StorageUtil._META_KEY)) || {};
		await Promise.all(Object.entries(meta).filter(([key, isPresent]) => isPresent).map(async ([key]) => out[key] = await StorageUtil.pGet(key)));
		return out;
	},

	async pSetFromDump (dump) {
		return Promise.all(Object.entries(dump).map(([k, v]) => StorageUtil.pSet(k, v)));
	},
	// endregion
};
StorageUtil._META_KEY = "_STORAGE_META_STORAGE";

// TODO transition cookie-like storage items over to this
SessionStorageUtil = {
	_fakeStorage: {},
	__storage: null,
	getStorage: () => {
		try {
			return window.sessionStorage;
		} catch (e) {
			// if the user has disabled cookies, build a fake version
			if (SessionStorageUtil.__storage) return SessionStorageUtil.__storage;
			else {
				return SessionStorageUtil.__storage = {
					isFake: true,
					getItem: (k) => {
						return SessionStorageUtil._fakeStorage[k];
					},
					removeItem: (k) => {
						delete SessionStorageUtil._fakeStorage[k];
					},
					setItem: (k, v) => {
						SessionStorageUtil._fakeStorage[k] = v;
					},
				};
			}
		}
	},

	isFake () {
		return SessionStorageUtil.getStorage().isSyncFake
	},

	setForPage: (key, value) => {
		SessionStorageUtil.set(`${key}_${UrlUtil.getCurrentPage()}`, value);
	},

	set (key, value) {
		SessionStorageUtil.getStorage().setItem(key, JSON.stringify(value));
	},

	getForPage: (key) => {
		return SessionStorageUtil.get(`${key}_${UrlUtil.getCurrentPage()}`);
	},

	get (key) {
		const rawOut = SessionStorageUtil.getStorage().getItem(key);
		if (rawOut && rawOut !== "undefined" && rawOut !== "null") return JSON.parse(rawOut);
		return null;
	},

	removeForPage: (key) => {
		SessionStorageUtil.remove(`${key}_${UrlUtil.getCurrentPage()}`)
	},

	remove (key) {
		SessionStorageUtil.getStorage().removeItem(key);
	},
};

// HOMEBREW ============================================================================================================
BrewUtil = {
	_PAGE: null, // Allow the current page to be forcibly specified externally

	homebrew: null,
	homebrewMeta: null,
	_lists: null,
	_sourceCache: null,
	_filterBox: null,
	_sourceFilter: null,
	_pHandleBrew: null,
	_lockHandleBrewJson: null,

	/**
	 * @param options Options object.
	 * @param [options.list] List.
	 * @param [options.lists] Lists.
	 * @param [options.filterBox] Filter box.
	 * @param [options.sourceFilter] Source filter.
	 * @param [options.pHandleBrew] Brew handling function.
	 */
	bind (options) {
		// provide ref to List.js instance
		if (options.list) BrewUtil._lists = [options.list];
		else if (options.lists) BrewUtil._lists = options.lists;
		// provide ref to FilterBox and Filter instance
		if (options.filterBox) BrewUtil._filterBox = options.filterBox;
		if (options.sourceFilter) BrewUtil._sourceFilter = options.sourceFilter;
		// allow external source for handleBrew
		if (options.pHandleBrew !== undefined) this._pHandleBrew = options.pHandleBrew;
	},

	async pAddBrewData () {
		if (BrewUtil.homebrew) {
			return BrewUtil.homebrew;
		} else {
			try {
				const homebrew = await StorageUtil.pGet(VeCt.STORAGE_HOMEBREW) || {};
				BrewUtil.homebrewMeta = StorageUtil.syncGet(VeCt.STORAGE_HOMEBREW_META) || {sources: []};
				BrewUtil.homebrewMeta.sources = BrewUtil.homebrewMeta.sources || [];

				await this._pAddLocalBrewData(homebrew);

				BrewUtil._mutMakeBrewCompatible(homebrew);

				BrewUtil.homebrew = homebrew;

				BrewUtil._resetSourceCache();

				return BrewUtil.homebrew;
			} catch (e) {
				BrewUtil.pPurgeBrew(e);
			}
		}
	},

	_mutMakeBrewCompatible (homebrew) {
		let hasOldSubclasses = false;

		if (homebrew.class) {
			homebrew.class.forEach(cls => {
				if (cls.subclasses) {
					hasOldSubclasses = true;
					cls.subclasses.forEach(sc => {
						sc.className = sc.className || cls.name;
						sc.classSource = sc.classSource || cls.source;
						(homebrew.subclass = homebrew.subclass || []).push(sc);
					});
					delete cls.subclasses;
				}
			})
		}

		if (hasOldSubclasses) {
			JqueryUtil.doToast({type: "warning", content: `Converted legacy homebrew subclasses\u2014you should re-load your class homebrews, as this backwards compatibility will be removed in future!`});
		}
	},

	async pPurgeBrew (error) {
		JqueryUtil.doToast({
			content: "Error when loading homebrew! Purged homebrew data. (See the log for more information.)",
			type: "danger",
		});
		await StorageUtil.pRemove(VeCt.STORAGE_HOMEBREW);
		StorageUtil.syncRemove(VeCt.STORAGE_HOMEBREW_META);
		BrewUtil.homebrew = null;
		window.location.hash = "";
		BrewUtil.homebrew = {};
		BrewUtil.homebrewMeta = {sources: []};
		if (error) setTimeout(() => { throw error; });
	},

	async _pAddLocalBrewData (homebrew) {
		if (IS_VTT || IS_DEPLOYED || typeof window === "undefined") return;

		// auto-load from `homebrew/`, for custom versions of the site
		const indexLocal = await DataUtil.loadJSON(`${Renderer.get().baseUrl}${VeCt.JSON_HOMEBREW_INDEX}`);
		if (!indexLocal?.toImport?.length) return;

		const page = BrewUtil._PAGE || UrlUtil.getCurrentPage();
		const allData = await Promise.all(indexLocal.toImport.map(it => DataUtil.loadJSON(`homebrew/${it}`)));
		for (const d of allData) await BrewUtil._pDoHandleBrewJson(d, page, {isLocalPreload: true, homebrew});
	},

	/**
	 * @param $appendTo Parent element
	 * @param [opts] Options object
	 * @param [opts.isModal]
	 * @param [opts.isShowAll]
	 */
	async _pRenderBrewScreen ($appendTo, opts) {
		opts = opts || {};

		const page = BrewUtil._PAGE || UrlUtil.getCurrentPage();

		const $brewList = $(`<div class="manbrew__current_brew flex-col h-100 mt-1"></div>`);

		await BrewUtil._pRenderBrewScreen_pRefreshBrewList($brewList);

		const $btnLoadFromFile = $(`<button class="btn btn-default btn-sm mr-2">Upload File</button>`)
			.click(async () => {
				const {jsons, errors} = await DataUtil.pUserUpload({isMultiple: true});

				DataUtil.doHandleFileLoadErrorsGeneric(errors);

				for (const json of jsons) {
					await DataUtil.pDoMetaMerge(CryptUtil.uid(), json);

					await BrewUtil.pDoHandleBrewJson(json, page, BrewUtil._pRenderBrewScreen_pRefreshBrewList.bind(this, $brewList));
				}
			});

		const $btnLoadFromUrl = $(`<button class="btn btn-default btn-sm mr-2">Load from URL</button>`)
			.click(async () => {
				const enteredUrl = await InputUiUtil.pGetUserString({title: "Homebrew URL"});
				if (!enteredUrl || !enteredUrl.trim()) return;

				let parsedUrl;
				try {
					parsedUrl = new URL(enteredUrl);
				} catch (e) {
					JqueryUtil.doToast({
						content: `The provided URL does not appear to be valid.`,
						type: "danger",
					});
					return;
				}
				BrewUtil.addBrewRemote(null, parsedUrl.href).catch(err => {
					JqueryUtil.doToast({
						content: "Could not load homebrew from the provided URL.",
						type: "danger",
					});
					setTimeout(() => { throw err; });
				});
			});

		const $btnGet = $(`<button class="btn btn-info btn-sm">Get Homebrew</button>`)
			.click(() => BrewUtil._pHandleClickBtnGet(opts));

		const $btnCustomUrl = $(`<button class="btn btn-info btn-sm px-2" title="Set Custom Repository URL"><span class="glyphicon glyphicon-cog"></span></button>`)
			.click(async () => {
				const customBrewUtl = await StorageUtil.pGet(`HOMEBREW_CUSTOM_REPO_URL`);

				const nxtUrl = await InputUiUtil.pGetUserString({
					title: "Homebrew Repository URL (Blank for Default)",
					default: customBrewUtl,
				});

				if (nxtUrl == null) await StorageUtil.pRemove(`HOMEBREW_CUSTOM_REPO_URL`);
				else await StorageUtil.pSet(`HOMEBREW_CUSTOM_REPO_URL`, nxtUrl);
			});

		const $btnDelAll = opts.isModal ? null : BrewUtil._$getBtnDeleteAll();

		const $wrpBtns = $$`<div class="flex-vh-center no-shrink mobile__flex-col">
			<div class="flex-v-center mobile__mb-2">
				<div class="flex-v-center btn-group mr-2">
					${$btnGet}
					${$btnCustomUrl}
				</div>
				${$btnLoadFromFile}
				${$btnLoadFromUrl}
			</div>
			<div class="flex-v-center">
				<a href="https://github.com/TheGiddyLimit/homebrew" class="flex-v-center" target="_blank" rel="noopener noreferrer"><button class="btn btn-default btn-sm">Browse Source Repository</button></a>
				${$btnDelAll}
			</div>
		</div>`;

		if (opts.isModal) {
			$$($appendTo)`
			${$brewList}
			${$wrpBtns.addClass("mb-2")}`
		} else {
			$$($appendTo)`
			${$wrpBtns.addClass("mb-3")}
			${$brewList}`
		}

		BrewUtil.addBrewRemote = async ($ele, jsonUrl, doUnescape) => {
			let cached;
			if ($ele) {
				cached = $ele.html();
				$ele.text("Loading...");
			}
			if (doUnescape) jsonUrl = jsonUrl.unescapeQuotes();
			const data = await DataUtil.loadJSON(`${jsonUrl}?${(new Date()).getTime()}`);
			await BrewUtil.pDoHandleBrewJson(data, page, BrewUtil._pRenderBrewScreen_pRefreshBrewList.bind(this, $brewList));
			if ($ele) {
				$ele.text("Done!");
				setTimeout(() => $ele.html(cached), VeCt.DUR_INLINE_NOTIFY);
			}
		};
	},

	async _pHandleClickBtnGet (opts) {
		const $btnToggleDisplayNonPageBrews = opts.isModal ? $(`<button class="btn btn-default btn-xs mr-2 ${opts.isShowAll ? "" : "active"}" disabled title="Hides homebrews which do not contain content relevant to this page.">Hide Unrelated</button>`) : null;

		const $btnAll = $(`<button class="btn btn-default btn-xs" disabled title="(Excluding samples)">Add All</button>`);

		const $wrpRows = $$`<div class="list"><div class="lst__row flex-col"><div class="lst__wrp-cells lst--border lst__row-inner flex w-100"><span style="font-style: italic;">Loading...</span></div></div></div>`;

		const $iptSearch = $(`<input type="search" class="search manbrew__search form-control w-100" placeholder="Find homebrew...">`)
			.keydown(evt => {
				switch (evt.which) {
					case 13: { // enter
						return $wrpRows.find(`.lst__row`).first().find(`.manbrew__load_from_url`).click()
					}
					case 40: { // down
						const firstItem = list.visibleItems[0];
						if (firstItem) firstItem.ele.focus();
					}
				}
			});

		const {$modalInner, doClose} = UiUtil.getShowModal({
			isHeight100: true,
			title: `Get Homebrew`,
			isUncappedHeight: true,
			isWidth100: true,
			overlayColor: "transparent",
			isHeaderBorder: true,
		});

		$$($modalInner)`
		<div class="mt-1"><i>A list of homebrew available in the public repository. Click a name to load the homebrew, or view the source directly.<br>
		Contributions are welcome; see the <a href="https://github.com/TheGiddyLimit/homebrew/blob/master/README.md" target="_blank" rel="noopener noreferrer">README</a>, or stop by our <a href="https://discord.gg/5etools" target="_blank" rel="noopener noreferrer">Discord</a>.</i></div>
		<hr class="hr-1">
		<div class="flex-h-right mb-1">${$btnToggleDisplayNonPageBrews}${$btnAll}</div>
		${$iptSearch}
		<div class="filtertools manbrew__filtertools btn-group input-group input-group--bottom flex no-shrink">
			<button class="col-4 sort btn btn-default btn-xs" data-sort="name">Name</button>
			<button class="col-3 sort btn btn-default btn-xs" data-sort="author">Author</button>
			<button class="col-1-2 sort btn btn-default btn-xs" data-sort="category">Category</button>
			<button class="col-1-4 sort btn btn-default btn-xs" data-sort="modified">Modified</button>
			<button class="col-1-4 sort btn btn-default btn-xs" data-sort="added">Added</button>
			<button class="sort btn btn-default btn-xs ve-grow" disabled>Source</button>
		</div>
		${$wrpRows}`;

		// populate list
		let dataList;
		function fnSort (a, b, o) {
			a = dataList[a.ix];
			b = dataList[b.ix];

			if (o.sortBy === "name") return byName();
			if (o.sortBy === "author") return orFallback(SortUtil.ascSortLower, "_brewAuthor");
			if (o.sortBy === "category") return orFallback(SortUtil.ascSortLower, "_brewCat");
			if (o.sortBy === "added") return orFallback(SortUtil.ascSort, "_brewAdded");
			if (o.sortBy === "modified") return orFallback(SortUtil.ascSort, "_brewModified");

			function byName () { return SortUtil.ascSortLower(a._brewName, b._brewName); }
			function orFallback (func, prop) { return func(a[prop], b[prop]) || byName(); }
		}

		const urlRoot = await StorageUtil.pGet(`HOMEBREW_CUSTOM_REPO_URL`);
		const [timestamps, propIndex, nameIndex] = await Promise.all([
			DataUtil.brew.pLoadTimestamps(urlRoot),
			DataUtil.brew.pLoadPropIndex(urlRoot),
			DataUtil.brew.pLoadNameIndex(urlRoot),
		]);
		const props = opts.isShowAll ? BrewUtil.getPageProps(UrlUtil.PG_MANAGE_BREW) : BrewUtil.getPageProps();

		const seenPaths = new Set();

		dataList = [];
		props.forEach(prop => {
			Object.entries(propIndex[prop] || {})
				.forEach(([path, dir]) => {
					if (seenPaths.has(path)) return;
					seenPaths.add(path);
					dataList.push({
						download_url: DataUtil.brew.getFileUrl(path, urlRoot),
						path,
						name: path.slice(path.indexOf("/") + 1),
						_cat: BrewUtil.dirToProp(dir),
					})
				})
		});

		dataList.forEach(it => {
			const cleanFilename = it.name.trim().replace(/\.json$/, "");
			const spl = cleanFilename.split(";").map(it => it.trim());
			if (spl.length > 1) {
				it._brewName = spl[1];
				it._brewAuthor = spl[0];
			} else {
				it._brewName = cleanFilename;
				it._brewAuthor = "";
			}
		});
		dataList.sort((a, b) => SortUtil.ascSortLower(a._brewName, b._brewName));

		const list = new List({
			$iptSearch,
			$wrpList: $wrpRows,
			fnSort,
			isUseJquery: true,
			isFuzzy: true,
		});
		SortUtil.initBtnSortHandlers($modalInner.find(".manbrew__filtertools"), list);

		dataList.forEach((it, i) => {
			it._brewAdded = (timestamps[it.path] || {}).a || 0;
			it._brewModified = (timestamps[it.path] || {}).m || 0;
			it._brewInternalSources = (nameIndex[it.name]) || [];
			it._brewCat = BrewUtil._pRenderBrewScreen_getDisplayCat(BrewUtil.dirToProp(it._cat));

			const timestampAdded = it._brewAdded ? DatetimeUtil.getDateStr(new Date(it._brewAdded * 1000), true) : "";
			const timestampModified = it._brewModified ? DatetimeUtil.getDateStr(new Date(it._brewModified * 1000), true) : "";

			const $btnAdd = $(`<span class="col-4 bold manbrew__load_from_url pl-0 clickable"></span>`)
				.text(it._brewName)
				.click(() => BrewUtil.addBrewRemote($btnAdd, it.download_url || "", true));

			const $row = $$`<div class="lst__row lst__row-inner not-clickable lst--border lst__row--focusable" tabindex="1">
				<div class="lst__wrp-cells flex w-100">
					${$btnAdd}
					<span class="col-3">${it._brewAuthor}</span>
					<span class="col-1-2 text-center">${it._brewCat}</span>
					<span class="col-1-4 text-center">${timestampModified}</span>
					<span class="col-1-4 text-center">${timestampAdded}</span>
					<span class="col-1 manbrew__source text-center pr-0"><a href="${it.download_url}" target="_blank" rel="noopener noreferrer">View Raw</a></span>
				</div>
			</div>`;

			$row.keydown(evt => {
				switch (evt.which) {
					case 13: { // enter
						return $btnAdd.click()
					}
					case 38: { // up
						const ixCur = list.visibleItems.indexOf(listItem);
						if (~ixCur) {
							const prevItem = list.visibleItems[ixCur - 1];
							if (prevItem) prevItem.ele.focus();
						} else {
							const firstItem = list.visibleItems[0];
							if (firstItem) firstItem.ele.focus();
						}
						return;
					}
					case 40: { // down
						const ixCur = list.visibleItems.indexOf(listItem);
						if (~ixCur) {
							const nxtItem = list.visibleItems[ixCur + 1];
							if (nxtItem) nxtItem.ele.focus();
						} else {
							const lastItem = list.visibleItems.last();
							if (lastItem) lastItem.ele.focus();
						}
					}
				}
			});

			const listItem = new ListItem(
				i,
				$row,
				it._brewName,
				{
					author: it._brewAuthor,
					category: it._brewCat,
					// Used for search
					internalSources: it._brewInternalSources,
				},
				{
					$btnAdd,
					isSample: it._brewAuthor.toLowerCase().startsWith("sample -"),
					added: timestampAdded,
					modified: timestampAdded,
				},
			);
			list.addItem(listItem);
		});

		list.init();

		$btnAll
			.prop("disabled", false)
			.click(async () => {
				const toAdd = list.visibleItems.filter(it => !it.data.isSample);
				if (toAdd.length > 10 && !await InputUiUtil.pGetUserBoolean({title: "Are you sure?", htmlDescription: `<div>You area about to load ${toAdd.length} homebrew files.<br>Loading large quantities of homebrew can lead to performance and stability issues.</div>`, textYes: "Continue"})) return;
				toAdd.forEach(it => it.data.$btnAdd.click());
			});

		if ($btnToggleDisplayNonPageBrews) {
			$btnToggleDisplayNonPageBrews
				.prop("disabled", false)
				.click(() => {
					$btnToggleDisplayNonPageBrews.toggleClass("active");
					doClose();
					BrewUtil._pHandleClickBtnGet({
						...opts,
						isShowAll: !$btnToggleDisplayNonPageBrews.hasClass("active"),
					});
				});
		}

		$iptSearch.focus();
	},

	_$getBtnDeleteAll (isModal) {
		return $(`<button class="btn ${isModal ? "btn-xs" : "btn-sm ml-2"} btn-danger">Delete All</button>`)
			.click(async () => {
				if (!window.confirm("Are you sure?")) return;
				await StorageUtil.pSet(VeCt.STORAGE_HOMEBREW, {});
				StorageUtil.syncSet(VeCt.STORAGE_HOMEBREW_META, {});
				window.location.hash = "";
				location.reload();
			});
	},

	async _pCleanSaveBrew () {
		const cpy = MiscUtil.copy(BrewUtil.homebrew || {});
		BrewUtil._STORABLE.forEach(prop => {
			(cpy[prop] || []).forEach(ent => {
				Object.keys(ent).filter(k => k.startsWith("_")).forEach(k => delete ent[k]);
			});
		});
		await StorageUtil.pSet(VeCt.STORAGE_HOMEBREW, cpy);
	},

	async _pRenderBrewScreen_pDeleteSource ($brewList, source, doConfirm, isAllSources) {
		if (doConfirm && !window.confirm(`Are you sure you want to remove all homebrew${!isAllSources ? ` with${source ? ` source "${Parser.sourceJsonToFull(source)}"` : `out a source`}` : ""}?`)) return;

		const vetoolsSourceSet = new Set(BrewUtil._getActiveVetoolsSources().map(it => it.json));
		const isMatchingSource = (itSrc) => isAllSources || (itSrc === source || (source === undefined && !vetoolsSourceSet.has(itSrc) && !BrewUtil.hasSourceJson(itSrc)));

		await Promise.all(BrewUtil._getBrewCategories().map(async k => {
			const cat = BrewUtil.homebrew[k];
			const pDeleteFn = BrewUtil._getPDeleteFunction(k);
			const toDel = [];
			cat.filter(it => isMatchingSource(it.source)).forEach(it => toDel.push(it.uniqueId));
			await Promise.all(toDel.map(async uId => pDeleteFn(uId)));
		}));
		if (BrewUtil._lists) BrewUtil._lists.forEach(l => l.update());
		BrewUtil._persistHomebrewDebounced();
		BrewUtil.removeJsonSource(source);
		// remove the source from the filters and re-render the filter box
		if (BrewUtil._sourceFilter) BrewUtil._sourceFilter.removeItem(source);
		if (BrewUtil._filterBox) BrewUtil._filterBox.render();
		await BrewUtil._pRenderBrewScreen_pRefreshBrewList($brewList);
		window.location.hash = "";
		if (BrewUtil._filterBox) BrewUtil._filterBox.fireChangeEvent();
	},

	async _pRenderBrewScreen_pRefreshBrewList ($brewList) {
		function showSourceManager (source, showAll) {
			const $wrpBtnDel = $(`<div class="flex-v-center"></div>`);

			const {$modalInner, doClose} = UiUtil.getShowModal({
				isHeight100: true,
				title: `View/Manage ${source ? `Source Contents: ${Parser.sourceJsonToFull(source)}` : showAll ? "Entries from All Sources" : `Entries with No Source`}`,
				isUncappedHeight: true,
				isWidth100: true,
				overlayColor: "transparent",
				$titleSplit: $wrpBtnDel,
				isHeaderBorder: true,
			});

			const $cbAll = $(`<input type="checkbox">`);
			const $wrpRows = $$`<div class="list flex-col w-100"></div>`;
			const $iptSearch = $(`<input type="search" class="search manbrew__search form-control w-100 mt-1" placeholder="Search entries...">`);
			const $wrpBtnsSort = $$`<div class="filtertools manbrew__filtertools btn-group">
				<button class="col-6 sort btn btn-default btn-xs" data-sort="name">Name</button>
				<button class="col-5 sort btn btn-default btn-xs" data-sort="category">Category</button>
				<label class="wrp-cb-all pr-0 flex-vh-center mb-0 h-100">${$cbAll}</label>
			</div>`;
			$$($modalInner)`
				${$iptSearch}
				${$wrpBtnsSort}
				${$wrpRows}`;

			let list;

			// populate list
			function populateList () {
				$wrpRows.empty();

				list = new List({
					$iptSearch,
					$wrpList: $wrpRows,
					fnSort: SortUtil.listSort,
				});

				ListUiUtil.bindSelectAllCheckbox($cbAll.off("change"), list);

				function mapCategoryEntry (cat, bru) {
					const out = {};
					out.name = bru.name;
					out.uniqueId = bru.uniqueId;
					out.extraInfo = "";
					switch (cat) {
						case "subclass":
							out.extraInfo = ` (${bru.class})`;
							break;
						case "subrace":
							out.extraInfo = ` (${(bru.race || {}).name})`;
							break;
						case "psionic":
							out.extraInfo = ` (${Parser.psiTypeToMeta(bru.type).short})`;
							break;
						case "itemProperty": {
							if (bru.entries) out.name = Renderer.findName(bru.entries);
							if (!out.name) out.name = bru.abbreviation;
							break;
						}
						case "adventureData":
						case "bookData": {
							const assocData = {
								"adventureData": "adventure",
								"bookData": "book",
							};
							out.name = (((BrewUtil.homebrew[assocData[cat]] || []).find(a => a.id === bru.id) || {}).name || bru.id);
						}
					}
					out.name = out.name || `(Unknown)`;
					return out;
				}

				const vetoolsSourceSet = new Set(BrewUtil._getActiveVetoolsSources().map(it => it.json));

				const isMatchingSource = (itSrc) => showAll || (itSrc === source || (source === undefined && !vetoolsSourceSet.has(itSrc) && !BrewUtil.hasSourceJson(itSrc)));
				BrewUtil._getBrewCategories().forEach(cat => {
					BrewUtil.homebrew[cat]
						.filter(it => isMatchingSource(it.source))
						.map(it => mapCategoryEntry(cat, it))
						.sort((a, b) => SortUtil.ascSort(a.name, b.name))
						.forEach((it, i) => {
							const dispCat = BrewUtil._pRenderBrewScreen_getDisplayCat(cat, true);

							const eleLi = document.createElement("div");
							eleLi.className = "lst__row flex-col px-0";

							eleLi.innerHTML = `<label class="lst--border lst__row-inner no-select mb-0 flex-v-center">
								<div class="col-6 bold">${it.name}</div>
								<div class="col-5 flex-vh-center">${dispCat}${it.extraInfo}</div>
								<div class="pr-0 col-1 flex-vh-center"><input type="checkbox" class="no-events"></div>
							</label>`;

							const listItem = new ListItem(
								i,
								eleLi,
								it.name,
								{
									category: dispCat,
									category_raw: cat,
								},
								{
									uniqueId: it.uniqueId,
									cbSel: eleLi.firstElementChild.children[2].firstElementChild,
								},
							);
							list.addItem(listItem);

							eleLi.addEventListener("click", evt => ListUiUtil.handleSelectClick(list, listItem, evt));
						});
				});
				$wrpRows.empty();

				list.init();
				if (!list.items.length) $wrpRows.append(`<h5 class="text-center">No results found.</h5>`);
				SortUtil.initBtnSortHandlers($wrpBtnsSort, list);
			}
			populateList();

			$(`<button class="btn btn-danger btn-xs">Delete Selected</button>`).on("click", async () => {
				const toDel = list.items.filter(it => $(it.ele).find(`input`).prop("checked")).map(it => ({...it.values, ...it.data}));

				if (!toDel.length) return;
				if (!window.confirm(`Are you sure you want to delete the ${toDel.length} selected item${toDel.length === 1 ? "" : "s"}?`)) return;

				if (toDel.length === list.items.length) {
					await BrewUtil._pRenderBrewScreen_pDeleteSource($brewList, source, false, false);
					doClose();
				} else {
					await Promise.all(toDel.map(async it => {
						const pDeleteFn = BrewUtil._getPDeleteFunction(it.category_raw);
						await pDeleteFn(it.uniqueId);
					}));
					if (BrewUtil._lists) BrewUtil._lists.forEach(l => l.update());
					BrewUtil._persistHomebrewDebounced();
					populateList();
					await BrewUtil._pRenderBrewScreen_pRefreshBrewList($brewList);
					window.location.hash = "";
				}
			}).appendTo($wrpBtnDel);

			$iptSearch.focus();
		}

		$brewList.empty();
		if (!BrewUtil.homebrew) return;

		const $iptSearch = $(`<input type="search" class="search manbrew__search form-control" placeholder="Search active homebrew...">`);
		const $wrpList = $(`<div class="list-display-only brew-list brew-list--target manbrew__list flex-col w-100 mb-3"></div>`);
		const $wrpListGroup = $(`<div class="list-display-only brew-list brew-list--groups no-shrink flex-col w-100" style="height: initial;"></div>`);

		const list = new List({
			$iptSearch,
			$wrpList,
			isUseJquery: true,
			isFuzzy: true,
			sortByInitial: "source",
		});

		const $lst = $$`
			<div class="flex-col h-100">
				${$iptSearch}
				<div class="filtertools manbrew__filtertools btn-group input-group input-group--bottom flex no-shrink">
					<button class="col-5 sort btn btn-default btn-xs ve-grow" data-sort="source">Source</button>
					<button class="col-5 sort btn btn-default btn-xs" data-sort="authors">Authors</button>
					<button class="col-1 btn btn-default btn-xs" disabled>Origin</button>
					<button class="col-1 ve-grow btn btn-default btn-xs" disabled>&nbsp;</button>
				</div>
				<div class="flex w-100 h-100 overflow-y-auto relative">${$wrpList}</div>
			</div>
		`.appendTo($brewList);
		$wrpListGroup.appendTo($brewList);
		SortUtil.initBtnSortHandlers($lst.find(".manbrew__filtertools"), list);

		const createButtons = (src, $row, isFooterGroup) => {
			const hasConverters = !isFooterGroup && !!src.convertedBy?.length;
			const btnConvertedBy = isFooterGroup ? null : e_({
				tag: "button",
				clazz: `btn btn-xs btn-default ${!hasConverters ? "disabled" : ""}`,
				title: hasConverters ? `Converted by: ${src.convertedBy.join(", ").qq()}` : "(No conversion credit given)",
				children: [
					e_({
						tag: "span",
						clazz: "glyphicon glyphicon-certificate",
					}),
				],
				click: () => {
					if (!hasConverters) return;
					const {$modalInner} = UiUtil.getShowModal({
						title: "Converted By:",
						isMinHeight0: true,
					});

					if (src.convertedBy.length === 1) return $modalInner.append(`<div>${src.convertedBy.join("").qq()}</div>`);

					$modalInner.append(`<ul>${src.convertedBy.map(it => `<li>${it.qq()}</li>`).join("")}</ul>`);
				},
			});

			const $btnViewManage = $(`<button class="btn btn-xs btn-default" title="View/Manage"><span class="glyphicon glyphicon-folder-close"></span></button>`)
				.on("click", () => {
					showSourceManager(src.json, src._all);
				});

			const $btnDeleteAll = $(`<button class="btn btn-danger btn-xs"><span class="glyphicon glyphicon-trash"></span></button>`)
				.on("click", () => BrewUtil._pRenderBrewScreen_pDeleteSource($brewList, src.json, true, src._all));

			$$`<div class="${isFooterGroup ? `flex-v-center flex-h-right` : `flex-vh-center ve-grow`} btn-group">
				${$btnViewManage}
				${btnConvertedBy}
				${$btnDeleteAll}
			</div>`.appendTo($row);
		};

		const brewSources = MiscUtil.copy(BrewUtil.getJsonSources())
			.filter(src => BrewUtil._isSourceRelevantForCurrentPage(src.json));
		brewSources.sort((a, b) => SortUtil.ascSort(a.full, b.full));

		brewSources.forEach((src, i) => {
			const validAuthors = (!src.authors ? [] : !(src.authors instanceof Array) ? [] : src.authors).join(", ");
			const isGroup = src._unknown || src._all;

			const $row = $(`<div class="manbrew__row flex-v-center lst__row lst--border lst__row-inner no-shrink">
				<span class="col-5 source manbrew__source">${isGroup ? "<i>" : ""}${src.full}${isGroup ? "</i>" : ""}</span>
				<span class="col-5 authors">${validAuthors}</span>
				<${src.url ? "a" : "span"} class="col-1 text-center" ${src.url ? `href="${src.url}" target="_blank" rel="noopener noreferrer"` : ""}>${src.url ? "View Source" : ""}</${src.url ? "a" : "span"}>
				<span class="hidden">${src.abbreviation}</span>
			</div>`);
			createButtons(src, $row);

			const listItem = new ListItem(
				i,
				$row,
				src.full,
				{
					authors: validAuthors,
					abbreviation: src.abbreviation,
				},
			);
			list.addItem(listItem);
		});

		const createGroupRow = (fullText, modeProp) => {
			const $row = $(`<div class="manbrew__row flex-h-right flex-v-center">
				<div class="source manbrew__source text-right"><i class="mr-3">${fullText}</i></div>
			</div>`);
			createButtons({[modeProp]: true}, $row, true);
			$wrpListGroup.append($row);
		};
		createGroupRow("Entries From All Sources", "_all");
		createGroupRow("Entries Without Sources", "_unknown");

		list.init();
		$iptSearch.focus();
	},

	_isSourceRelevantForCurrentPage (source) {
		const cats = BrewUtil.getPageProps();
		return !!cats.find(cat => !!(BrewUtil.homebrew[cat] || []).some(entry => (entry.inherits ? entry.inherits.source : entry.source) === source));
	},

	getPageProps (page) {
		page = BrewUtil._PAGE || page || UrlUtil.getCurrentPage();

		const _PG_SPELLS = ["spell", "spellFluff"];
		const _PG_BESTIARY = ["monster", "legendaryGroup", "monsterFluff"];

		switch (page) {
			case UrlUtil.PG_SPELLS: return _PG_SPELLS;
			case UrlUtil.PG_CLASSES: return ["class", "subclass", "classFeature", "subclassFeature"];
			case UrlUtil.PG_BESTIARY: return _PG_BESTIARY;
			case UrlUtil.PG_BACKGROUNDS: return ["background"];
			case UrlUtil.PG_FEATS: return ["feat"];
			case UrlUtil.PG_OPT_FEATURES: return ["optionalfeature"];
			case UrlUtil.PG_RACES: return ["race", "raceFluff", "subrace"];
			case UrlUtil.PG_OBJECTS: return ["object"];
			case UrlUtil.PG_TRAPS_HAZARDS: return ["trap", "hazard"];
			case UrlUtil.PG_DEITIES: return ["deity"];
			case UrlUtil.PG_ITEMS: return ["item", "baseitem", "variant", "itemProperty", "itemType", "itemFluff", "itemGroup", "itemEntry"];
			case UrlUtil.PG_REWARDS: return ["reward"];
			case UrlUtil.PG_PSIONICS: return ["psionic"];
			case UrlUtil.PG_VARIANTRULES: return ["variantrule"];
			case UrlUtil.PG_CONDITIONS_DISEASES: return ["condition", "disease", "status"];
			case UrlUtil.PG_ADVENTURES: return ["adventure", "adventureData"];
			case UrlUtil.PG_BOOKS: return ["book", "bookData"];
			case UrlUtil.PG_TABLES: return ["table", "tableGroup"];
			case UrlUtil.PG_MAKE_BREW: return [
				..._PG_SPELLS,
				..._PG_BESTIARY,
				"makebrewCreatureTrait",
			];
			case UrlUtil.PG_MANAGE_BREW:
			case UrlUtil.PG_DEMO_RENDER: return BrewUtil._STORABLE;
			case UrlUtil.PG_VEHICLES: return ["vehicle", "vehicleUpgrade"];
			case UrlUtil.PG_ACTIONS: return ["action"];
			case UrlUtil.PG_CULTS_BOONS: return ["cult", "boon"];
			case UrlUtil.PG_LANGUAGES: return ["language", "languageScript"];
			case UrlUtil.PG_CHAR_CREATION_OPTIONS: return ["charoption"];
			case UrlUtil.PG_RECIPES: return ["recipe"];
			case UrlUtil.PG_CLASS_SUBCLASS_FEATURES: return ["classFeature", "subclassFeature"];
			default: throw new Error(`No homebrew properties defined for category ${page}`);
		}
	},

	dirToProp (dir) {
		if (!dir) return "";
		else if (BrewUtil._STORABLE.includes(dir)) return dir;
		else {
			switch (dir) {
				case "creature": return "monster";
				case "collection": return dir;
				case "magicvariant": return "variant";
				case "makebrew": return "makebrewCreatureTrait";
			}
			throw new Error(`Directory was not mapped to a category: "${dir}"`);
		}
	},

	_pRenderBrewScreen_getDisplayCat (cat, isManager) {
		switch (cat) {
			case "variantrule": return "Variant Rule";
			case "legendaryGroup": return "Legendary Group";
			case "optionalfeature": return "Optional Feature";
			case "adventure": return isManager ? "Adventure Contents/Info" : "Adventure";
			case "adventureData": return "Adventure Text";
			case "book": return isManager ? "Book Contents/Info" : "Book";
			case "bookData": return "Book Text";
			case "itemProperty": return "Item Property";
			case "itemEntry": return "Item Entry";
			case "baseitem": return "Base Item";
			case "variant": return "Magic Item Variant";
			case "itemGroup": return "Item Group";
			case "monsterFluff": return "Monster Fluff";
			case "itemFluff": return "Item Fluff";
			case "makebrewCreatureTrait": return "Homebrew Builder Creature Trait";
			case "classFeature": return "Class Feature";
			case "subclassFeature": return "Subclass Feature";
			case "charoption": return "Other Character Creation Option";
			default: return cat.uppercaseFirst();
		}
	},

	handleLoadbrewClick: async (ele) => {
		const $ele = $(ele);
		if (!$ele.hasClass("rd__wrp-loadbrew--ready")) return; // an existing click is being handled
		let jsonUrl = ele.dataset.rdLoaderPath;
		const name = ele.dataset.rdLoaderName;
		const cached = $ele.html();
		const cachedTitle = $ele.title();
		$ele.title("");
		$ele.removeClass("rd__wrp-loadbrew--ready").html(`${name.qq()}<span class="glyphicon glyphicon-refresh rd__loadbrew-icon rd__loadbrew-icon--active"></span>`);
		jsonUrl = jsonUrl.unescapeQuotes();
		const data = await DataUtil.loadJSON(`${jsonUrl}?${(new Date()).getTime()}`);
		await BrewUtil.pDoHandleBrewJson(data, BrewUtil._PAGE || UrlUtil.getCurrentPage());
		$ele.html(`${name.qq()}<span class="glyphicon glyphicon-saved rd__loadbrew-icon"></span>`);
		setTimeout(() => $ele.html(cached).addClass("rd__wrp-loadbrew--ready").title(cachedTitle), 500);
	},

	async _pDoRemove (arrName, uniqueId, {isChild} = {}) {
		const index = BrewUtil.homebrew[arrName].findIndex(it => isChild ? it.parentUniqueId : it.uniqueId === uniqueId)
		if (!~index) return;

		const toRemove = BrewUtil.homebrew[arrName][index];
		BrewUtil.homebrew[arrName].splice(index, 1);
		if (BrewUtil._lists) {
			BrewUtil._lists.forEach(l => l.removeItemByData(isChild ? "parentUniqueId" : "uniqueId", uniqueId));
		}
		return toRemove;
	},

	_getPDeleteFunction (category) {
		switch (category) {
			case "spell":
			case "spellFluff":
			case "monster":
			case "monsterFluff":
			case "background":
			case "feat":
			case "optionalfeature":
			case "raceFluff":
			case "subrace":
			case "object":
			case "trap":
			case "hazard":
			case "deity":
			case "item":
			case "baseitem":
			case "variant":
			case "itemType":
			case "itemProperty":
			case "itemFluff":
			case "itemGroup":
			case "itemEntry":
			case "reward":
			case "psionic":
			case "variantrule":
			case "legendaryGroup":
			case "condition":
			case "disease":
			case "status":
			case "table":
			case "tableGroup":
			case "vehicle":
			case "vehicleUpgrade":
			case "action":
			case "cult":
			case "boon":
			case "language":
			case "languageScript":
			case "class":
			case "makebrewCreatureTrait":
			case "classFeature":
			case "subclassFeature":
			case "charoption":
			case "charoptionFluff":
			case "recipe":
				return BrewUtil._pPDeleteGenericBrew.bind(BrewUtil, category);
			case "race": return BrewUtil._pDeleteRaceBrew.bind(BrewUtil);
			case "subclass": return BrewUtil._pDeleteSubclassBrew.bind(BrewUtil);
			case "adventure":
			case "book": return BrewUtil._pDeleteGenericBookBrew.bind(BrewUtil, category);
			case "adventureData":
			case "bookData": return () => {}; // Do nothing, handled by deleting the associated book/adventure
			default: throw new Error(`No homebrew delete function defined for category ${category}`);
		}
	},

	async _pDeleteSubclassBrew (uniqueId) {
		let sc;
		let index = 0;
		for (; index < BrewUtil.homebrew.subclass.length; ++index) {
			if (BrewUtil.homebrew.subclass[index].uniqueId === uniqueId) {
				sc = BrewUtil.homebrew.subclass[index];
				break;
			}
		}

		if (sc) {
			BrewUtil.homebrew.subclass.splice(index, 1);
			BrewUtil._persistHomebrewDebounced();

			if (typeof ClassesPage === "undefined") return;
			await classesPage.pDeleteSubclassBrew(uniqueId, sc);
		}
	},

	async _pDeleteRaceBrew (uniqueId) {
		const removedRace = await BrewUtil._pDoRemove("race", uniqueId);
		if (!removedRace || !removedRace.subraces) return;
		if (typeof racesPage === "undefined" || !BrewUtil._lists) return;

		const subraceMetas = removedRace.subraces
			.map(it => ({name: it.name, source: it.source || removedRace.source}))
			.filter(it => it.name);
		if (!subraceMetas.length) return;

		const allAttachedRaces = racesPage.getMergedSubraces(uniqueId)
			.filter(it => subraceMetas.some(meta => meta.name === it._subraceName && meta.source === it.source))
			.filter(it => it.uniqueId);

		if (!allAttachedRaces) return;

		allAttachedRaces.forEach(attachedRace => {
			BrewUtil._lists.forEach(l => l.removeItemByData("uniqueId", attachedRace.uniqueId));
		});
	},

	async _pPDeleteGenericBrew (category, uniqueId) {
		await BrewUtil._pDoRemove(category, uniqueId);
	},

	async _pDeleteGenericBookBrew (category, uniqueId) {
		await BrewUtil._pDoRemove(category, uniqueId);
		await BrewUtil._pDoRemove(`${category}Data`, uniqueId, {isChild: true});
	},

	manageBrew: () => {
		const {$modalInner} = UiUtil.getShowModal({
			isHeight100: true,
			isWidth100: true,
			title: `Manage Homebrew`,
			isUncappedHeight: true,
			$titleSplit: BrewUtil._$getBtnDeleteAll(true),
			isHeaderBorder: true,
		});

		BrewUtil._pRenderBrewScreen($modalInner, {isModal: true});
	},

	async pAddEntry (prop, obj) {
		BrewUtil._mutUniqueId(obj);
		(BrewUtil.homebrew[prop] = BrewUtil.homebrew[prop] || []).push(obj);
		BrewUtil._persistHomebrewDebounced();
		return BrewUtil.homebrew[prop].length - 1;
	},

	async pRemoveEntry (prop, obj) {
		const ix = (BrewUtil.homebrew[prop] = BrewUtil.homebrew[prop] || []).findIndex(it => it.uniqueId === obj.uniqueId);
		if (~ix) {
			BrewUtil.homebrew[prop].splice(ix, 1);
			BrewUtil._persistHomebrewDebounced();
		} else throw new Error(`Could not find object with ID "${obj.uniqueId}" in "${prop}" list`);
	},

	getEntryIxByEntry (prop, obj) {
		return (BrewUtil.homebrew[prop] = BrewUtil.homebrew[prop] || []).findIndex(it => it.name === obj.name && it.source === obj.source);
	},

	getEntryByEntryIx (prop, ix) {
		return (BrewUtil.homebrew[prop] = BrewUtil.homebrew[prop] || [])[ix];
	},

	async pUpdateEntryByIx (prop, ix, obj) {
		if (~ix && ix < BrewUtil.homebrew[prop].length) {
			BrewUtil._mutUniqueId(obj);
			BrewUtil.homebrew[prop].splice(ix, 1, obj);
			BrewUtil._persistHomebrewDebounced();
		} else throw new Error(`Index "${ix}" was not valid!`);
	},

	_mutUniqueId (obj) {
		delete obj.uniqueId; // avoid basing the hash on the previous hash
		obj.uniqueId = CryptUtil.md5(JSON.stringify(obj));
	},

	_DIRS: ["action", "adventure", "background", "book", "boon", "charoption", "class", "condition", "creature", "cult", "deity", "disease", "feat", "hazard", "item", "language", "magicvariant", "makebrew", "object", "optionalfeature", "psionic", "race", "recipe", "reward", "spell", "spellFluff", /* "status", */ "subclass", "subrace", "table", "trap", "variantrule", "vehicle", "classFeature", "subclassFeature"],
	_STORABLE: ["class", "subclass", "classFeature", "subclassFeature", "spell", "spellFluff", "monster", "legendaryGroup", "monsterFluff", "background", "feat", "optionalfeature", "race", "raceFluff", "subrace", "deity", "item", "baseitem", "variant", "itemProperty", "itemType", "itemFluff", "itemGroup", "itemEntry", "psionic", "reward", "object", "trap", "hazard", "variantrule", "condition", "disease", "status", "adventure", "adventureData", "book", "bookData", "table", "tableGroup", "vehicle", "vehicleUpgrade", "action", "cult", "boon", "language", "languageScript", "makebrewCreatureTrait", "charoption", "charoptionFluff", "recipe"],
	async pDoHandleBrewJson (json, page, pFuncRefresh) {
		page = BrewUtil._PAGE || page;
		await BrewUtil._lockHandleBrewJson.pLock();
		try {
			await BrewUtil._pDoHandleBrewJson(json, page, {pFuncRefresh});

			// Allow blacklists to be loaded alongside homebrew
			if (json.blacklist && ExcludeUtil.isInitialised) {
				await ExcludeUtil.pSetList(ExcludeUtil.getList().concat(json.blacklist || []));
			}
		} finally {
			BrewUtil._lockHandleBrewJson.unlock();
		}
	},

	async _pDoHandleBrewJson (json, page, {pFuncRefresh, isLocalPreload, homebrew} = {}) {
		page = BrewUtil._PAGE || page;

		homebrew = homebrew || BrewUtil.homebrew || {};

		function storePrep (arrName) {
			if (
				(json[arrName] != null && !(json[arrName] instanceof Array))
				|| !json[arrName]
			) return;

			json[arrName].forEach(it => BrewUtil._mutUniqueId(it));
		}

		// prepare for storage
		BrewUtil._STORABLE.forEach(storePrep);

		const bookPairs = [
			["adventure", "adventureData"],
			["book", "bookData"],
		];
		bookPairs.forEach(([bookMetaKey, bookDataKey]) => {
			if (json[bookMetaKey] && json[bookDataKey]) {
				json[bookMetaKey].forEach(book => {
					const data = json[bookDataKey].find(it => it.id === book.id);
					if (data) {
						data.parentUniqueId = book.uniqueId;
					}
				});
			}
		});

		// store
		async function pCheckAndAdd (prop) {
			if (!homebrew[prop]) homebrew[prop] = [];
			if (!json[prop] || !(json[prop] instanceof Array)) return [];
			if (IS_DEPLOYED || IS_VTT || IS_NODE) {
				// in production mode, skip any existing brew
				const areNew = [];
				const existingIds = homebrew[prop].map(it => it.uniqueId);
				json[prop].forEach(it => {
					if (!existingIds.find(id => it.uniqueId === id)) {
						homebrew[prop].push(it);
						areNew.push(it);
					}
				});
				return areNew;
			}

			// in development mode, replace any existing brew
			const existingLookup = {};
			homebrew[prop].forEach(it => {
				const brewHash = BrewUtil._getDevBrewHash(page, prop, it);
				existingLookup[brewHash] = it.uniqueId;
			});

			const pDeleteFn = BrewUtil._getPDeleteFunction(prop);
			for (const entity of json[prop]) {
				const brewHash = BrewUtil._getDevBrewHash(page, prop, entity);
				if (existingLookup[brewHash] && entity.uniqueId !== existingLookup[brewHash]) {
					if (isLocalPreload) {
						const ixExisting = homebrew[prop].findIndex(ex => BrewUtil._getDevBrewHash(page, prop, ex) === brewHash);
						if (~ixExisting) homebrew[prop].splice(ixExisting, 1);
					} else {
						await pDeleteFn(existingLookup[brewHash]);
					}

					homebrew[prop].push(entity);
				} else if (!existingLookup[brewHash]) {
					homebrew[prop].push(entity);
				}
			}

			return json[prop];
		}

		function checkAndAddMetaGetNewSources () {
			const areNew = [];
			if (json._meta) {
				if (!BrewUtil.homebrewMeta) BrewUtil.homebrewMeta = {sources: []};

				Object.keys(json._meta).forEach(k => {
					switch (k) {
						case "dateAdded":
						case "dateLastModified":
							break;
						case "sources": {
							const existing = BrewUtil.homebrewMeta.sources.map(src => src.json);
							json._meta.sources.forEach(src => {
								if (!existing.find(it => it === src.json)) {
									BrewUtil.homebrewMeta.sources.push(src);
									areNew.push(src);
								}
							});
							break;
						}
						default: {
							BrewUtil.homebrewMeta[k] = BrewUtil.homebrewMeta[k] || {};
							Object.assign(BrewUtil.homebrewMeta[k], json._meta[k]);
							break;
						}
					}
				});
			}
			return areNew;
		}

		let sourcesToAdd = json._meta ? json._meta.sources : [];
		const toAdd = {};
		BrewUtil._STORABLE.filter(k => json[k] && (json[k] instanceof Array)).forEach(k => toAdd[k] = json[k]);
		sourcesToAdd = checkAndAddMetaGetNewSources(); // adding source(s) to Filter should happen in per-page addX functions
		await Promise.all(BrewUtil._STORABLE.map(async k => toAdd[k] = await pCheckAndAdd(k))); // only add if unique ID not already present
		// TODO ...run some `DataUtil[prop].mutateBrew(ent)` function for each thing here?
		if (!isLocalPreload) BrewUtil._persistHomebrewDebounced(); // Debounce this for mass adds, e.g. "Add All"
		StorageUtil.syncSet(VeCt.STORAGE_HOMEBREW_META, BrewUtil.homebrewMeta);

		// wipe old cache
		BrewUtil._resetSourceCache();

		// display on page
		if (!isLocalPreload) {
			switch (page) {
				case UrlUtil.PG_SPELLS:
				case UrlUtil.PG_CLASSES:
				case UrlUtil.PG_BESTIARY:
				case UrlUtil.PG_BACKGROUNDS:
				case UrlUtil.PG_FEATS:
				case UrlUtil.PG_OPT_FEATURES:
				case UrlUtil.PG_RACES:
				case UrlUtil.PG_OBJECTS:
				case UrlUtil.PG_TRAPS_HAZARDS:
				case UrlUtil.PG_DEITIES:
				case UrlUtil.PG_ITEMS:
				case UrlUtil.PG_REWARDS:
				case UrlUtil.PG_PSIONICS:
				case UrlUtil.PG_VARIANTRULES:
				case UrlUtil.PG_CONDITIONS_DISEASES:
				case UrlUtil.PG_ADVENTURE:
				case UrlUtil.PG_ADVENTURES:
				case UrlUtil.PG_BOOK:
				case UrlUtil.PG_BOOKS:
				case UrlUtil.PG_TABLES:
				case UrlUtil.PG_VEHICLES:
				case UrlUtil.PG_ACTIONS:
				case UrlUtil.PG_CULTS_BOONS:
				case UrlUtil.PG_LANGUAGES:
				case UrlUtil.PG_CHAR_CREATION_OPTIONS:
				case UrlUtil.PG_RECIPES:
				case UrlUtil.PG_CLASS_SUBCLASS_FEATURES:
					await (BrewUtil._pHandleBrew || handleBrew)(MiscUtil.copy(toAdd));
					break;
				case UrlUtil.PG_MAKE_BREW:
					if (BrewUtil._pHandleBrew) await BrewUtil._pHandleBrew(MiscUtil.copy(toAdd));
					break;
				case UrlUtil.PG_MANAGE_BREW:
				case UrlUtil.PG_DEMO_RENDER:
				case VeCt.PG_NONE:
					// No-op
					break;
				default:
					throw new Error(`No homebrew add function defined for category ${page}`);
			}

			if (pFuncRefresh) await pFuncRefresh();

			if (BrewUtil._filterBox && BrewUtil._sourceFilter) {
				const cur = BrewUtil._filterBox.getValues();
				if (cur.Source) {
					const toSet = JSON.parse(JSON.stringify(cur.Source));

					if (toSet._totals.yes || toSet._totals.no) {
						if (page === UrlUtil.PG_CLASSES) toSet["Core"] = 1;
						else sourcesToAdd.forEach(src => toSet[src.json] = 1);
						BrewUtil._filterBox.setFromValues({Source: toSet});
					}
				}
				if (BrewUtil._filterBox) BrewUtil._filterBox.fireChangeEvent();
			}
		}
	},

	_getDevBrewHash (page, prop, it) {
		return UrlUtil.URL_TO_HASH_BUILDER[page]
			? UrlUtil.URL_TO_HASH_BUILDER[page](it)
			: UrlUtil.URL_TO_HASH_BUILDER[prop]
				? UrlUtil.URL_TO_HASH_BUILDER[prop](it)
				// Handle magic variants
				: `${it.inherits && it.inherits.source ? it.inherits.source : it.source}__${it.name}`;
	},

	makeBrewButton: (id) => {
		$(`#${id}`).on("click", () => BrewUtil.manageBrew());
	},

	_getBrewCategories () {
		return Object.keys(BrewUtil.homebrew).filter(it => !it.startsWith("_"));
	},

	// region sources
	_buildSourceCache () {
		function doBuild () {
			if (BrewUtil.homebrewMeta && BrewUtil.homebrewMeta.sources) {
				BrewUtil.homebrewMeta.sources.forEach(src => BrewUtil._sourceCache[src.json.toLowerCase()] = ({...src}));
			}
		}

		if (!BrewUtil._sourceCache) {
			BrewUtil._sourceCache = {};

			if (!BrewUtil.homebrewMeta) {
				const temp = StorageUtil.syncGet(VeCt.STORAGE_HOMEBREW_META) || {};
				temp.sources = temp.sources || [];
				BrewUtil.homebrewMeta = temp;
				doBuild();
			} else {
				doBuild();
			}
		}
	},

	_resetSourceCache () {
		BrewUtil._sourceCache = null;
	},

	removeJsonSource (source) {
		if (!source) return;
		source = source.toLowerCase();
		BrewUtil._resetSourceCache();
		const ix = BrewUtil.homebrewMeta.sources.findIndex(it => it.json.toLowerCase() === source);
		if (~ix) BrewUtil.homebrewMeta.sources.splice(ix, 1);
		StorageUtil.syncSet(VeCt.STORAGE_HOMEBREW_META, BrewUtil.homebrewMeta);
	},

	getJsonSources () {
		BrewUtil._buildSourceCache();
		return BrewUtil.homebrewMeta && BrewUtil.homebrewMeta.sources ? BrewUtil.homebrewMeta.sources : [];
	},

	hasSourceJson (source) {
		if (!source) return false;
		source = source.toLowerCase();
		BrewUtil._buildSourceCache();
		return !!BrewUtil._sourceCache[source];
	},

	sourceJsonToFull (source) {
		if (!source) return "";
		source = source.toLowerCase();
		BrewUtil._buildSourceCache();
		return BrewUtil._sourceCache[source] ? BrewUtil._sourceCache[source].full || source : source;
	},

	sourceJsonToAbv (source) {
		if (!source) return "";
		source = source.toLowerCase();
		BrewUtil._buildSourceCache();
		return BrewUtil._sourceCache[source] ? BrewUtil._sourceCache[source].abbreviation || source : source;
	},

	sourceJsonToDate (source) {
		if (!source) return "";
		source = source.toLowerCase();
		BrewUtil._buildSourceCache();
		return BrewUtil._sourceCache[source] ? BrewUtil._sourceCache[source].dateReleased || source : source;
	},

	sourceJsonToSource (source) {
		if (!source) return null;
		source = source.toLowerCase();
		BrewUtil._buildSourceCache();
		return BrewUtil._sourceCache[source] ? BrewUtil._sourceCache[source] : null;
	},

	sourceJsonToStyle (source) {
		const stylePart = BrewUtil.sourceJsonToStylePart(source);
		if (!stylePart) return stylePart;
		return `style="${stylePart}"`;
	},

	sourceJsonToStylePart (source) {
		if (!source) return "";
		source = source.toLowerCase();
		const color = BrewUtil.sourceJsonToColor(source);
		if (color) return `color: #${color}; border-color: #${color}; text-decoration-color: #${color};`
		return "";
	},

	sourceJsonToColor (source) {
		if (!source) return "";
		source = source.toLowerCase();
		BrewUtil._buildSourceCache();
		if (BrewUtil._sourceCache[source] && BrewUtil._sourceCache[source].color) {
			const validColor = BrewUtil.getValidColor(BrewUtil._sourceCache[source].color);
			if (validColor.length) return validColor;
			return "";
		} else return "";
	},

	getValidColor (color) {
		// Prevent any injection shenanigans
		return color.replace(/[^a-fA-F0-9]/g, "").slice(0, 8);
	},

	addSource (sourceObj) {
		BrewUtil._resetSourceCache();
		const exists = BrewUtil.homebrewMeta.sources.some(it => it.json === sourceObj.json);
		if (exists) throw new Error(`Source "${sourceObj.json}" already exists!`);
		(BrewUtil.homebrewMeta.sources = BrewUtil.homebrewMeta.sources || []).push(sourceObj);
		StorageUtil.syncSet(VeCt.STORAGE_HOMEBREW_META, BrewUtil.homebrewMeta);
	},

	updateSource (sourceObj) {
		BrewUtil._resetSourceCache();
		const ix = BrewUtil.homebrewMeta.sources.findIndex(it => it.json === sourceObj.json);
		if (!~ix) throw new Error(`Source "${sourceObj.json}" does not exist!`);
		const json = BrewUtil.homebrewMeta.sources[ix].json;
		BrewUtil.homebrewMeta.sources[ix] = {
			...sourceObj,
			json,
		};
		StorageUtil.syncSet(VeCt.STORAGE_HOMEBREW_META, BrewUtil.homebrewMeta);
	},

	_getActiveVetoolsSources () {
		if (BrewUtil.homebrew === null) throw new Error(`Homebrew was not initialized!`);

		const allActiveSources = new Set();
		Object.keys(BrewUtil.homebrew).forEach(k => BrewUtil.homebrew[k].forEach(it => it.source && allActiveSources.add(it.source)));
		return Object.keys(Parser.SOURCE_JSON_TO_FULL).map(k => ({
			json: k,
			full: Parser.SOURCE_JSON_TO_FULL[k],
			abbreviation: Parser.SOURCE_JSON_TO_ABV[k],
			dateReleased: Parser.SOURCE_JSON_TO_DATE[k],
		})).sort((a, b) => SortUtil.ascSort(a.full, b.full)).filter(it => allActiveSources.has(it.json));
	},
	// endregion

	/**
	 * Get data in a format similar to the main search index
	 */
	async pGetSearchIndex () {
		BrewUtil._buildSourceCache();
		const indexer = new Omnidexer(Omnisearch.highestId + 1);

		await BrewUtil.pAddBrewData();
		if (BrewUtil.homebrew) {
			const INDEX_DEFINITIONS = [Omnidexer.TO_INDEX__FROM_INDEX_JSON, Omnidexer.TO_INDEX];

			// Run these in serial, to prevent any ID race condition antics
			for (const IX_DEF of INDEX_DEFINITIONS) {
				for (const arbiter of IX_DEF) {
					if (arbiter.isSkipBrew) continue;
					if (!(BrewUtil.homebrew[arbiter.brewProp || arbiter.listProp] || []).length) continue;

					if (arbiter.pFnPreProcBrew) {
						const toProc = await arbiter.pFnPreProcBrew.bind(arbiter)(BrewUtil.homebrew);
						await indexer.pAddToIndex(arbiter, toProc)
					} else {
						await indexer.pAddToIndex(arbiter, BrewUtil.homebrew)
					}
				}
			}
		}

		return Omnidexer.decompressIndex(indexer.getIndex());
	},

	async pGetAdditionalSearchIndices (highestId, addiProp) {
		BrewUtil._buildSourceCache();
		const indexer = new Omnidexer(highestId + 1);

		await BrewUtil.pAddBrewData();
		if (BrewUtil.homebrew) {
			const INDEX_DEFINITIONS = [Omnidexer.TO_INDEX__FROM_INDEX_JSON, Omnidexer.TO_INDEX];

			await Promise.all(INDEX_DEFINITIONS.map(IXDEF => {
				return Promise.all(IXDEF
					.filter(ti => ti.additionalIndexes && (BrewUtil.homebrew[ti.listProp] || []).length)
					.map(ti => {
						return Promise.all(Object.entries(ti.additionalIndexes).filter(([prop]) => prop === addiProp).map(async ([prop, pGetIndex]) => {
							const toIndex = await pGetIndex(indexer, {[ti.listProp]: BrewUtil.homebrew[ti.listProp]});
							toIndex.forEach(add => indexer.pushToIndex(add));
						}));
					}));
			}));
		}
		return Omnidexer.decompressIndex(indexer.getIndex());
	},

	async pGetAlternateSearchIndices (highestId, altProp) {
		BrewUtil._buildSourceCache();
		const indexer = new Omnidexer(highestId + 1);

		await BrewUtil.pAddBrewData();
		if (BrewUtil.homebrew) {
			const INDEX_DEFINITIONS = [Omnidexer.TO_INDEX__FROM_INDEX_JSON, Omnidexer.TO_INDEX];

			for (const IXDEF of INDEX_DEFINITIONS) {
				const filteredIxDef = IXDEF.filter(ti => ti.alternateIndexes && (BrewUtil.homebrew[ti.listProp] || []).length);

				for (const ti of filteredIxDef) {
					const filteredAltIndexes = Object.entries(ti.alternateIndexes)
						.filter(([prop]) => prop === altProp);
					for (const tuple of filteredAltIndexes) {
						const [prop, pGetIndex] = tuple;
						await indexer.pAddToIndex(ti, BrewUtil.homebrew, {alt: ti.alternateIndexes[prop]})
					}
				}
			}
		}

		return Omnidexer.decompressIndex(indexer.getIndex());
	},

	__pPersistHomebrewDebounced: null,
	_persistHomebrewDebounced () {
		if (BrewUtil.__pPersistHomebrewDebounced == null) {
			BrewUtil.__pPersistHomebrewDebounced = MiscUtil.debounce(() => BrewUtil._pCleanSaveBrew(), 125);
		}
		BrewUtil.__pPersistHomebrewDebounced();
	},
};

// ID GENERATION =======================================================================================================
CryptUtil = {
	// region md5 internals
	// stolen from http://www.myersdaily.org/joseph/javascript/md5.js
	_md5cycle: (x, k) => {
		let a = x[0];
		let b = x[1];
		let c = x[2];
		let d = x[3];

		a = CryptUtil._ff(a, b, c, d, k[0], 7, -680876936);
		d = CryptUtil._ff(d, a, b, c, k[1], 12, -389564586);
		c = CryptUtil._ff(c, d, a, b, k[2], 17, 606105819);
		b = CryptUtil._ff(b, c, d, a, k[3], 22, -1044525330);
		a = CryptUtil._ff(a, b, c, d, k[4], 7, -176418897);
		d = CryptUtil._ff(d, a, b, c, k[5], 12, 1200080426);
		c = CryptUtil._ff(c, d, a, b, k[6], 17, -1473231341);
		b = CryptUtil._ff(b, c, d, a, k[7], 22, -45705983);
		a = CryptUtil._ff(a, b, c, d, k[8], 7, 1770035416);
		d = CryptUtil._ff(d, a, b, c, k[9], 12, -1958414417);
		c = CryptUtil._ff(c, d, a, b, k[10], 17, -42063);
		b = CryptUtil._ff(b, c, d, a, k[11], 22, -1990404162);
		a = CryptUtil._ff(a, b, c, d, k[12], 7, 1804603682);
		d = CryptUtil._ff(d, a, b, c, k[13], 12, -40341101);
		c = CryptUtil._ff(c, d, a, b, k[14], 17, -1502002290);
		b = CryptUtil._ff(b, c, d, a, k[15], 22, 1236535329);

		a = CryptUtil._gg(a, b, c, d, k[1], 5, -165796510);
		d = CryptUtil._gg(d, a, b, c, k[6], 9, -1069501632);
		c = CryptUtil._gg(c, d, a, b, k[11], 14, 643717713);
		b = CryptUtil._gg(b, c, d, a, k[0], 20, -373897302);
		a = CryptUtil._gg(a, b, c, d, k[5], 5, -701558691);
		d = CryptUtil._gg(d, a, b, c, k[10], 9, 38016083);
		c = CryptUtil._gg(c, d, a, b, k[15], 14, -660478335);
		b = CryptUtil._gg(b, c, d, a, k[4], 20, -405537848);
		a = CryptUtil._gg(a, b, c, d, k[9], 5, 568446438);
		d = CryptUtil._gg(d, a, b, c, k[14], 9, -1019803690);
		c = CryptUtil._gg(c, d, a, b, k[3], 14, -187363961);
		b = CryptUtil._gg(b, c, d, a, k[8], 20, 1163531501);
		a = CryptUtil._gg(a, b, c, d, k[13], 5, -1444681467);
		d = CryptUtil._gg(d, a, b, c, k[2], 9, -51403784);
		c = CryptUtil._gg(c, d, a, b, k[7], 14, 1735328473);
		b = CryptUtil._gg(b, c, d, a, k[12], 20, -1926607734);

		a = CryptUtil._hh(a, b, c, d, k[5], 4, -378558);
		d = CryptUtil._hh(d, a, b, c, k[8], 11, -2022574463);
		c = CryptUtil._hh(c, d, a, b, k[11], 16, 1839030562);
		b = CryptUtil._hh(b, c, d, a, k[14], 23, -35309556);
		a = CryptUtil._hh(a, b, c, d, k[1], 4, -1530992060);
		d = CryptUtil._hh(d, a, b, c, k[4], 11, 1272893353);
		c = CryptUtil._hh(c, d, a, b, k[7], 16, -155497632);
		b = CryptUtil._hh(b, c, d, a, k[10], 23, -1094730640);
		a = CryptUtil._hh(a, b, c, d, k[13], 4, 681279174);
		d = CryptUtil._hh(d, a, b, c, k[0], 11, -358537222);
		c = CryptUtil._hh(c, d, a, b, k[3], 16, -722521979);
		b = CryptUtil._hh(b, c, d, a, k[6], 23, 76029189);
		a = CryptUtil._hh(a, b, c, d, k[9], 4, -640364487);
		d = CryptUtil._hh(d, a, b, c, k[12], 11, -421815835);
		c = CryptUtil._hh(c, d, a, b, k[15], 16, 530742520);
		b = CryptUtil._hh(b, c, d, a, k[2], 23, -995338651);

		a = CryptUtil._ii(a, b, c, d, k[0], 6, -198630844);
		d = CryptUtil._ii(d, a, b, c, k[7], 10, 1126891415);
		c = CryptUtil._ii(c, d, a, b, k[14], 15, -1416354905);
		b = CryptUtil._ii(b, c, d, a, k[5], 21, -57434055);
		a = CryptUtil._ii(a, b, c, d, k[12], 6, 1700485571);
		d = CryptUtil._ii(d, a, b, c, k[3], 10, -1894986606);
		c = CryptUtil._ii(c, d, a, b, k[10], 15, -1051523);
		b = CryptUtil._ii(b, c, d, a, k[1], 21, -2054922799);
		a = CryptUtil._ii(a, b, c, d, k[8], 6, 1873313359);
		d = CryptUtil._ii(d, a, b, c, k[15], 10, -30611744);
		c = CryptUtil._ii(c, d, a, b, k[6], 15, -1560198380);
		b = CryptUtil._ii(b, c, d, a, k[13], 21, 1309151649);
		a = CryptUtil._ii(a, b, c, d, k[4], 6, -145523070);
		d = CryptUtil._ii(d, a, b, c, k[11], 10, -1120210379);
		c = CryptUtil._ii(c, d, a, b, k[2], 15, 718787259);
		b = CryptUtil._ii(b, c, d, a, k[9], 21, -343485551);

		x[0] = CryptUtil._add32(a, x[0]);
		x[1] = CryptUtil._add32(b, x[1]);
		x[2] = CryptUtil._add32(c, x[2]);
		x[3] = CryptUtil._add32(d, x[3]);
	},

	_cmn: (q, a, b, x, s, t) => {
		a = CryptUtil._add32(CryptUtil._add32(a, q), CryptUtil._add32(x, t));
		return CryptUtil._add32((a << s) | (a >>> (32 - s)), b);
	},

	_ff: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn((b & c) | ((~b) & d), a, b, x, s, t);
	},

	_gg: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn((b & d) | (c & (~d)), a, b, x, s, t);
	},

	_hh: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn(b ^ c ^ d, a, b, x, s, t);
	},

	_ii: (a, b, c, d, x, s, t) => {
		return CryptUtil._cmn(c ^ (b | (~d)), a, b, x, s, t);
	},

	_md51: (s) => {
		let n = s.length;
		let state = [1732584193, -271733879, -1732584194, 271733878];
		let i;
		for (i = 64; i <= s.length; i += 64) {
			CryptUtil._md5cycle(state, CryptUtil._md5blk(s.substring(i - 64, i)));
		}
		s = s.substring(i - 64);
		let tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		for (i = 0; i < s.length; i++) tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
		tail[i >> 2] |= 0x80 << ((i % 4) << 3);
		if (i > 55) {
			CryptUtil._md5cycle(state, tail);
			for (i = 0; i < 16; i++) tail[i] = 0;
		}
		tail[14] = n * 8;
		CryptUtil._md5cycle(state, tail);
		return state;
	},

	_md5blk: (s) => {
		let md5blks = [];
		for (let i = 0; i < 64; i += 4) {
			md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
		}
		return md5blks;
	},

	_hex_chr: "0123456789abcdef".split(""),

	_rhex: (n) => {
		let s = "";
		for (let j = 0; j < 4; j++) {
			s += CryptUtil._hex_chr[(n >> (j * 8 + 4)) & 0x0F] + CryptUtil._hex_chr[(n >> (j * 8)) & 0x0F];
		}
		return s;
	},

	_add32: (a, b) => {
		return (a + b) & 0xFFFFFFFF;
	},
	// endregion

	hex: (x) => {
		for (let i = 0; i < x.length; i++) {
			x[i] = CryptUtil._rhex(x[i]);
		}
		return x.join("");
	},

	hex2Dec (hex) {
		return parseInt(`0x${hex}`);
	},

	md5: (s) => {
		return CryptUtil.hex(CryptUtil._md51(s));
	},

	/**
	 * Based on Java's implementation.
	 * @param obj An object to hash.
	 * @return {*} An integer hashcode for the object.
	 */
	hashCode (obj) {
		if (typeof obj === "string") {
			if (!obj) return 0;
			let h = 0;
			for (let i = 0; i < obj.length; ++i) h = 31 * h + obj.charCodeAt(i);
			return h;
		} else if (typeof obj === "number") return obj;
		else throw new Error(`No hashCode implementation for ${obj}`);
	},

	uid () { // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
		if (RollerUtil.isCrypto()) {
			return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
		} else {
			let d = Date.now();
			if (typeof performance !== "undefined" && typeof performance.now === "function") {
				d += performance.now();
			}
			return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
				const r = (d + Math.random() * 16) % 16 | 0;
				d = Math.floor(d / 16);
				return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
			});
		}
	},
};

// COLLECTIONS =========================================================================================================
CollectionUtil = {
	ObjectSet: class ObjectSet {
		constructor () {
			this.map = new Map();
			this[Symbol.iterator] = this.values;
		}
		// Each inserted element has to implement _toIdString() method that returns a string ID.
		// Two objects are considered equal if their string IDs are equal.
		add (item) {
			this.map.set(item._toIdString(), item);
		}

		values () {
			return this.map.values();
		}
	},

	setEq (a, b) {
		if (a.size !== b.size) return false;
		for (const it of a) if (!b.has(it)) return false;
		return true;
	},

	setDiff (set1, set2) {
		return new Set([...set1].filter(it => !set2.has(it)));
	},

	deepEquals (a, b) {
		if (CollectionUtil._eq_sameValueZeroEqual(a, b)) return true;
		if (a && b && typeof a === "object" && typeof b === "object") {
			if (CollectionUtil._eq_isPlainObject(a) && CollectionUtil._eq_isPlainObject(b)) return CollectionUtil._eq_areObjectsEqual(a, b);
			const arrayA = Array.isArray(a);
			const arrayB = Array.isArray(b);
			if (arrayA || arrayB) return arrayA === arrayB && CollectionUtil._eq_areArraysEqual(a, b);
			const setA = a instanceof Set;
			const setB = b instanceof Set;
			if (setA || setB) return setA === setB && CollectionUtil.setEq(a, b);
			return CollectionUtil._eq_areObjectsEqual(a, b);
		}
		return false;
	},

	// This handles the NaN != NaN case; ignore linter complaints
	// eslint-disable-next-line no-self-compare
	_eq_sameValueZeroEqual: (a, b) => a === b || (a !== a && b !== b),
	_eq_isPlainObject: (value) => value.constructor === Object || value.constructor == null,
	_eq_areObjectsEqual (a, b) {
		const keysA = Object.keys(a);
		const {length} = keysA;
		if (Object.keys(b).length !== length) return false;
		for (let i = 0; i < length; i++) {
			if (!b.hasOwnProperty(keysA[i])) return false;
			if (!CollectionUtil.deepEquals(a[keysA[i]], b[keysA[i]])) return false;
		}
		return true;
	},
	_eq_areArraysEqual (a, b) {
		const {length} = a;
		if (b.length !== length) return false;
		for (let i = 0; i < length; i++) if (!CollectionUtil.deepEquals(a[i], b[i])) return false;
		return true;
	},

	// region Find first <X>
	dfs (obj, prop) {
		if (obj instanceof Array) {
			for (const child of obj) {
				const n = CollectionUtil.dfs(child, prop);
				if (n) return n;
			}
			return;
		}

		if (obj instanceof Object) {
			if (obj[prop]) return obj[prop];

			for (const child of Object.values(obj)) {
				const n = CollectionUtil.dfs(child, prop);
				if (n) return n;
			}
		}
	},

	bfs (obj, prop) {
		if (obj instanceof Array) {
			for (const child of obj) {
				if (!(child instanceof Array) && child instanceof Object && child[prop]) return child[prop];
			}

			for (const child of obj) {
				const n = CollectionUtil.bfs(child, prop);
				if (n) return n;
			}

			return;
		}

		if (obj instanceof Object) {
			if (obj[prop]) return obj[prop];

			return CollectionUtil.bfs(Object.values(obj));
		}
	},
	// endregion
};

Array.prototype.last || Object.defineProperty(Array.prototype, "last", {
	enumerable: false,
	writable: true,
	value: function (arg) {
		if (arg !== undefined) this[this.length - 1] = arg;
		else return this[this.length - 1];
	},
});

Array.prototype.filterIndex || Object.defineProperty(Array.prototype, "filterIndex", {
	enumerable: false,
	writable: true,
	value: function (fnCheck) {
		const out = [];
		this.forEach((it, i) => {
			if (fnCheck(it)) out.push(i);
		});
		return out;
	},
});

Array.prototype.equals || Object.defineProperty(Array.prototype, "equals", {
	enumerable: false,
	writable: true,
	value: function (array2) {
		const array1 = this;
		if (!array1 && !array2) return true;
		else if ((!array1 && array2) || (array1 && !array2)) return false;

		let temp = [];
		if ((!array1[0]) || (!array2[0])) return false;
		if (array1.length !== array2.length) return false;
		let key;
		// Put all the elements from array1 into a "tagged" array
		for (let i = 0; i < array1.length; i++) {
			key = `${(typeof array1[i])}~${array1[i]}`; // Use "typeof" so a number 1 isn't equal to a string "1".
			if (temp[key]) temp[key]++;
			else temp[key] = 1;
		}
		// Go through array2 - if same tag missing in "tagged" array, not equal
		for (let i = 0; i < array2.length; i++) {
			key = `${(typeof array2[i])}~${array2[i]}`;
			if (temp[key]) {
				if (temp[key] === 0) return false;
				else temp[key]--;
			} else return false;
		}
		return true;
	},
});

// Alternate name due to clash with Foundry VTT
Array.prototype.segregate || Object.defineProperty(Array.prototype, "segregate", {
	enumerable: false,
	writable: true,
	value: function (fnIsValid) {
		return this.reduce(([pass, fail], elem) => fnIsValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []]);
	},
});

Array.prototype.partition || Object.defineProperty(Array.prototype, "partition", {
	enumerable: false,
	writable: true,
	value: Array.prototype.segregate,
});

Array.prototype.getNext || Object.defineProperty(Array.prototype, "getNext", {
	enumerable: false,
	writable: true,
	value: function (curVal) {
		let ix = this.indexOf(curVal);
		if (!~ix) throw new Error("Value was not in array!");
		if (++ix >= this.length) ix = 0;
		return this[ix];
	},
});

Array.prototype.shuffle || Object.defineProperty(Array.prototype, "shuffle", {
	enumerable: false,
	writable: true,
	value: function () {
		for (let i = 0; i < 10000; ++i) this.sort(() => Math.random() - 0.5);
		return this;
	},
});

/** Map each array item to a k:v pair, then flatten them into one object. */
Array.prototype.mergeMap || Object.defineProperty(Array.prototype, "mergeMap", {
	enumerable: false,
	writable: true,
	value: function (fnMap) {
		return this.map((...args) => fnMap(...args)).reduce((a, b) => Object.assign(a, b), {});
	},
});

Array.prototype.first || Object.defineProperty(Array.prototype, "first", {
	enumerable: false,
	writable: true,
	value: function (fnMapFind) {
		for (let i = 0, len = this.length; i < len; ++i) {
			const result = fnMapFind(this[i], i, this);
			if (result) return result;
		}
	},
});

Array.prototype.pMap || Object.defineProperty(Array.prototype, "pMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		return Promise.all(this.map((it, i) => fnMap(it, i, this)));
	},
});

/** Map each item via an async function, awaiting for each to complete before starting the next. */
Array.prototype.pSerialAwaitMap || Object.defineProperty(Array.prototype, "pSerialAwaitMap", {
	enumerable: false,
	writable: true,
	value: async function (fnMap) {
		const out = [];
		for (let i = 0, len = this.length; i < len; ++i) out.push(await fnMap(this[i], i, this));
		return out;
	},
});

Array.prototype.pSerialAwaitFind || Object.defineProperty(Array.prototype, "pSerialAwaitFind", {
	enumerable: false,
	writable: true,
	value: async function (fnFind) {
		for (let i = 0, len = this.length; i < len; ++i) if (await fnFind(this[i], i, this)) return this[i];
	},
});

Array.prototype.pSerialAwaitSome || Object.defineProperty(Array.prototype, "pSerialAwaitSome", {
	enumerable: false,
	writable: true,
	value: async function (fnSome) {
		for (let i = 0, len = this.length; i < len; ++i) if (await fnSome(this[i], i, this)) return true;
		return false;
	},
});

Array.prototype.unique || Object.defineProperty(Array.prototype, "unique", {
	enumerable: false,
	writable: true,
	value: function (fnGetProp) {
		const seen = new Set();
		return this.filter((...args) => {
			const val = fnGetProp ? fnGetProp(...args) : args[0];
			if (seen.has(val)) return false;
			seen.add(val);
			return true;
		});
	},
});

Array.prototype.zip || Object.defineProperty(Array.prototype, "zip", {
	enumerable: false,
	writable: true,
	value: function (otherArray) {
		const out = [];
		const len = Math.max(this.length, otherArray.length);
		for (let i = 0; i < len; ++i) {
			out.push([this[i], otherArray[i]]);
		}
		return out;
	},
});

Array.prototype.nextWrap || Object.defineProperty(Array.prototype, "nextWrap", {
	enumerable: false,
	writable: true,
	value: function (item) {
		const ix = this.indexOf(item);
		if (~ix) {
			if (ix + 1 < this.length) return this[ix + 1];
			else return this[0];
		} else return this.last();
	},
});

Array.prototype.prevWrap || Object.defineProperty(Array.prototype, "prevWrap", {
	enumerable: false,
	writable: true,
	value: function (item) {
		const ix = this.indexOf(item);
		if (~ix) {
			if (ix - 1 >= 0) return this[ix - 1];
			else return this.last();
		} else return this[0];
	},
});

Array.prototype.findLast || Object.defineProperty(Array.prototype, "findLast", {
	enumerable: false,
	writable: true,
	value: function (fn) {
		for (let i = this.length - 1; i >= 0; --i) if (fn(this[i])) return this[i];
	},
});

Array.prototype.findLastIndex || Object.defineProperty(Array.prototype, "findLastIndex", {
	enumerable: false,
	writable: true,
	value: function (fn) {
		for (let i = this.length - 1; i >= 0; --i) if (fn(this[i])) return i;
		return -1;
	},
});

Array.prototype.sum || Object.defineProperty(Array.prototype, "sum", {
	enumerable: false,
	writable: true,
	value: function () {
		let tmp = 0;
		const len = this.length;
		for (let i = 0; i < len; ++i) tmp += this[i];
		return tmp;
	},
});

Array.prototype.mean || Object.defineProperty(Array.prototype, "mean", {
	enumerable: false,
	writable: true,
	value: function () {
		return this.sum() / this.length;
	},
});

Array.prototype.meanAbsoluteDeviation || Object.defineProperty(Array.prototype, "meanAbsoluteDeviation", {
	enumerable: false,
	writable: true,
	value: function () {
		const mean = this.mean();
		return (this.map(num => Math.abs(num - mean)) || []).mean();
	},
});

// OVERLAY VIEW ========================================================================================================
/**
 * Relies on:
 * - page implementing HashUtil's `loadSubHash` with handling to show/hide the book view based on hashKey changes
 * - page running no-argument `loadSubHash` when `hashchange` occurs
 *
 * @param opts Options object.
 * @param opts.hashKey to use in the URL so that forward/back can open/close the view
 * @param opts.$openBtn jQuery-selected button to bind click open/close
 * @param opts.$eleNoneVisible "error" message to display if user has not selected any viewable content
 * @param opts.pageTitle Title.
 * @param opts.state State to modify when opening/closing.
 * @param opts.stateKey Key in state to set true/false when opening/closing.
 * @param opts.popTblGetNumShown function which should populate the view with HTML content and return the number of items displayed
 * @param [opts.hasPrintColumns] True if the overlay should contain a dropdown for adjusting print columns.
 * @param [opts.isHideContentOnNoneShown]
 * @param [opts.isHideButtonCloseNone]
 * @constructor
 */
function BookModeView (opts) {
	opts = opts || {};
	const {hashKey, $openBtn, $eleNoneVisible, pageTitle, popTblGetNumShown, isFlex, state, stateKey, isHideContentOnNoneShown, isHideButtonCloseNone} = opts;

	if (hashKey && stateKey) throw new Error();

	this.hashKey = hashKey;
	this.stateKey = stateKey;
	this.state = state;
	this.$openBtn = $openBtn;
	this.$eleNoneVisible = $eleNoneVisible;
	this.popTblGetNumShown = popTblGetNumShown;
	this.isHideContentOnNoneShown = isHideContentOnNoneShown;
	this.isHideButtonCloseNone = isHideButtonCloseNone;

	this.active = false;
	this._$body = null;
	this._$wrpBook = null;

	this._$wrpRenderedContent = null;
	this._$wrpNoneShown = null;
	this._doRenderContent = null; // N.B. currently unused, but can be used to refresh the contents of the view

	this.$openBtn.off("click").on("click", () => {
		if (this.stateKey) {
			this.state[this.stateKey] = true;
		} else {
			Hist.cleanSetHash(`${window.location.hash}${HASH_PART_SEP}${this.hashKey}${HASH_SUB_KV_SEP}true`);
		}
	});

	this.close = () => { return this._doHashTeardown(); };

	this._doHashTeardown = () => {
		if (this.stateKey) {
			this.state[this.stateKey] = false;
		} else {
			Hist.cleanSetHash(window.location.hash.replace(`${this.hashKey}${HASH_SUB_KV_SEP}true`, ""));
		}
	};

	this._renderContent = async ($wrpContent, $dispName, $wrpControlsToPass) => {
		this._$wrpRenderedContent = this._$wrpRenderedContent
			? this._$wrpRenderedContent.empty().append($wrpContent)
			: $$`<div class="bkmv__scroller h-100 overflow-y-auto ${isFlex ? "flex" : ""}">${this.isHideContentOnNoneShown ? null : $wrpContent}</div>`;
		this._$wrpRenderedContent.appendTo(this._$wrpBook);

		const numShown = await this.popTblGetNumShown($wrpContent, $dispName, $wrpControlsToPass);

		if (numShown) {
			if (this.isHideContentOnNoneShown) this._$wrpRenderedContent.append($wrpContent);
			if (this._$wrpNoneShown) {
				this._$wrpNoneShown.detach();
			}
		} else {
			if (this.isHideContentOnNoneShown) $wrpContent.detach();
			if (!this._$wrpNoneShown) {
				const $btnClose = $(`<button class="btn btn-default">Close</button>`)
					.click(() => this.close());

				this._$wrpNoneShown = $$`<div class="w-100 flex-col flex-h-center no-shrink bkmv__footer mb-3">
					<div class="mb-2 flex-vh-center min-h-0">${this.$eleNoneVisible}</div>
					${this.isHideButtonCloseNone ? null : $$`<div class="flex-vh-center">${$btnClose}</div>`}
				</div>`;
			}
			this._$wrpNoneShown.appendTo(this.isHideContentOnNoneShown ? this._$wrpRenderedContent : this._$wrpBook);
		}
	};

	// NOTE: Avoid using `flex` css, as it doesn't play nice with printing
	this.pOpen = async () => {
		if (this.active) return;
		this.active = true;
		document.title = `${pageTitle} - 5etools`;

		this._$body = $(`body`);
		this._$wrpBook = $(`<div class="bkmv"></div>`);

		this._$body.css("overflow", "hidden");
		this._$body.addClass("bkmv-active");

		const $btnClose = $(`<span class="delete-icon glyphicon glyphicon-remove"></span>`)
			.click(() => this._doHashTeardown());
		const $dispName = $(`<div></div>`); // pass this to the content function to allow it to set a main header
		$$`<div class="bkmv__spacer-name split-v-center no-shrink">${$dispName}${$btnClose}</div>`.appendTo(this._$wrpBook);

		// region controls
		// Optionally usable "controls" section at the top of the pane
		const $wrpControls = $(`<div class="w-100 flex-col bkmv__wrp-controls"></div>`)
			.appendTo(this._$wrpBook);

		let $wrpControlsToPass = $wrpControls;
		if (opts.hasPrintColumns) {
			$wrpControls.addClass("px-2 mt-2");

			const injectPrintCss = (cols) => {
				$(`#bkmv__print-style`).remove();
				$(`<style media="print" id="bkmv__print-style">.bkmv__wrp { column-count: ${cols}; }</style>`)
					.appendTo($(document.body))
			};

			const lastColumns = StorageUtil.syncGetForPage(BookModeView._BOOK_VIEW_COLUMNS_K);

			const $selColumns = $(`<select class="form-control input-sm">
				<option value="0">Two (book style)</option>
				<option value="1">One</option>
			</select>`)
				.change(() => {
					const val = Number($selColumns.val());
					if (val === 0) injectPrintCss(2);
					else injectPrintCss(1);

					StorageUtil.syncSetForPage(BookModeView._BOOK_VIEW_COLUMNS_K, val);
				});
			if (lastColumns != null) $selColumns.val(lastColumns);
			$selColumns.change();

			$wrpControlsToPass = $$`<div class="w-100 flex">
				<div class="flex-vh-center"><div class="mr-2 no-wrap help-subtle" title="Applied when printing the page.">Print columns:</div>${$selColumns}</div>
			</div>`.appendTo($wrpControls);
		}
		// endregion

		const $wrpContent = $(`<div class="bkmv__wrp p-2"></div>`);

		await this._renderContent($wrpContent, $dispName, $wrpControlsToPass);

		this._pRenderContent = () => this._renderContent($wrpContent, $dispName, $wrpControlsToPass);

		this._$body.append(this._$wrpBook);
	};

	this.teardown = () => {
		if (this.active) {
			if (this._$wrpRenderedContent) this._$wrpRenderedContent.detach();
			if (this._$wrpNoneShown) this._$wrpNoneShown.detach();

			this._$body.css("overflow", "");
			this._$body.removeClass("bkmv-active");
			this._$wrpBook.remove();
			this.active = false;

			this._pRenderContent = null;
		}
	};

	this.pHandleSub = (sub) => {
		if (this.stateKey) return; // Assume anything with state will handle this itself.

		const bookViewHash = sub.find(it => it.startsWith(this.hashKey));
		if (bookViewHash && UrlUtil.unpackSubHash(bookViewHash)[this.hashKey][0] === "true") return this.pOpen();
		else this.teardown();
	};
}
BookModeView._BOOK_VIEW_COLUMNS_K = "bookViewColumns";

// CONTENT EXCLUSION ===================================================================================================
ExcludeUtil = {
	isInitialised: false,
	_excludes: null,

	async pInitialise () {
		ExcludeUtil.pSave = MiscUtil.throttle(ExcludeUtil._pSave, 50);
		try {
			ExcludeUtil._excludes = await StorageUtil.pGet(VeCt.STORAGE_EXCLUDES) || [];
			ExcludeUtil._excludes = ExcludeUtil._excludes.filter(it => it.hash); // remove legacy rows
		} catch (e) {
			JqueryUtil.doToast({
				content: "Error when loading content blacklist! Purged blacklist data. (See the log for more information.)",
				type: "danger",
			});
			try {
				await StorageUtil.pRemove(VeCt.STORAGE_EXCLUDES);
			} catch (e) {
				setTimeout(() => { throw e });
			}
			ExcludeUtil._excludes = null;
			window.location.hash = "";
			setTimeout(() => { throw e });
		}
		ExcludeUtil.isInitialised = true;
	},

	getList () {
		return ExcludeUtil._excludes || [];
	},

	async pSetList (toSet) {
		ExcludeUtil._excludes = toSet;
		await ExcludeUtil.pSave();
	},

	_excludeCount: 0,
	/**
	 * @param hash
	 * @param category
	 * @param source
	 * @param [opts]
	 * @param [opts.isNoCount]
	 */
	isExcluded (hash, category, source, opts) {
		if (!ExcludeUtil._excludes || !ExcludeUtil._excludes.length) return false;
		if (!source) throw new Error(`Entity had no source!`);
		opts = opts || {};

		source = source.source || source;
		const out = !!ExcludeUtil._excludes.find(row => (row.source === "*" || row.source === source) && (row.category === "*" || row.category === category) && (row.hash === "*" || row.hash === hash));
		if (out && !opts.isNoCount) ++ExcludeUtil._excludeCount;
		return out;
	},

	isAllContentExcluded (list) { return (!list.length && ExcludeUtil._excludeCount) || (list.length > 0 && list.length === ExcludeUtil._excludeCount); },
	getAllContentBlacklistedHtml () { return `<div class="initial-message">(All content <a href="blacklist.html">blacklisted</a>)</div>`; },

	addExclude (displayName, hash, category, source) {
		if (!ExcludeUtil._excludes.find(row => row.source === source && row.category === category && row.hash === hash)) {
			ExcludeUtil._excludes.push({displayName, hash, category, source});
			ExcludeUtil.pSave();
			return true;
		}
		return false;
	},

	removeExclude (hash, category, source) {
		const ix = ExcludeUtil._excludes.findIndex(row => row.source === source && row.category === category && row.hash === hash);
		if (~ix) {
			ExcludeUtil._excludes.splice(ix, 1);
			ExcludeUtil.pSave();
		}
	},

	async _pSave () {
		return StorageUtil.pSet(VeCt.STORAGE_EXCLUDES, ExcludeUtil._excludes);
	},

	// The throttled version, available post-initialisation
	async pSave () { /* no-op */ },

	resetExcludes () {
		ExcludeUtil._excludes = [];
		ExcludeUtil.pSave();
	},
};

// ENCOUNTERS ==========================================================================================================
EncounterUtil = {
	async pGetInitialState () {
		if (await EncounterUtil._pHasSavedStateLocal()) {
			if (await EncounterUtil._hasSavedStateUrl()) {
				return {
					type: "url",
					data: EncounterUtil._getSavedStateUrl(),
				};
			} else {
				return {
					type: "local",
					data: await EncounterUtil._pGetSavedStateLocal(),
				};
			}
		} else return null;
	},

	_hasSavedStateUrl () {
		return window.location.hash.length && Hist.getSubHash(EncounterUtil.SUB_HASH_PREFIX) != null;
	},

	_getSavedStateUrl () {
		let out = null;
		try {
			out = JSON.parse(decodeURIComponent(Hist.getSubHash(EncounterUtil.SUB_HASH_PREFIX)));
		} catch (e) {
			setTimeout(() => {
				throw e;
			});
		}
		Hist.setSubhash(EncounterUtil.SUB_HASH_PREFIX, null);
		return out;
	},

	async _pHasSavedStateLocal () {
		return !!StorageUtil.pGet(VeCt.STORAGE_ENCOUNTER);
	},

	async _pGetSavedStateLocal () {
		try {
			return await StorageUtil.pGet(VeCt.STORAGE_ENCOUNTER);
		} catch (e) {
			JqueryUtil.doToast({
				content: "Error when loading encounters! Purged encounter data. (See the log for more information.)",
				type: "danger",
			});
			await StorageUtil.pRemove(VeCt.STORAGE_ENCOUNTER);
			setTimeout(() => { throw e; });
		}
	},

	async pDoSaveState (toSave) {
		StorageUtil.pSet(VeCt.STORAGE_ENCOUNTER, toSave);
	},

	async pGetSavedState () {
		const saved = await StorageUtil.pGet(EncounterUtil.SAVED_ENCOUNTER_SAVE_LOCATION);
		return saved || {};
	},

	getEncounterName (encounter) {
		if (encounter.l && encounter.l.items && encounter.l.items.length) {
			const largestCount = encounter.l.items.sort((a, b) => SortUtil.ascSort(Number(b.c), Number(a.c)))[0];
			const name = (UrlUtil.decodeHash(largestCount.h)[0] || "(Unnamed)").toTitleCase();
			return `Encounter with ${name} ×${largestCount.c}`;
		} else return "(Unnamed Encounter)"
	},
};
EncounterUtil.SUB_HASH_PREFIX = "encounter";
EncounterUtil.SAVED_ENCOUNTER_SAVE_LOCATION = "ENCOUNTER_SAVED_STORAGE";

// EXTENSIONS ==========================================================================================================
ExtensionUtil = {
	ACTIVE: false,

	_doSend (type, data) {
		const detail = MiscUtil.copy({type, data});
		window.dispatchEvent(new CustomEvent("rivet.send", {detail}));
	},

	async pDoSendStats (evt, ele) {
		const $parent = $(ele).closest(`th.rnd-name`);
		const page = $parent.attr("data-page");
		const source = $parent.attr("data-source");
		const hash = $parent.attr("data-hash");
		const rawExtensionData = $parent.attr("data-extension");
		const extensionData = rawExtensionData ? JSON.parse(rawExtensionData) : null;

		if (page && source && hash) {
			let toSend = await Renderer.hover.pCacheAndGet(page, source, hash);

			if (extensionData) {
				switch (page) {
					case UrlUtil.PG_BESTIARY: {
						if (extensionData._scaledCr) toSend = await ScaleCreature.scale(toSend, extensionData._scaledCr);
						else if (extensionData._scaledSpellSummonLevel) toSend = await ScaleSpellSummonedCreature.scale(toSend, extensionData._scaledSpellSummonLevel);
						else if (extensionData._scaledClassSummonLevel) toSend = await ScaleClassSummonedCreature.scale(toSend, extensionData._scaledClassSummonLevel);
					}
				}
			}

			ExtensionUtil._doSend("entity", {page, entity: toSend, isTemp: !!evt.shiftKey});
		}
	},

	pDoSendStatsPreloaded ({page, entity, isTemp, options}) {
		ExtensionUtil._doSend("entity", {page, entity, isTemp, options});
	},

	pDoSendCurrency ({currency}) {
		ExtensionUtil._doSend("currency", {currency});
	},

	doSendRoll (data) { ExtensionUtil._doSend("roll", data); },

	pDoSend ({type, data}) { ExtensionUtil._doSend(type, data); },
};
if (typeof window !== "undefined") window.addEventListener("rivet.active", () => ExtensionUtil.ACTIVE = true);

// TOKENS ==============================================================================================================
TokenUtil = {
	handleStatblockScroll (event, ele) {
		$(`#token_image`)
			.toggle(ele.scrollTop < 32)
			.css({
				opacity: (32 - ele.scrollTop) / 32,
				top: -ele.scrollTop,
			})
	},
}

// LOCKS ===============================================================================================================
VeLock = function () {
	this._lockMeta = null;

	this.pLock = async () => {
		while (this._lockMeta) await this._lockMeta.lock;
		let unlock = null;
		const lock = new Promise(resolve => unlock = resolve);
		this._lockMeta = {
			lock,
			unlock,
		}
	};

	this.unlock = () => {
		const lockMeta = this._lockMeta;
		if (lockMeta) {
			this._lockMeta = null;
			lockMeta.unlock();
		}
	};
}
BrewUtil._lockHandleBrewJson = new VeLock();

// DATETIME ============================================================================================================
DatetimeUtil = {
	getDateStr (date, short) {
		const month = DatetimeUtil._MONTHS[date.getMonth()];
		return `${short ? month.substring(0, 3) : month} ${Parser.getOrdinalForm(date.getDate())}, ${date.getFullYear()}`;
	},

	getDatetimeStr ({date, isPlainText = false} = {}) {
		date = date ?? new Date();
		const monthName = DatetimeUtil._MONTHS[date.getMonth()];
		return `${date.getDate()} ${!isPlainText ? `<span title="${monthName}">` : ""}${monthName.substring(0, 3)}.${!isPlainText ? `</span>` : ""} ${date.getFullYear()}, ${DatetimeUtil._getPad2(date.getHours())}:${DatetimeUtil._getPad2(date.getMinutes())}:${DatetimeUtil._getPad2(date.getSeconds())}`;
	},

	_getPad2 (num) { return `${num}`.padStart(2, "0"); },

	getIntervalStr (millis) {
		if (millis < 0 || isNaN(millis)) return "(Unknown interval)";

		const s = number => (number !== 1) ? "s" : "";

		const stack = [];

		let numSecs = Math.floor(millis / 1000);

		const numYears = Math.floor(numSecs / DatetimeUtil._SECS_PER_YEAR);
		if (numYears) {
			stack.push(`${numYears} year${s(numYears)}`);
			numSecs = numSecs - (numYears * DatetimeUtil._SECS_PER_YEAR);
		}

		const numDays = Math.floor(numSecs / DatetimeUtil._SECS_PER_DAY);
		if (numDays) {
			stack.push(`${numDays} day${s(numDays)}`);
			numSecs = numSecs - (numDays * DatetimeUtil._SECS_PER_DAY);
		}

		const numHours = Math.floor(numSecs / DatetimeUtil._SECS_PER_HOUR);
		if (numHours) {
			stack.push(`${numHours} hour${s(numHours)}`);
			numSecs = numSecs - (numHours * DatetimeUtil._SECS_PER_HOUR);
		}

		const numMinutes = Math.floor(numSecs / DatetimeUtil._SECS_PER_MINUTE);
		if (numMinutes) {
			stack.push(`${numMinutes} minute${s(numMinutes)}`);
			numSecs = numSecs - (numMinutes * DatetimeUtil._SECS_PER_MINUTE);
		}

		if (numSecs) stack.push(`${numSecs} second${s(numSecs)}`);
		else if (!stack.length) stack.push("less than a second"); // avoid adding this if there's already info

		return stack.join(", ");
	},
}
DatetimeUtil._MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
DatetimeUtil._SECS_PER_YEAR = 31536000;
DatetimeUtil._SECS_PER_DAY = 86400;
DatetimeUtil._SECS_PER_HOUR = 3600;
DatetimeUtil._SECS_PER_MINUTE = 60;

// MISC WEBPAGE ONLOADS ================================================================================================
if (!IS_VTT && typeof window !== "undefined") {
	window.addEventListener("load", () => {
		$(document.body)
			.on("click", `[data-packed-dice]`, evt => {
				Renderer.dice.pRollerClickUseData(evt, evt.currentTarget);
			})
			.on("click", `[data-rd-data-embed-header]`, evt => {
				Renderer.events.handleClick_dataEmbedHeader(evt, evt.currentTarget);
			});
	});

	if (location.origin === VeCt.LOC_ORIGIN_CANCER) {
		const ivsCancer = [];

		window.addEventListener("load", () => {
			let isPadded = false;
			let anyFound = false;
			[
				"div-gpt-ad-5etools35927", // main banner
				"div-gpt-ad-5etools35930", // side banner
				"div-gpt-ad-5etools35928", // sidebar top
				"div-gpt-ad-5etools35929", // sidebar bottom
				"div-gpt-ad-5etools36159", // bottom floater
				"div-gpt-ad-5etools36834", // mobile middle
			].forEach(id => {
				const iv = setInterval(() => {
					const $wrp = $(`#${id}`);
					if (!$wrp.length) return;
					if (!$wrp.children().length) return;
					if ($wrp.children()[0].tagName === "SCRIPT") return;
					const $tgt = $wrp.closest(".cancer__anchor").find(".cancer__disp-cancer");
					if ($tgt.length) {
						anyFound = true;
						$tgt.css({display: "flex"}).text("Advertisements");
						clearInterval(iv);
					}
				}, 250);

				ivsCancer.push(iv);
			});

			const ivPad = setInterval(() => {
				if (!anyFound) return;
				if (isPadded) return;
				isPadded = true;
				// Pad the bottom of the page so the adhesive unit doesn't overlap the content
				$(`.view-col-group--cancer`).append(`<div class="w-100 no-shrink" style="height: 110px;"></div>`)
			}, 300);
			ivsCancer.push(ivPad);
		});

		// Hack to lock the ad space at original size--prevents the screen from shifting around once loaded
		setTimeout(() => {
			const $wrp = $(`.cancer__wrp-leaderboard-inner`);
			const h = $wrp.outerHeight();
			$wrp.css({height: h});
			ivsCancer.forEach(iv => clearInterval(iv));
		}, 5000);
	} else {
		window.addEventListener("load", () => $(`.cancer__anchor`).remove());
	}

	// window.addEventListener("load", () => {
	// 	$(`.cancer__sidebar-rhs-inner--top`).append(`<div class="TEST_RHS_TOP"></div>`)
	// 	$(`.cancer__sidebar-rhs-inner--bottom`).append(`<div class="TEST_RHS_BOTTOM"></div>`)
	// });
}

_Donate = {
	// TAG Disabled until further notice
	/*
	init () {
		if (IS_DEPLOYED) {
			DataUtil.loadJSON(`https://get.5etools.com/money.php`).then(dosh => {
				const pct = Number(dosh.donated) / Number(dosh.Goal);
				$(`#don-total`).text(`€${dosh.Goal}`);
				if (isNaN(pct)) {
					throw new Error(`Was not a number! Values were ${dosh.donated} and ${dosh.Goal}`);
				} else {
					const $bar = $(`.don__bar_inner`);
					$bar.css("width", `${Math.min(Math.ceil(100 * pct), 100)}%`).html(pct !== 0 ? `€${dosh.donated}&nbsp;` : "");
					if (pct >= 1) $bar.css("background-color", "lightgreen");
				}
			}).catch(noDosh => {
				$(`#don-wrapper`).remove();
				throw noDosh;
			});
		}
	},

	async pNotDonating () {
		const isFake = await StorageUtil.pIsAsyncFake();
		const isNotDonating = await StorageUtil.pGet("notDonating");
		return isFake || isNotDonating;
	},
	*/

	// region Test code, please ignore
	cycleLeader (ele) {
		const modes = [{width: 970, height: 90}, {width: 970, height: 250}, {width: 320, height: 50}, {width: 728, height: 90}];
		_Donate._cycleMode(ele, modes);
	},

	cycleSide (ele) {
		const modes = [{width: 300, height: 250}, {width: 300, height: 600}];
		_Donate._cycleMode(ele, modes);
	},

	_cycleMode (ele, modes) {
		const $e = $(ele);
		const pos = $e.data("pos") || 0;
		const mode = modes[pos];
		$e.css(mode);
		$e.text(`${mode.width}*${mode.height}`);
		$e.data("pos", (pos + 1) % modes.length)
	},
	// endregion
};

}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_5 () {
"use strict";

class Prx {
	static addHook (prop, hook) {
		this.px._hooks[prop] = this.px._hooks[prop] || [];
		this.px._hooks[prop].push(hook);
	}

	static addHookAll (hook) {
		this.px._hooksAll.push(hook);
	}

	static toString () {
		return JSON.stringify(this, (k, v) => k === "px" ? undefined : v);
	}

	static copy () {
		return JSON.parse(Prx.toString.bind(this)());
	}

	static get (toProxy) {
		toProxy.px = {
			addHook: Prx.addHook.bind(toProxy),
			addHookAll: Prx.addHookAll.bind(toProxy),
			toString: Prx.toString.bind(toProxy),
			copy: Prx.copy.bind(toProxy),
			_hooksAll: [],
			_hooks: {},
		};

		return new Proxy(toProxy, {
			set: (object, prop, value) => {
				object[prop] = value;
				toProxy.px._hooksAll.forEach(hook => hook(prop, value));
				if (toProxy.px._hooks[prop]) toProxy.px._hooks[prop].forEach(hook => hook(prop, value));
				return true;
			},
			deleteProperty: (object, prop) => {
				delete object[prop];
				toProxy.px._hooksAll.forEach(hook => hook(prop, null));
				if (toProxy.px._hooks[prop]) toProxy.px._hooks[prop].forEach(hook => hook(prop, null));
				return true;
			},
		});
	}
}

class ProxyBase {
	constructor () {
		this.__hooks = {};
		this.__hooksAll = {};
		this.__hooksTmp = null;
		this.__hooksAllTmp = null;
	}

	_getProxy (hookProp, toProxy) {
		return new Proxy(toProxy, {
			set: (object, prop, value) => {
				return this._doProxySet(hookProp, object, prop, value);
			},
			deleteProperty: (object, prop) => {
				if (!(prop in object)) return true;
				const prevValue = object[prop];
				delete object[prop];
				this._doFireHooksAll(hookProp, prop, undefined, prevValue);
				if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) this.__hooks[hookProp][prop].forEach(hook => hook(prop, undefined, prevValue));
				return true;
			},
		});
	}

	_doProxySet (hookProp, object, prop, value) {
		if (object[prop] === value) return true;
		const prevValue = object[prop];
		object[prop] = value;
		this._doFireHooksAll(hookProp, prop, value, prevValue);
		if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) this.__hooks[hookProp][prop].forEach(hook => hook(prop, value, prevValue));
		return true;
	}

	/** As per `_doProxySet`, but the hooks are run strictly in serial. */
	async _pDoProxySet (hookProp, object, prop, value) {
		if (object[prop] === value) return true;
		const prevValue = object[prop];
		object[prop] = value;
		if (this.__hooksAll[hookProp]) for (const hook of this.__hooksAll[hookProp]) await hook(prop, value, prevValue);
		if (this.__hooks[hookProp] && this.__hooks[hookProp][prop]) for (const hook of this.__hooks[hookProp][prop]) await hook(prop, value, prevValue);
		return true;
	}

	_doFireHooksAll (hookProp, prop, value, prevValue) {
		if (this.__hooksAll[hookProp]) this.__hooksAll[hookProp].forEach(hook => hook(prop, undefined, prevValue));
	}

	// ...Not to be confused with...

	_doFireAllHooks (hookProp) {
		if (this.__hooks[hookProp]) Object.entries(this.__hooks[hookProp]).forEach(([prop, hk]) => hk(prop));
	}

	/**
	 * Register a hook versus a root property on the state object. **INTERNAL CHANGES TO CHILD OBJECTS ON THE STATE
	 *   OBJECT ARE NOT TRACKED**.
	 * @param hookProp The state object.
	 * @param prop The root property to track.
	 * @param hook The hook to run. Will be called with two arguments; the property and the value of the property being
	 *   modified.
	 */
	_addHook (hookProp, prop, hook) {
		ProxyBase._addHook_to(this.__hooks, hookProp, prop, hook);
		if (this.__hooksTmp) ProxyBase._addHook_to(this.__hooksTmp, hookProp, prop, hook);
	}

	static _addHook_to (obj, hookProp, prop, hook) {
		((obj[hookProp] = obj[hookProp] || {})[prop] = (obj[hookProp][prop] || [])).push(hook);
	}

	_addHookAll (hookProp, hook) {
		ProxyBase._addHookAll_to(this.__hooksAll, hookProp, hook);
		if (this.__hooksAllTmp) ProxyBase._addHookAll_to(this.__hooksAllTmp, hookProp, hook)
	}

	static _addHookAll_to (obj, hookProp, hook) {
		(obj[hookProp] = obj[hookProp] || []).push(hook);
	}

	_removeHook (hookProp, prop, hook) {
		ProxyBase._removeHook_from(this.__hooks, hookProp, prop, hook);
		if (this.__hooksTmp) ProxyBase._removeHook_from(this.__hooksTmp, hookProp, prop, hook);
	}

	static _removeHook_from (obj, hookProp, prop, hook) {
		if (obj[hookProp] && obj[hookProp][prop]) {
			const ix = obj[hookProp][prop].findIndex(hk => hk === hook);
			if (~ix) obj[hookProp][prop].splice(ix, 1);
		}
	}

	_removeHooks (hookProp, prop) {
		if (this.__hooks[hookProp]) delete this.__hooks[hookProp][prop];
		if (this.__hooksTmp && this.__hooksTmp[hookProp]) delete this.__hooksTmp[hookProp][prop];
	}

	_removeHookAll (hookProp, hook) {
		ProxyBase._removeHookAll_from(this.__hooksAll, hookProp, hook);
		if (this.__hooksAllTmp) ProxyBase._removeHook_from(this.__hooksAllTmp, hookProp, hook);
	}

	static _removeHookAll_from (obj, hookProp, hook) {
		if (obj[hookProp]) {
			const ix = obj[hookProp].findIndex(hk => hk === hook);
			if (~ix) obj[hookProp].splice(ix, 1);
		}
	}

	_resetHooks (hookProp) {
		if (hookProp !== undefined) delete this.__hooks[hookProp];
		else Object.keys(this.__hooks).forEach(prop => delete this.__hooks[prop]);
	}

	_resetHooksAll (hookProp) {
		if (hookProp !== undefined) delete this.__hooksAll[hookProp];
		else Object.keys(this.__hooksAll).forEach(prop => delete this.__hooksAll[prop]);
	}

	_saveHookCopiesTo (obj) { this.__hooksTmp = obj; }
	_saveHookAllCopiesTo (obj) { this.__hooksAllTmp = obj; }

	/**
	 * Object.assign equivalent, overwrites values on the current proxied object with some new values,
	 *   then trigger all the appropriate event handlers.
	 * @param hookProp Hook property, e.g. "state".
	 * @param proxyProp Proxied object property, e.g. "_state".
	 * @param underProp Underlying object property, e.g. "__state".
	 * @param toObj
	 * @param isOverwrite If the overwrite should clean/delete all data from the object beforehand.
	 */
	_proxyAssign (hookProp, proxyProp, underProp, toObj, isOverwrite) {
		const oldKeys = Object.keys(this[proxyProp]);
		const nuKeys = new Set(Object.keys(toObj));
		const dirtyKeyValues = {};

		if (isOverwrite) {
			oldKeys.forEach(k => {
				if (!nuKeys.has(k) && this[underProp] !== undefined) {
					const prevValue = this[proxyProp][k];
					delete this[underProp][k];
					dirtyKeyValues[k] = prevValue;
				}
			});
		}

		nuKeys.forEach(k => {
			if (!CollectionUtil.deepEquals(this[underProp][k], toObj[k])) {
				const prevValue = this[proxyProp][k];
				this[underProp][k] = toObj[k];
				dirtyKeyValues[k] = prevValue;
			}
		});

		Object.entries(dirtyKeyValues)
			.forEach(([k, prevValue]) => {
				this._doFireHooksAll(hookProp, k, this[underProp][k], prevValue);
				if (this.__hooks[hookProp] && this.__hooks[hookProp][k]) this.__hooks[hookProp][k].forEach(hk => hk(k, this[underProp][k], prevValue));
			});
	}

	_proxyAssignSimple (hookProp, toObj, isOverwrite) {
		return this._proxyAssign(hookProp, `_${hookProp}`, `__${hookProp}`, toObj, isOverwrite);
	}
}

class UiUtil {
	/**
	 * @param string String to parse.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 */
	static strToInt (string, fallbackEmpty = 0, opts) { return UiUtil._strToNumber(string, fallbackEmpty, opts, true) }

	/**
	 * @param string String to parse.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 */
	static strToNumber (string, fallbackEmpty = 0, opts) { return UiUtil._strToNumber(string, fallbackEmpty, opts, false) }

	static _strToNumber (string, fallbackEmpty = 0, opts, isInt) {
		opts = opts || {};
		let out;
		string = string.trim();
		if (!string) out = fallbackEmpty;
		else {
			const num = UiUtil._parseStrAsNumber(string, isInt);
			out = isNaN(num) || !isFinite(num)
				? opts.fallbackOnNaN !== undefined ? opts.fallbackOnNaN : 0
				: num;
		}
		if (opts.max != null) out = Math.min(out, opts.max);
		if (opts.min != null) out = Math.max(out, opts.min);
		return out;
	}

	/**
	 * @param string String to parse.
	 * @param [fallbackEmpty] Fallback value if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.fallbackOnNaB] Return value if not a boolean.
	 */
	static strToBool (string, fallbackEmpty = null, opts) {
		opts = opts || {};
		if (!string) return fallbackEmpty;
		string = string.trim().toLowerCase();
		if (!string) return fallbackEmpty;
		return string === "true" ? true : string === "false" ? false : opts.fallbackOnNaB;
	}

	static intToBonus (int) { return `${int >= 0 ? "+" : int < 0 ? "\u2012" : ""}${Math.abs(int)}`; }

	static getEntriesAsText (entryArray) {
		if (!entryArray || !entryArray.length) return "";
		const lines = JSON.stringify(entryArray, null, 2)
			.replace(/^\s*\[/, "").replace(/]\s*$/, "")
			.split("\n")
			.filter(it => it.trim())
			.map(it => {
				const trim = it.replace(/^\s\s/, "");
				const mQuotes = /^"(.*?)",?$/.exec(trim);
				if (mQuotes) return mQuotes[1]; // if string, strip quotes
				else return `  ${trim}`; // if object, indent
			});

		let out = "";
		const len = lines.length;
		for (let i = 0; i < len; ++i) {
			out += lines[i];

			if (i < len - 1) {
				out += "\n";
				if (!lines[i].startsWith("  ")) out += "\n";
			}
		}
		return out;
	}

	static getTextAsEntries (text) {
		try {
			const lines = [];
			text.split("\n").filter(it => it.trim()).forEach(it => {
				if (/^\s/.exec(it)) lines.push(it); // keep indented lines as-is
				else lines.push(`"${it.replace(/"/g, `\\"`)}",`); // wrap strings
			});
			if (lines.length) lines[lines.length - 1] = lines.last().replace(/^(.*?),?$/, "$1"); // remove trailing comma
			return JSON.parse(`[${lines.join("")}]`);
		} catch (e) {
			const lines = text.split("\n").filter(it => it.trim());
			const slice = lines.join(" \\ ").substring(0, 30);
			JqueryUtil.doToast({
				content: `Could not parse entries! Error was: ${e.message}<br>Text was: ${slice}${slice.length === 30 ? "..." : ""}`,
				type: "danger",
			});
			return lines;
		}
	}

	/**
	 * @param {Object} [opts] Options object.
	 * @param {string} [opts.title] Modal title.
	 *
	 * @param {string} [opts.title] Modal title.
	 *
	 * @param [opts.isUncappedHeight] {boolean}
	 * @param [opts.isUncappedWidth] {boolean}
	 * @param [opts.isHeight100] {boolean}
	 * @param [opts.isWidth100] {boolean}
	 * @param [opts.isMinHeight0] {boolean}
	 * @param [opts.isMaxWidth640p] {boolean}
	 * @param [opts.isFullscreenModal] {boolean} An alternate mode.
	 * @param [opts.isHeaderBorder] {boolean}
	 *
	 * @param {function} [opts.cbClose] Callback run when the modal is closed.
	 * @param {JQuery} [opts.$titleSplit] Element to have split alongside the title.
	 * @param {int} [opts.zIndex] Z-index of the modal.
	 * @param {number} [opts.overlayColor] Overlay color.
	 * @param {boolean} [opts.isPermanent] If the modal should be impossible to close.
	 * @param {boolean} [opts.isIndestructible] If the modal elements should be detached, not removed.
	 * @param {boolean} [opts.isClosed] If the modal should start off closed.
	 * @param {boolean} [opts.isEmpty] If the modal should contain no content.
	 * @param {boolean} [opts.hasFooter] If the modal has a footer.
	 * @returns {object}
	 */
	static getShowModal (opts) {
		opts = opts || {};

		UiUtil._initModalEscapeHandler();
		UiUtil._initModalMouseupHandlers();
		if (document.activeElement) document.activeElement.blur(); // blur any active element as it will be behind the modal

		// if the user closed the modal by clicking the "cancel" background, isDataEntered is false
		const pHandleCloseClick = async (isDataEntered, ...args) => {
			if (opts.cbClose) await opts.cbClose(isDataEntered, ...args);

			if (opts.isIndestructible) wrpOverlay.detach();
			else wrpOverlay.remove();

			doTeardown();
		};

		const doTeardown = () => {
			UiUtil._popFromModalStack(modalStackMeta);
			if (!UiUtil._MODAL_STACK.length) document.body.classList.remove(`ui-modal__body-active`);
		};

		const doOpen = () => {
			wrpOverlay.appendTo(document.body);
			document.body.classList.add(`ui-modal__body-active`);
		};

		const wrpOverlay = e_({tag: "div", clazz: "ui-modal__overlay"});
		if (opts.zIndex != null) wrpOverlay.style.zIndex = `${opts.zIndex}`;
		if (opts.overlayColor != null) wrpOverlay.style.backgroundColor = `${opts.overlayColor}`;

		// In "fullscreen" mode, blank out the modal background
		const overlayBlind = opts.isFullscreenModal
			? e_({
				tag: "div",
				clazz: `ui-modal__overlay-blind w-100 h-100 flex-col`,
			}).appendTo(wrpOverlay)
			: null;

		const wrpScroller = e_({
			tag: "div",
			clazz: `ui-modal__scroller flex-col`,
		});

		const modalWindowClasses = [
			opts.isWidth100 ? `w-100` : "",
			opts.isHeight100 ? "h-100" : "",
			opts.isUncappedHeight ? "ui-modal__inner--uncap-height" : "",
			opts.isUncappedWidth ? "ui-modal__inner--uncap-width" : "",
			opts.isMinHeight0 ? `ui-modal__inner--no-min-height` : "",
			opts.isMaxWidth640p ? `ui-modal__inner--max-width-640p` : "",
			opts.isFullscreenModal ? `ui-modal__inner--mode-fullscreen my-0 pt-0` : "",
			opts.hasFooter ? `pb-0` : "",
		].filter(Boolean);

		const btnCloseModal = opts.isFullscreenModal ? e_({
			tag: "button",
			clazz: `btn btn-danger btn-xs`,
			html: `<span class="glyphicon glyphicon-remove></span>`,
			click: pHandleCloseClick(false),
		}) : null;

		const modalFooter = opts.hasFooter
			? e_({
				tag: "div",
				clazz: `"no-shrink w-100 flex-col ui-modal__footer ${opts.isFullscreenModal ? `ui-modal__footer--fullscreen mt-1` : ""}`,
			})
			: null;

		const modal = e_({
			tag: "div",
			clazz: `ui-modal__inner flex-col ${modalWindowClasses.join(" ")}`,
			children: [
				!opts.isEmpty && opts.title
					? e_({
						tag: "div",
						clazz: `split-v-center no-shrink ${opts.isHeaderBorder ? `ui-modal__header--border` : ""} ${opts.isFullscreenModal ? `ui-modal__header--fullscreen mb-1` : ""}`,
						children: [
							opts.title
								? e_({
									tag: "h4",
									clazz: `my-2`,
									html: opts.title.qq(),
								})
								: null,

							opts.$titleSplit ? opts.$titleSplit[0] : null,

							btnCloseModal,
						].filter(Boolean),
					})
					: null,

				!opts.isEmpty ? wrpScroller : null,

				modalFooter,
			].filter(Boolean),
		}).appendTo(opts.isFullscreenModal ? overlayBlind : wrpOverlay)

		wrpOverlay
			.addEventListener("mouseup", evt => {
				if (evt.target !== wrpOverlay) return;
				if (evt.target !== UiUtil._MODAL_LAST_MOUSEDOWN) return;
				if (opts.isPermanent) return;
				evt.stopPropagation();
				evt.preventDefault();
				return pHandleCloseClick(false);
			});

		if (!opts.isClosed) doOpen();

		const modalStackMeta = {
			isPermanent: opts.isPermanent,
			pHandleCloseClick,
			doTeardown,
		};
		if (!opts.isClosed) UiUtil._pushToModalStack(modalStackMeta);

		const out = {
			$modal: $(modal),
			$modalInner: $(wrpScroller),
			$modalFooter: $(modalFooter),
			doClose: pHandleCloseClick,
			doTeardown,
		};

		if (opts.isIndestructible || opts.isClosed) {
			out.doOpen = () => {
				UiUtil._pushToModalStack(modalStackMeta);
				doOpen();
			};
		}

		return out;
	}

	static _pushToModalStack (modalStackMeta) {
		if (!UiUtil._MODAL_STACK.includes(modalStackMeta)) {
			UiUtil._MODAL_STACK.push(modalStackMeta);
		}
	}

	static _popFromModalStack (modalStackMeta) {
		const ixStack = UiUtil._MODAL_STACK.indexOf(modalStackMeta);
		if (~ixStack) UiUtil._MODAL_STACK.splice(ixStack, 1);
	}

	static _initModalEscapeHandler () {
		if (UiUtil._MODAL_STACK) return;
		UiUtil._MODAL_STACK = [];

		document.addEventListener("keydown", evt => {
			if (evt.which !== 27) return;
			if (!UiUtil._MODAL_STACK.length) return;
			if (EventUtil.isInInput(evt)) return;

			const outerModalMeta = UiUtil._MODAL_STACK.last();
			if (!outerModalMeta) return;
			evt.stopPropagation();
			if (!outerModalMeta.isPermanent) return outerModalMeta.pHandleCloseClick(false);
		});
	}

	static _initModalMouseupHandlers () {
		document.addEventListener("mousedown", evt => {
			UiUtil._MODAL_LAST_MOUSEDOWN = evt.target;
		});
	}

	static addModalSep ($modalInner) {
		$modalInner.append(`<hr class="ui-modal__row-sep">`);
	}

	static $getAddModalRow ($modalInner, tag = "div") {
		return $(`<${tag} class="ui-modal__row"></${tag}>`).appendTo($modalInner);
	}

	/**
	 * @param $modalInner Element this row should be added to.
	 * @param headerText Header text.
	 * @param [opts] Options object.
	 * @param [opts.helpText] Help text (title) of select dropdown.
	 * @param [opts.$eleRhs] Element to attach to the right-hand side of the header.
	 */
	static $getAddModalRowHeader ($modalInner, headerText, opts) {
		opts = opts || {};
		const $row = UiUtil.$getAddModalRow($modalInner, "h5").addClass("bold");
		if (opts.$eleRhs) $$`<div class="split flex-v-center w-100 pr-1"><span>${headerText}</span>${opts.$eleRhs}</div>`.appendTo($row);
		else $row.text(headerText);
		if (opts.helpText) $row.title(opts.helpText);
		return $row;
	}

	static $getAddModalRowCb ($modalInner, labelText, objectWithProp, propName, helpText) {
		const $row = UiUtil.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--cb`);
		if (helpText) $row.title(helpText);
		$row.append(`<span>${labelText}</span>`);
		const $cb = $(`<input type="checkbox">`).appendTo($row)
			.keydown(evt => {
				if (evt.key === "Escape") $cb.blur();
			})
			.prop("checked", objectWithProp[propName])
			.on("change", () => objectWithProp[propName] = $cb.prop("checked"));
		return $cb;
	}

	/**
	 *
	 * @param $modalInner Element this row should be added to.
	 * @param labelText Row label.
	 * @param objectWithProp Object to mutate when changing select values.
	 * @param propName Property to set in `objectWithProp`.
	 * @param values Values to display in select dropdown.
	 * @param [opts] Options object.
	 * @param [opts.helpText] Help text (title) of select dropdown.
	 * @param [opts.fnDisplay] Function used to map values to displayable versions.
	 */
	static $getAddModalRowSel ($modalInner, labelText, objectWithProp, propName, values, opts) {
		opts = opts || {};
		const $row = UiUtil.$getAddModalRow($modalInner, "label").addClass(`ui-modal__row--sel`);
		if (opts.helpText) $row.title(opts.helpText);
		$row.append(`<span>${labelText}</span>`);
		const $sel = $(`<select class="form-control input-xs w-30">`).appendTo($row);
		values.forEach((val, i) => $(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(val) : val).appendTo($sel));
		// N.B. this doesn't support null values
		const ix = values.indexOf(objectWithProp[propName]);
		$sel.val(`${~ix ? ix : 0}`)
			.change(() => objectWithProp[propName] = values[$sel.val()]);
		return $sel;
	}

	static _parseStrAsNumber (str, isInt) {
		const wrpTree = Renderer.dice.lang.getTree3(str);
		if (!wrpTree) return NaN;
		const out = wrpTree.tree.evl({});
		if (!isNaN(out) && isInt) return Math.round(out);
		return out;
	}

	static bindTypingEnd ({$ipt, fnKeyup, fnKeypress, fnKeydown, fnClick} = {}) {
		let timerTyping;
		$ipt
			.on("keyup search paste", evt => {
				clearTimeout(timerTyping);
				timerTyping = setTimeout(() => { fnKeyup(evt); }, UiUtil.TYPE_TIMEOUT_MS);
			})
			.on("keypress", (e) => {
				if (fnKeypress) fnKeypress(e);
			})
			.on("keydown", evt => {
				if (fnKeydown) fnKeydown(evt);
				clearTimeout(timerTyping);
			})
			.on("click", () => {
				if (fnClick) fnClick();
			});
	}

	/** Brute-force select the input, in case something has delayed the rendering (e.g. a VTT application window) */
	static async pDoForceFocus (ele, {timeout = 250} = {}) {
		if (!ele) return;
		ele.focus();

		const forceFocusStart = Date.now();
		while ((Date.now() < forceFocusStart + timeout) && document.activeElement !== ele) {
			await MiscUtil.pDelay(33);
			ele.focus();
		}
	}
}
UiUtil.SEARCH_RESULTS_CAP = 75;
UiUtil.TYPE_TIMEOUT_MS = 100; // auto-search after 100ms
UiUtil._MODAL_STACK = null;
UiUtil._MODAL_LAST_MOUSEDOWN = null;

class ListUiUtil {
	/**
	 * (Public method for Plutonium use)
	 * Handle doing a checkbox-based selection toggle on a list.
	 * @param list
	 * @param item List item. Must have a "data" property with a "cbSel" (the checkbox).
	 * @param evt Click event.
	 * @param [opts] Options object.
	 * @param [opts.isNoHighlightSelection] If highlighting selected rows should be skipped.
	 * @param [opts.fnOnSelectionChange] Function to call when selection status of an item changes.
	 * @param [opts.fnGetCb] Function which gets the checkbox from a list item.
	 */
	static handleSelectClick (list, item, evt, opts) {
		opts = opts || {};
		evt.preventDefault();
		evt.stopPropagation();

		const cb = this._getCb(item, opts);
		if (cb.disabled) return true;

		if (evt && evt.shiftKey && list.__firstListSelection) {
			if (list.__lastListSelection === item) {
				// on double-tapping the end of the selection, toggle it on/off

				this.setCheckbox(item, {...opts, toVal: !cb.checked});
			} else if (list.__firstListSelection === item && list.__lastListSelection) {
				// If the item matches the last clicked, clear all checkboxes from our last selection

				const ix1 = list.visibleItems.indexOf(list.__firstListSelection);
				const ix2 = list.visibleItems.indexOf(list.__lastListSelection);

				const [ixStart, ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
				for (let i = ixStart; i <= ixEnd; ++i) {
					const it = list.visibleItems[i];
					this.setCheckbox(it, {...opts, toVal: false});
				}

				this.setCheckbox(item, opts);
			} else {
				// on a shift-click, toggle all the checkboxes to true...

				const ix1 = list.visibleItems.indexOf(list.__firstListSelection);
				const ix2 = list.visibleItems.indexOf(item);
				const ix2Prev = list.__lastListSelection ? list.visibleItems.indexOf(list.__lastListSelection) : null;

				const [ixStart, ixEnd] = [ix1, ix2].sort(SortUtil.ascSort);
				for (let i = ixStart; i <= ixEnd; ++i) {
					const it = list.visibleItems[i];
					this.setCheckbox(it, opts);
				}

				// ...except those between the last selection and this selection, set those to false
				if (ix2Prev != null) {
					if (ix2Prev > ixEnd) {
						const nxtOpts = {...opts, toVal: false};
						for (let i = ixEnd + 1; i <= ix2Prev; ++i) {
							const it = list.visibleItems[i];
							this.setCheckbox(it, nxtOpts);
						}
					} else if (ix2Prev < ixStart) {
						const nxtOpts = {...opts, toVal: false};
						for (let i = ix2Prev; i < ixStart; ++i) {
							const it = list.visibleItems[i];
							this.setCheckbox(it, nxtOpts);
						}
					}
				}
			}

			list.__lastListSelection = item;
		} else {
			// on a normal click, or if there's been no initial selection, just toggle the checkbox

			const cbMaster = this._getCb(item, opts);
			if (cbMaster) {
				cbMaster.checked = !cbMaster.checked;

				if (opts.fnOnSelectionChange) opts.fnOnSelectionChange(item, cbMaster.checked);

				if (!opts.isNoHighlightSelection) {
					if (cbMaster.checked) item.ele instanceof $ ? item.ele.addClass("list-multi-selected") : item.ele.classList.add("list-multi-selected");
					else item.ele instanceof $ ? item.ele.removeClass("list-multi-selected") : item.ele.classList.remove("list-multi-selected");
				}
			} else {
				if (!opts.isNoHighlightSelection) {
					item.ele instanceof $ ? item.ele.removeClass("list-multi-selected") : item.ele.classList.remove("list-multi-selected");
				}
			}

			list.__firstListSelection = item;
			list.__lastListSelection = null;
		}
	}

	/**
	 * Handle doing a radio-based selection toggle on a list.
	 * @param list
	 * @param item List item. Must have a "data" property with a "cbSel" (the radio input).
	 * @param evt Click event.
	 */
	static handleSelectClickRadio (list, item, evt) {
		evt.preventDefault();
		evt.stopPropagation();

		list.items.forEach(it => {
			if (it === item) {
				// Setting this to true *should* cause the browser to update the rest for us, but since list items can
				//   be filtered/hidden, the browser won't necessarily update them all. Therefore, forcibly set
				//   `checked = false` below.
				it.data.cbSel.checked = true;
				it.ele.classList.add("list-multi-selected");
			} else {
				it.data.cbSel.checked = false;
				it.ele.classList.remove("list-multi-selected");
			}
		})
	}

	static _getCb (item, opts) { return opts.fnGetCb ? opts.fnGetCb(item) : item.data.cbSel; }

	static setCheckbox (item, {fnGetCb, fnOnSelectionChange, isNoHighlightSelection, toVal = true} = {}) {
		const cbSlave = this._getCb(item, {fnGetCb, fnOnSelectionChange, isNoHighlightSelection});
		if (cbSlave) {
			cbSlave.checked = toVal;
			if (fnOnSelectionChange) fnOnSelectionChange(item, toVal);
		}

		if (isNoHighlightSelection) return;

		if (toVal) item.ele instanceof $ ? item.ele.addClass("list-multi-selected") : item.ele.classList.add("list-multi-selected");
		else item.ele instanceof $ ? item.ele.removeClass("list-multi-selected") : item.ele.classList.remove("list-multi-selected");
	}

	/**
	 * (Public method for Plutonium use)
	 */
	static bindSelectAllCheckbox ($cbAll, list) {
		$cbAll.change(() => {
			const isChecked = $cbAll.prop("checked");
			this.setCheckboxes({isChecked, list});
		});
	}

	static setCheckboxes ({isChecked, isIncludeHidden, list}) {
		(isIncludeHidden ? list.items : list.visibleItems).forEach(item => {
			if (item.data.cbSel) item.data.cbSel.checked = isChecked;

			if (isChecked) item.ele instanceof $ ? item.ele.addClass("list-multi-selected") : item.ele.classList.add("list-multi-selected");
			else item.ele instanceof $ ? item.ele.removeClass("list-multi-selected") : item.ele.classList.remove("list-multi-selected");
		});
	}

	static bindPreviewButton (page, allData, item, btnShowHidePreview) {
		btnShowHidePreview.addEventListener("click", evt => {
			const entity = allData[item.ix];

			const elePreviewWrp = this.getOrAddListItemPreviewLazy(item);

			this.handleClickBtnShowHideListPreview(evt, page, entity, btnShowHidePreview, elePreviewWrp);
		});
	}

	static handleClickBtnShowHideListPreview (evt, page, entity, btnShowHidePreview, elePreviewWrp, nxtText = null) {
		evt.stopPropagation();
		evt.preventDefault();

		nxtText = nxtText ?? btnShowHidePreview.innerHTML.trim() === this.HTML_GLYPHICON_EXPAND ? this.HTML_GLYPHICON_CONTRACT : this.HTML_GLYPHICON_EXPAND;
		const isHidden = nxtText === this.HTML_GLYPHICON_EXPAND;
		const isFluff = !!evt.shiftKey;

		elePreviewWrp.classList.toggle("ve-hidden", isHidden);
		btnShowHidePreview.innerHTML = nxtText;

		const elePreviewWrpInner = elePreviewWrp.lastElementChild;

		const isForce = (elePreviewWrp.dataset.dataType === "stats" && isFluff) || (elePreviewWrp.dataset.dataType === "fluff" && !isFluff);
		if (!isForce && elePreviewWrpInner.innerHTML) return;

		$(elePreviewWrpInner).empty().off("click").on("click", evt => { evt.stopPropagation(); });

		if (isHidden) return;

		elePreviewWrp.dataset.dataType = isFluff ? "fluff" : "stats";

		if (!evt.shiftKey) {
			Renderer.hover.$getHoverContent_stats(page, entity).appendTo(elePreviewWrpInner);
			return;
		}

		Renderer.hover.pGetHoverableFluff(page, entity.source, UrlUtil.URL_TO_HASH_BUILDER[page](entity))
			.then(fluffEntity => {
				// Avoid clobbering existing elements, as other events might have updated the preview area while we were
				//  loading the fluff.
				if (elePreviewWrpInner.innerHTML) return;

				if (!fluffEntity) return Renderer.hover.$getHoverContent_stats(page, entity).appendTo(elePreviewWrpInner);
				Renderer.hover.$getHoverContent_fluff(page, fluffEntity).appendTo(elePreviewWrpInner);
			});
	}

	static getOrAddListItemPreviewLazy (item) {
		// We lazily add the preview UI, to mitigate rendering performance issues
		let elePreviewWrp;
		if (item.ele.children.length === 1) {
			elePreviewWrp = e_({
				ag: "div",
				clazz: "ve-hidden flex",
				children: [
					e_({tag: "div", clazz: "col-0-5"}),
					e_({tag: "div", clazz: "col-11-5 ui-list__wrp-preview py-2 pr-2"}),
				],
			}).appendTo(item.ele);
		} else elePreviewWrp = item.ele.lastElementChild;
		return elePreviewWrp;
	}

	static bindPreviewAllButton ($btnAll, list) {
		$btnAll
			.click(async () => {
				const nxtHtml = $btnAll.html() === ListUiUtil.HTML_GLYPHICON_EXPAND
					? ListUiUtil.HTML_GLYPHICON_CONTRACT
					: ListUiUtil.HTML_GLYPHICON_EXPAND;

				if (nxtHtml === ListUiUtil.HTML_GLYPHICON_CONTRACT && list.visibleItems.length > 500) {
					const isSure = await InputUiUtil.pGetUserBoolean({
						title: "Are You Sure?",
						htmlDescription: `You are about to expand ${list.visibleItems.length} rows. This may seriously degrade performance.<br>Are you sure you want to continue?`,
					})
					if (!isSure) return;
				}

				$btnAll.html(nxtHtml);

				list.visibleItems.forEach(listItem => {
					if (listItem.data.btnShowHidePreview.innerHTML !== nxtHtml) listItem.data.btnShowHidePreview.click();
				});
			});
	}
}
ListUiUtil.HTML_GLYPHICON_EXPAND = `[+]`;
ListUiUtil.HTML_GLYPHICON_CONTRACT = `[\u2012]`;

class ProfUiUtil {
	/**
	 * @param state Initial state.
	 * @param [opts] Options object.
	 * @param [opts.isSimple] If the cycler only has "not proficient" and "proficient" options
	 */
	static getProfCycler (state = 0, opts) {
		opts = opts || {};

		const STATES = opts.isSimple ? Object.keys(ProfUiUtil.PROF_TO_FULL).slice(0, 2) : Object.keys(ProfUiUtil.PROF_TO_FULL);

		const NUM_STATES = Object.keys(STATES).length;

		// validate initial state
		state = Number(state) || 0;
		if (state >= NUM_STATES) state = NUM_STATES - 1;
		else if (state < 0) state = 0;

		const $btnCycle = $(`<button class="ui-prof__btn-cycle"></button>`)
			.click(() => {
				$btnCycle
					.attr("data-state", ++state >= NUM_STATES ? state = 0 : state)
					.title(ProfUiUtil.PROF_TO_FULL[state].name)
					.trigger("change");
			})
			.contextmenu(evt => {
				evt.preventDefault();
				$btnCycle
					.attr("data-state", --state < 0 ? state = NUM_STATES - 1 : state)
					.title(ProfUiUtil.PROF_TO_FULL[state].name)
					.trigger("change");
			});
		const setState = (nuState) => {
			state = nuState;
			if (state > NUM_STATES) state = 0;
			else if (state < 0) state = NUM_STATES - 1;
			$btnCycle.attr("data-state", state).title(ProfUiUtil.PROF_TO_FULL[state].name);
		};
		return {
			$ele: $btnCycle,
			setState,
			getState: () => state,
		}
	}
}
ProfUiUtil.PROF_TO_FULL = {
	"0": {
		name: "No proficiency",
		mult: 0,
	},
	"1": {
		name: "Proficiency",
		mult: 1,
	},
	"2": {
		name: "Expertise",
		mult: 2,
	},
	"3": {
		name: "Half proficiency",
		mult: 0.5,
	},
};

class TabUiUtilBase {
	static decorate (obj) {
		obj.__tabState = {};

		obj._getTabProps = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return {
				propProxy,
				_propProxy: `_${propProxy}`,
				__propProxy: `__${propProxy}`,
				propActive: `ixActiveTab__${tabGroup}`,
			};
		};

		/** Render a collection of tabs. */
		obj._renderTabs = function (tabMetas, {$parent, propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, cbTabChange} = {}) {
			if (!tabMetas.length) throw new Error(`One or more tab meta must be specified!`);
			obj._resetTabs({tabGroup});

			const isSingleTab = tabMetas.length === 1;

			const {propActive, _propProxy, __propProxy} = obj._getTabProps({propProxy, tabGroup});

			this[__propProxy][propActive] = this[__propProxy][propActive] || 0;

			const $dispTabTitle = obj.__$getDispTabTitle({isSingleTab});

			const renderTabMetas_standard = (it, i) => {
				const $btnTab = obj.__$getBtnTab({
					isSingleTab,
					tabMeta: it,
					_propProxy,
					propActive,
					ixTab: i,
				});

				const $wrpTab = obj.__$getWrpTab({tabMeta: it, ixTab: i});

				return {
					...it,
					ix: i,
					$btnTab,
					$wrpTab,
				};
			};

			const tabMetasOut = tabMetas.map((it, i) => {
				if (it.type) return obj.__renderTypedTabMeta({tabMeta: it, ixTab: i});
				return renderTabMetas_standard(it, i);
			}).filter(Boolean);

			if ($parent) obj.__renderTabs_addToParent({$dispTabTitle, $parent, tabMetasOut});

			const hkActiveTab = () => {
				tabMetasOut.forEach(it => {
					if (it.type) return; // For specially typed tabs (e.g. buttons), do nothing

					const isActive = it.ix === this[_propProxy][propActive];
					if (isActive && $dispTabTitle) $dispTabTitle.text(isSingleTab ? "" : it.name);
					if (it.$btnTab) it.$btnTab.toggleClass("active", isActive);
					it.$wrpTab.toggleVe(isActive);
				});

				if (cbTabChange) cbTabChange();
			};
			this._addHook(propProxy, propActive, hkActiveTab);
			hkActiveTab();

			obj.__tabState[tabGroup] = {
				fnReset: () => {
					this._removeHook(propProxy, propActive, hkActiveTab);
				},
				tabMetasOut,
			};

			return tabMetasOut;
		};

		obj.__renderTabs_addToParent = function ({$dispTabTitle, $parent, tabMetasOut}) {
			const hasBorder = tabMetasOut.some(it => it.hasBorder);
			$$`<div class="flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="flex-col w-100 h-100 min-h-0">
					<div class="flex ${hasBorder ? `ui-tab__wrp-tab-heads--border` : ""}">${tabMetasOut.map(it => it.$btnTab)}</div>
					<div class="flex w-100 h-100 min-h-0">${tabMetasOut.map(it => it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
		};

		obj._resetTabs = function ({tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			if (!obj.__tabState[tabGroup]) return;
			obj.__tabState[tabGroup].fnReset();
			delete obj.__tabState[tabGroup];
		};

		obj._hasPrevTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__hasTab({propProxy, tabGroup, offset: -1});
		};
		obj._hasNextTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__hasTab({propProxy, tabGroup, offset: 1});
		};

		obj.__hasTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			const ixActive = obj[_propProxy][propActive];
			return !!(obj.__tabState[tabGroup]?.tabMetasOut && obj.__tabState[tabGroup]?.tabMetasOut[ixActive + offset]);
		};

		obj._doSwitchToPrevTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__doSwitchToTab({propProxy, tabGroup, offset: -1});
		};
		obj._doSwitchToNextTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			return obj.__doSwitchToTab({propProxy, tabGroup, offset: 1});
		};

		obj.__doSwitchToTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, offset}) {
			if (!obj.__hasTab({propProxy, tabGroup, offset})) return;
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			obj[_propProxy][propActive] = obj[_propProxy][propActive] + offset;
		};

		obj._addHookActiveTab = function (hook, {propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const {propActive} = obj._getTabProps({propProxy, tabGroup});
			this._addHook(propProxy, propActive, hook);
		};

		obj._getIxActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP} = {}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			return obj[_propProxy][propActive];
		};

		obj._setIxActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, ixActiveTab} = {}) {
			const {propActive, _propProxy} = obj._getTabProps({propProxy, tabGroup});
			obj[_propProxy][propActive] = ixActiveTab;
		};

		obj._getActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP}) {
			const tabState = obj.__tabState[tabGroup];
			const ixActiveTab = obj._getIxActiveTab({propProxy, tabGroup});
			return tabState.tabMetasOut[ixActiveTab];
		};

		obj._setActiveTab = function ({propProxy = TabUiUtilBase._DEFAULT_PROP_PROXY, tabGroup = TabUiUtilBase._DEFAULT_TAB_GROUP, tab}) {
			const tabState = obj.__tabState[tabGroup];
			const ix = tabState.tabMetasOut.indexOf(tab);
			obj._setIxActiveTab({propProxy, tabGroup, ixActiveTab: ix});
		};

		obj.__$getBtnTab = function () { throw new Error("Unimplemented!"); };
		obj.__$getWrpTab = function () { throw new Error("Unimplemented!"); };
		obj.__renderTypedTabMeta = function () { throw new Error("Unimplemented!"); };
		obj.__$getDispTabTitle = function () { throw new Error("Unimplemented!"); };
	}
}
TabUiUtilBase._DEFAULT_TAB_GROUP = "_default";
TabUiUtilBase._DEFAULT_PROP_PROXY = "meta";

TabUiUtilBase.TabMeta = class {
	constructor ({name, icon = null, type = null, buttons = null} = {}) {
		this.name = name;
		this.icon = icon;
		this.type = type;
		this.buttons = buttons;
	}
}

class TabUiUtil extends TabUiUtilBase {
	static decorate (obj) {
		super.decorate(obj);

		obj.__$getBtnTab = function ({tabMeta, _propProxy, propActive, ixTab}) {
			return $(`<button class="btn btn-default ui-tab__btn-tab-head">${tabMeta.name.qq()}</button>`)
				.click(() => obj[_propProxy][propActive] = ixTab);
		};

		obj.__$getWrpTab = function ({tabMeta}) {
			return $(`<div class="ui-tab__wrp-tab-body flex-col ve-hidden ${tabMeta.hasBorder ? "ui-tab__wrp-tab-body--border" : ""} ${tabMeta.hasBackground ? "ui-tab__wrp-tab-body--background" : ""}"></div>`)
		};

		obj.__renderTypedTabMeta = function ({tabMeta, ixTab}) {
			switch (tabMeta.type) {
				default: throw new Error(`Unhandled tab type "${tabMeta.type}"`);
			}
		};

		obj.__$getDispTabTitle = function () { return null; };
	}
}
TabUiUtil.TabMeta = class extends TabUiUtilBase.TabMeta {
	constructor (opts) {
		super(opts);
		this.hasBorder = opts.hasBorder;
		this.hasBackground = opts.hasBackground;
	}
}

class TabUiUtilSide extends TabUiUtilBase {
	static decorate (obj) {
		super.decorate(obj);

		obj.__$getBtnTab = function ({isSingleTab, tabMeta, _propProxy, propActive, ixTab}) {
			return isSingleTab ? null : $(`<button class="btn btn-default btn-sm ui-tab-side__btn-tab mb-2 br-0 btr-0 bbr-0 text-left flex-v-center" title="${tabMeta.name.qq()}"><div class="${tabMeta.icon} ui-tab-side__icon-tab mr-2 mobile-ish__mr-0 text-center"></div><div class="mobile-ish__hidden">${tabMeta.name.qq()}</div></button>`)
				.click(() => this[_propProxy][propActive] = ixTab);
		};

		obj.__$getWrpTab = function () {
			return $(`<div class="flex-col w-100 h-100 ui-tab-side__wrp-tab px-3 py-2 overflow-y-auto"></div>`);
		};

		obj.__renderTabs_addToParent = function ({$dispTabTitle, $parent, tabMetasOut}) {
			$$`<div class="flex-col w-100 h-100">
				${$dispTabTitle}
				<div class="flex w-100 h-100 min-h-0">
					<div class="flex-col h-100 pt-2">${tabMetasOut.map(it => it.$btnTab)}</div>
					<div class="flex-col w-100 h-100 min-w-0">${tabMetasOut.map(it => it.$wrpTab).filter(Boolean)}</div>
				</div>
			</div>`.appendTo($parent);
		};

		obj.__renderTypedTabMeta = function ({tabMeta, ixTab}) {
			switch (tabMeta.type) {
				case "buttons": return obj.__renderTypedTabMeta_buttons({tabMeta, ixTab});
				default: throw new Error(`Unhandled tab type "${tabMeta.type}"`);
			}
		};

		obj.__renderTypedTabMeta_buttons = function ({tabMeta, ixTab}) {
			const $btns = tabMeta.buttons.map((meta, j) => {
				const $btn = $(`<button class="btn ${meta.type ? `btn-${meta.type}` : "btn-primary"} btn-sm" ${meta.title ? `title="${meta.title.qq()}"` : ""}>${meta.html}</button>`)
					.click(evt => meta.pFnClick(evt, $btn));

				if (j === tabMeta.buttons.length - 1) $btn.addClass(`br-0 btr-0 bbr-0`);

				return $btn;
			});

			const $btnTab = $$`<div class="btn-group flex-v-center flex-h-right mb-2">${$btns}</div>`;

			return {
				...tabMeta,
				ix: ixTab,
				$btnTab,
			};
		};

		obj.__$getDispTabTitle = function ({isSingleTab}) {
			return $(`<div class="ui-tab-side__disp-active-tab-name ${isSingleTab ? `ui-tab-side__disp-active-tab-name--single` : ""} bold"></div>`);
		};
	}
}

// TODO have this respect the blacklist?
class SearchUiUtil {
	static async pDoGlobalInit () {
		elasticlunr.clearStopWords();
		await Renderer.item.populatePropertyAndTypeReference();
	}

	static _isNoHoverCat (cat) {
		return SearchUiUtil.NO_HOVER_CATEGORIES.has(cat);
	}

	static async pGetContentIndices (options) {
		options = options || {};

		const availContent = {};

		const [searchIndexRaw] = await Promise.all([
			DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index.json`),
			ExcludeUtil.pInitialise(),
		]);

		const data = Omnidexer.decompressIndex(searchIndexRaw);

		const additionalData = {};
		if (options.additionalIndices) {
			await Promise.all(options.additionalIndices.map(async add => {
				additionalData[add] = Omnidexer.decompressIndex(await DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index-${add}.json`));
				const maxId = additionalData[add].last().id;
				const brewIndex = await BrewUtil.pGetAdditionalSearchIndices(maxId, add);
				if (brewIndex.length) additionalData[add] = additionalData[add].concat(brewIndex);
			}));
		}

		const alternateData = {};
		if (options.alternateIndices) {
			await Promise.all(options.alternateIndices.map(async alt => {
				alternateData[alt] = Omnidexer.decompressIndex(await DataUtil.loadJSON(`${Renderer.get().baseUrl}search/index-alt-${alt}.json`));
				const maxId = alternateData[alt].last().id;
				const brewIndex = await BrewUtil.pGetAlternateSearchIndices(maxId, alt);
				if (brewIndex.length) alternateData[alt] = alternateData[alt].concat(brewIndex);
			}));
		}

		const fromDeepIndex = (d) => d.d; // flag for "deep indexed" content that refers to the same item

		availContent.ALL = elasticlunr(function () {
			this.addField("n");
			this.addField("s");
			this.setRef("id");
		});
		SearchUtil.removeStemmer(availContent.ALL);

		// Add main site index
		let ixMax = 0;

		const initIndexForFullCat = (doc) => {
			if (!availContent[doc.cf]) {
				availContent[doc.cf] = elasticlunr(function () {
					this.addField("n");
					this.addField("s");
					this.setRef("id");
				});
				SearchUtil.removeStemmer(availContent[doc.cf]);
			}
		};

		const handleDataItem = (d, isAlternate) => {
			if (
				SearchUiUtil._isNoHoverCat(d.c)
				|| fromDeepIndex(d)
				|| ExcludeUtil.isExcluded(d.h, Parser.pageCategoryToProp(d.c), d.s, {isNoCount: true})
			) return;
			d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
			if (isAlternate) d.cf = `alt_${d.cf}`;
			initIndexForFullCat(d);
			if (!isAlternate) availContent.ALL.addDoc(d);
			availContent[d.cf].addDoc(d);
			ixMax = Math.max(ixMax, d.id);
		};

		data.forEach(d => handleDataItem(d));
		Object.values(additionalData).forEach(arr => arr.forEach(d => handleDataItem(d)));
		Object.values(alternateData).forEach(arr => arr.forEach(d => handleDataItem(d, true)));

		// Add homebrew
		Omnisearch.highestId = Math.max(ixMax, Omnisearch.highestId);

		const brewIndex = await BrewUtil.pGetSearchIndex();

		brewIndex.forEach(d => {
			if (SearchUiUtil._isNoHoverCat(d.c) || fromDeepIndex(d)) return;
			d.cf = Parser.pageCategoryToFull(d.c);
			d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
			initIndexForFullCat(d);
			availContent.ALL.addDoc(d);
			availContent[d.cf].addDoc(d);
		});

		return availContent;
	}
}
SearchUiUtil.NO_HOVER_CATEGORIES = new Set([
	Parser.CAT_ID_ADVENTURE,
	Parser.CAT_ID_BOOK,
	Parser.CAT_ID_QUICKREF,
	Parser.CAT_ID_PAGE,
	Parser.CAT_ID_LEGENDARY_GROUP,
]);

// based on DM screen's AddMenuSearchTab
class SearchWidget {
	static getSearchNoResults () {
		return `<div class="ui-search__message"><i>No results.</i></div>`;
	}

	static getSearchLoading () {
		return `<div class="ui-search__message"><i>\u2022\u2022\u2022</i></div>`;
	}

	static getSearchEnter () {
		return `<div class="ui-search__message"><i>Enter a search.</i></div>`;
	}

	/**
	 * @param $iptSearch input element
	 * @param opts Options object.
	 * @param opts.fnSearch Function which runs the search.
	 * @param opts.fnShowWait Function which displays loading dots
	 * @param opts.flags Flags object; modified during user interaction.
	 * @param opts.flags.isWait Flag tracking "waiting for user to stop typing"
	 * @param opts.flags.doClickFirst Flag tracking "should first result get clicked"
	 * @param opts.flags.doClickFirst Flag tracking "should first result get clicked"
	 * @param opts.$ptrRows Pointer to array of rows.
	 */
	static bindAutoSearch ($iptSearch, opts) {
		UiUtil.bindTypingEnd({
			$ipt: $iptSearch,
			fnKeyup: () => {
				opts.fnSearch && opts.fnSearch();
			},
			fnKeypress: evt => {
				if (evt.which === 13) {
					opts.flags.doClickFirst = true;
					opts.fnSearch && opts.fnSearch();
				}
			},
			fnKeydown: evt => {
				if (opts.flags.isWait) {
					opts.flags.isWait = false;
					opts.fnShowWait && opts.fnShowWait();
				} else {
					switch (evt.which) {
						case 40: { // down
							if (opts.$ptrRows && opts.$ptrRows._[0]) {
								evt.preventDefault();
								opts.$ptrRows._[0].focus();
							}
							break;
						}
						case 13: { // enter
							if (opts.$ptrRows && opts.$ptrRows._[0]) {
								evt.preventDefault();
								opts.$ptrRows._[0].click();
							}
							break;
						}
					}
				}
			},
			fnClick: () => {
				if (opts.fnSearch && $iptSearch.val() && $iptSearch.val().trim().length) opts.fnSearch();
			},
		});
	}

	static bindRowHandlers ({result, $row, $ptrRows, fnHandleClick}) {
		return $row
			.keydown(evt => {
				switch (evt.which) {
					case 13: { // enter
						return fnHandleClick(result);
					}
					case 38: { // up
						evt.preventDefault();
						const ixRow = $ptrRows._.indexOf($row);
						const $prev = $ptrRows._[ixRow - 1];
						if ($prev) $prev.focus();
						else $ptrRows.focus();
						break;
					}
					case 40: { // down
						evt.preventDefault();
						const ixRow = $ptrRows._.indexOf($row);
						const $nxt = $ptrRows._[ixRow + 1];
						if ($nxt) $nxt.focus();
						break;
					}
				}
			})
			.click(() => fnHandleClick(result));
	}

	static docToPageSourceHash (doc) {
		const page = UrlUtil.categoryToHoverPage(doc.c);
		const source = doc.s;
		const hash = doc.u;

		return {page, source, hash};
	}

	/**
	 * @param indexes An object with index names (categories) as the keys, and indexes as the values.
	 * @param cbSearch Callback to run on user clicking a search result.
	 * @param options Options object.
	 * @param options.defaultCategory Default search category.
	 * @param options.fnFilterResults Function which takes a document and returns false if it is to be filtered out of the results.
	 * @param options.searchOptions Override for default elasticlunr search options.
	 * @param options.fnTransform Function which transforms the document before passing it back to cbSearch.
	 */
	constructor (indexes, cbSearch, options) {
		options = options || {};

		this._indexes = indexes;
		this._cat = options.defaultCategory || "ALL";
		this._cbSearch = cbSearch;
		this._fnFilterResults = options.fnFilterResults || null;
		this._searchOptions = options.searchOptions || null;
		this._fnTransform = options.fnTransform || null;

		this._flags = {
			doClickFirst: false,
			isWait: false,
		};
		this._$ptrRows = {_: []};

		this._$selCat = null;
		this._$iptSearch = null;
		this._$wrpResults = null;

		this._$rendered = null;
	}

	static pDoGlobalInit () {
		if (!SearchWidget.P_LOADING_CONTENT) {
			SearchWidget.P_LOADING_CONTENT = (async () => {
				Object.assign(SearchWidget.CONTENT_INDICES, await SearchUiUtil.pGetContentIndices({additionalIndices: ["item"], alternateIndices: ["spell"]}));
			})();
		}
		return SearchWidget.P_LOADING_CONTENT;
	}

	__getSearchOptions () {
		return this._searchOptions || {
			fields: {
				n: {boost: 5, expand: true},
				s: {expand: true},
			},
			bool: "AND",
			expand: true,
		};
	}

	__$getRow (r) {
		return $(`<div class="ui-search__row" tabindex="0">
			<span>${r.doc.n}</span>
			<span>${r.doc.s ? `<i title="${Parser.sourceJsonToFull(r.doc.s)}">${Parser.sourceJsonToAbv(r.doc.s)}${r.doc.p ? ` p${r.doc.p}` : ""}</i>` : ""}</span>
		</div>`);
	}

	static __getAllTitle () {
		return "All Categories";
	}

	static __getCatOptionText (it) {
		return it;
	}

	get $wrpSearch () {
		if (!this._$rendered) this._render();
		return this._$rendered
	}

	__showMsgInputRequired () {
		this._flags.isWait = true;
		this._$wrpResults.empty().append(SearchWidget.getSearchEnter());
	}

	__showMsgWait () {
		this._$wrpResults.empty().append(SearchWidget.getSearchLoading())
	}

	__showMsgNoResults () {
		this._flags.isWait = true;
		this._$wrpResults.empty().append(SearchWidget.getSearchNoResults());
	}

	__doSearch () {
		const searchInput = this._$iptSearch.val().trim();

		const index = this._indexes[this._cat];
		const results = index.search(searchInput, this.__getSearchOptions());

		const {toProcess, resultCount} = (() => {
			if (results.length) {
				if (this._fnFilterResults) {
					const filtered = results.filter(it => this._fnFilterResults(it.doc));
					return {
						toProcess: filtered.slice(0, UiUtil.SEARCH_RESULTS_CAP),
						resultCount: filtered.length,
					}
				} else {
					return {
						toProcess: results.slice(0, UiUtil.SEARCH_RESULTS_CAP),
						resultCount: results.length,
					}
				}
			} else {
				// If the user has entered a search and we found nothing, return no results
				if (searchInput.trim()) {
					return {
						toProcess: [],
						resultCount: 0,
					};
				}

				// Otherwise, we have no search term, so show a default list of results
				if (this._fnFilterResults) {
					const filtered = Object.values(index.documentStore.docs).filter(it => this._fnFilterResults(it)).map(it => ({doc: it}));
					return {
						toProcess: filtered.slice(0, UiUtil.SEARCH_RESULTS_CAP),
						resultCount: filtered.length,
					}
				} else {
					return {
						toProcess: Object.values(index.documentStore.docs).slice(0, UiUtil.SEARCH_RESULTS_CAP).map(it => ({doc: it})),
						resultCount: Object.values(index.documentStore.docs).length,
					}
				}
			}
		})();

		this._$wrpResults.empty();
		this._$ptrRows._ = [];

		if (resultCount) {
			const handleClick = (r) => {
				if (this._fnTransform) this._cbSearch(this._fnTransform(r.doc));
				else this._cbSearch(r.doc);
			};

			if (this._flags.doClickFirst) {
				handleClick(toProcess[0]);
				this._flags.doClickFirst = false;
				return;
			}

			const res = toProcess.slice(0, UiUtil.SEARCH_RESULTS_CAP);

			res.forEach(r => {
				const $row = this.__$getRow(r).appendTo(this._$wrpResults);
				SearchWidget.bindRowHandlers({result: r, $row, $ptrRows: this._$ptrRows, fnHandleClick: handleClick});
				this._$ptrRows._.push($row);
			});

			if (resultCount > UiUtil.SEARCH_RESULTS_CAP) {
				const diff = resultCount - UiUtil.SEARCH_RESULTS_CAP;
				this._$wrpResults.append(`<div class="ui-search__row ui-search__row--readonly">...${diff} more result${diff === 1 ? " was" : "s were"} hidden. Refine your search!</div>`);
			}
		} else {
			if (!searchInput.trim()) this.__showMsgInputRequired();
			else this.__showMsgNoResults();
		}
	}

	_render () {
		if (!this._$rendered) {
			this._$rendered = $(`<div class="ui-search__wrp-output"></div>`);
			const $wrpControls = $(`<div class="ui-search__wrp-controls"></div>`).appendTo(this._$rendered);

			this._$selCat = $(`<select class="form-control ui-search__sel-category">
				<option value="ALL">${SearchWidget.__getAllTitle()}</option>
				${Object.keys(this._indexes).sort().filter(it => it !== "ALL").map(it => `<option value="${it}">${SearchWidget.__getCatOptionText(it)}</option>`).join("")}
			</select>`)
				.appendTo($wrpControls).toggle(Object.keys(this._indexes).length !== 1)
				.on("change", () => {
					this._cat = this._$selCat.val();
					this.__doSearch();
				});

			this._$iptSearch = $(`<input class="ui-search__ipt-search search form-control" autocomplete="off" placeholder="Search...">`).appendTo($wrpControls);
			this._$wrpResults = $(`<div class="ui-search__wrp-results"></div>`).appendTo(this._$rendered);

			let lastSearchTerm = "";
			SearchWidget.bindAutoSearch(this._$iptSearch, {
				flags: this._flags,
				fnSearch: this.__doSearch.bind(this),
				fnShowWait: this.__showMsgWait.bind(this),
				$ptrRows: this._$ptrRows,
			});

			// On the first keypress, switch to loading dots
			this._$iptSearch.keydown(evt => {
				if (evt.key === "Escape") this._$iptSearch.blur();
				if (!this._$iptSearch.val().trim().length) return;
				if (evt.which !== 13) {
					if (lastSearchTerm === "") this.__showMsgWait();
					lastSearchTerm = this._$iptSearch.val();
				}
			});

			this.__doSearch();
		}
	}

	doFocus () {
		this._$iptSearch.focus();
	}

	static async pAddToIndexes (prop, entry) {
		const nextId = Object.values(SearchWidget.CONTENT_INDICES.ALL.documentStore.docs).length;

		const indexer = new Omnidexer(nextId);

		const toIndex = {[prop]: [entry]};

		const toIndexMultiPart = Omnidexer.TO_INDEX__FROM_INDEX_JSON.filter(it => it.listProp === prop);
		for (const it of toIndexMultiPart) await indexer.pAddToIndex(it, toIndex);

		const toIndexSinglePart = Omnidexer.TO_INDEX.filter(it => it.listProp === prop);
		for (const it of toIndexSinglePart) await indexer.pAddToIndex(it, toIndex);

		const toAdd = Omnidexer.decompressIndex(indexer.getIndex());
		toAdd.forEach(d => {
			d.cf = d.c === Parser.CAT_ID_CREATURE ? "Creature" : Parser.pageCategoryToFull(d.c);
			SearchWidget.CONTENT_INDICES.ALL.addDoc(d);
			SearchWidget.CONTENT_INDICES[d.cf].addDoc(d);
		});
	}

	// region entity searches
	static async pGetUserSpellSearch (opts) {
		opts = opts || {};
		await SearchWidget.P_LOADING_CONTENT;

		const nxtOpts = {
			fnTransform: doc => {
				const cpy = MiscUtil.copy(doc);
				Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
				cpy.tag = `{@spell ${doc.n.toSpellCase()}${doc.s !== SRC_PHB ? `|${doc.s}` : ""}}`;
				return cpy;
			},
		};
		if (opts.level != null) nxtOpts.fnFilterResults = result => result.lvl === opts.level;

		const title = opts.level === 0 ? "Select Cantrip" : "Select Spell";
		return SearchWidget.pGetUserEntitySearch(
			title,
			"alt_Spell",
			nxtOpts,
		);
	}

	static async pGetUserLegendaryGroupSearch () {
		await SearchWidget.pLoadCustomIndex("entity_LegendaryGroups", `${Renderer.get().baseUrl}data/bestiary/legendarygroups.json`, "legendaryGroup", Parser.CAT_ID_LEGENDARY_GROUP, "legendaryGroup", "legendary groups");

		return SearchWidget.pGetUserEntitySearch(
			"Select Legendary Group",
			"entity_LegendaryGroups",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copy(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.page = "legendaryGroup";
					return cpy;
				},
			},
		);
	}

	static async pGetUserFeatSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		await SearchWidget.pLoadCustomIndex("entity_Feats", `${Renderer.get().baseUrl}data/feats.json`, "feat", Parser.CAT_ID_FEAT, UrlUtil.PG_FEATS, "feats");

		return SearchWidget.pGetUserEntitySearch(
			"Select Feat",
			"entity_Feats",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copy(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@feat ${doc.n}${doc.s !== SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserBackgroundSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		await SearchWidget.pLoadCustomIndex("entity_Backgrounds", `${Renderer.get().baseUrl}data/backgrounds.json`, "background", Parser.CAT_ID_BACKGROUND, UrlUtil.PG_BACKGROUNDS, "backgrounds");

		return SearchWidget.pGetUserEntitySearch(
			"Select Background",
			"entity_Backgrounds",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copy(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@background ${doc.n}${doc.s !== SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserRaceSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		const dataSource = () => {
			return DataUtil.race.loadJSON();
		};
		await SearchWidget.pLoadCustomIndex("entity_Races", dataSource, "race", Parser.CAT_ID_RACE, UrlUtil.PG_RACES, "races");

		return SearchWidget.pGetUserEntitySearch(
			"Select Race",
			"entity_Races",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copy(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@race ${doc.n}${doc.s !== SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserOptionalFeatureSearch () {
		// FIXME convert to be more like spell/creature search instead of running custom indexes
		await SearchWidget.pLoadCustomIndex("entity_OptionalFeatures", `${Renderer.get().baseUrl}data/optionalfeatures.json`, "optionalfeature", Parser.CAT_ID_OPTIONAL_FEATURE_OTHER, UrlUtil.PG_OPT_FEATURES, "optional features");

		return SearchWidget.pGetUserEntitySearch(
			"Select Optional Feature",
			"entity_OptionalFeatures",
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copy(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@optfeature ${doc.n}${doc.s !== SRC_PHB ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserAdventureSearch (opts) {
		await SearchWidget.pLoadCustomIndex("entity_Adventures", `${Renderer.get().baseUrl}data/adventures.json`, "adventure", Parser.CAT_ID_ADVENTURE, UrlUtil.PG_ADVENTURE, "adventures");
		return SearchWidget.pGetUserEntitySearch("Select Adventure", "entity_Adventures", opts);
	}

	static async pGetUserCreatureSearch () {
		await SearchWidget.P_LOADING_CONTENT;

		const nxtOpts = {
			fnTransform: doc => {
				const cpy = MiscUtil.copy(doc);
				Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
				cpy.tag = `{@creature ${doc.n}${doc.s !== SRC_MM ? `|${doc.s}` : ""}}`;
				return cpy;
			},
		};

		return SearchWidget.pGetUserEntitySearch(
			"Select Creature",
			"Creature",
			nxtOpts,
		);
	}

	static async __pLoadItemIndex (isBasicIndex) {
		const dataSource = async () => {
			const allItems = await Renderer.item.pBuildList({isBlacklistVariants: true});
			return {
				item: allItems.filter(it => {
					if (it.type === "GV") return false;
					if (isBasicIndex == null) return true;
					const isBasic = it.rarity === "none" || it.rarity === "unknown" || it._category === "basic";
					return isBasicIndex ? isBasic : !isBasic;
				}),
			};
		};
		const indexName = isBasicIndex == null ? "entity_Items" : isBasicIndex ? "entity_ItemsBasic" : "entity_ItemsMagic";
		return SearchWidget.pLoadCustomIndex(indexName, dataSource, "item", Parser.CAT_ID_ITEM, UrlUtil.PG_ITEMS, "items");
	}

	static async __pGetUserItemSearch (isBasicIndex) {
		const indexName = isBasicIndex == null ? "entity_Items" : isBasicIndex ? "entity_ItemsBasic" : "entity_ItemsMagic";
		return SearchWidget.pGetUserEntitySearch(
			"Select Item",
			indexName,
			{
				fnTransform: doc => {
					const cpy = MiscUtil.copy(doc);
					Object.assign(cpy, SearchWidget.docToPageSourceHash(cpy));
					cpy.tag = `{@item ${doc.n}${doc.s !== SRC_DMG ? `|${doc.s}` : ""}}`;
					return cpy;
				},
			},
		);
	}

	static async pGetUserBasicItemSearch () {
		await SearchWidget.__pLoadItemIndex(true);
		return SearchWidget.__pGetUserItemSearch(true);
	}

	static async pGetUserMagicItemSearch () {
		await SearchWidget.__pLoadItemIndex(false);
		return SearchWidget.__pGetUserItemSearch(false);
	}

	static async pGetUserItemSearch () {
		await SearchWidget.__pLoadItemIndex();
		return SearchWidget.__pGetUserItemSearch();
	}
	// endregion

	/**
	 *
	 * @param title
	 * @param indexName
	 * @param [opts]
	 * @param [opts.fnFilterResults]
	 * @param [opts.fnTransform]
	 */
	static async pGetUserEntitySearch (title, indexName, opts) {
		opts = opts || {};

		return new Promise(resolve => {
			const searchOpts = {defaultCategory: indexName};
			if (opts.fnFilterResults) searchOpts.fnFilterResults = opts.fnFilterResults;
			if (opts.fnTransform) searchOpts.fnTransform = opts.fnTransform;

			const searchWidget = new SearchWidget(
				{[indexName]: SearchWidget.CONTENT_INDICES[indexName]},
				(docOrTransformed) => {
					doClose(false); // "cancel" close
					resolve(docOrTransformed);
				},
				searchOpts,
			);
			const {$modalInner, doClose} = UiUtil.getShowModal({
				title,
				cbClose: (doResolve) => {
					searchWidget.$wrpSearch.detach();
					if (doResolve) resolve(null); // ensure resolution
				},
			});
			$modalInner.append(searchWidget.$wrpSearch);
			searchWidget.doFocus();
		});
	}

	// region custom search indexes
	static async pLoadCustomIndex (contentIndexName, dataSource, jsonProp, catId, page, errorName) {
		if (SearchWidget.P_LOADING_INDICES[contentIndexName]) await SearchWidget.P_LOADING_INDICES[contentIndexName];
		else {
			const doClose = SearchWidget._showLoadingModal();

			try {
				SearchWidget.P_LOADING_INDICES[contentIndexName] = (SearchWidget.CONTENT_INDICES[contentIndexName] = await SearchWidget._pGetIndex(dataSource, jsonProp, catId, page));
				SearchWidget.P_LOADING_INDICES[contentIndexName] = null;
			} catch (e) {
				JqueryUtil.doToast({type: "danger", content: `Could not load ${errorName}! ${VeCt.STR_SEE_CONSOLE}`});
				throw e;
			} finally {
				doClose();
			}
		}
	}

	static async _pGetIndex (dataSource, prop, catId, page) {
		const index = elasticlunr(function () {
			this.addField("n");
			this.addField("s");
			this.setRef("id");
		});

		const [featJson, homebrew] = await Promise.all([
			typeof dataSource === "string" ? DataUtil.loadJSON(dataSource) : dataSource(),
			BrewUtil.pAddBrewData(),
		]);

		featJson[prop].concat(homebrew[prop] || []).forEach((it, i) => index.addDoc({
			id: i,
			c: catId,
			cf: Parser.pageCategoryToFull(catId),
			h: 1,
			n: it.name,
			p: it.page,
			s: it.source,
			u: UrlUtil.URL_TO_HASH_BUILDER[page](it),
		}));

		return index;
	}

	static _showLoadingModal () {
		const {$modalInner, doClose} = UiUtil.getShowModal({isPermanent: true});
		$(`<div class="flex-vh-center w-100 h-100"><span class="dnd-font italic ve-muted">Loading...</span></div>`).appendTo($modalInner);
		return doClose;
	}
	// endregion
}
SearchWidget.P_LOADING_CONTENT = null;
SearchWidget.CONTENT_INDICES = {};
SearchWidget.P_LOADING_INDICES = {};

class InputUiUtil {
	/**
	 * @param opts Options.
	 * @param opts.min Minimum value.
	 * @param opts.max Maximum value.
	 * @param opts.int If the value returned should be an integer.
	 * @param opts.title Prompt title.
	 * @param opts.default Default value.
	 * @param [opts.$elePre] Element to add before the number input.
	 * @param [opts.$elePost] Element to add after the number input.
	 * @param [opts.isPermanent] If the prompt can only be closed by entering a number.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @param [opts.storageKey_default] Storage key for a "default" value override using the user's last/previous input.
	 * @param [opts.isGlobal_default] If the "default" storage key is global (rather than page-specific).
	 * @return {Promise<number>} A promise which resolves to the number if the user entered one, or null otherwise.
	 */
	static async pGetUserNumber (opts) {
		opts = opts || {};

		let defaultVal = opts.default !== undefined ? opts.default : null;
		if (opts.storageKey_default) {
			const prev = await (opts.isGlobal_default ? StorageUtil.pGet(opts.storageKey_default) : StorageUtil.pGetForPage(opts.storageKey_default));
			if (prev != null) defaultVal = prev;
		}

		return new Promise(resolve => {
			const $iptNumber = $(`<input class="form-control mb-2 text-right" ${opts.min ? `min="${opts.min}"` : ""} ${opts.max ? `max="${opts.max}"` : ""}>`)
				.keydown(evt => {
					if (evt.key === "Escape") { $iptNumber.blur(); return; }
					// return key
					if (evt.which === 13) doClose(true);
					evt.stopPropagation();
				});
			if (defaultVal !== undefined) $iptNumber.val(defaultVal);

			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));

			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Enter a Number",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);

					if (!isDataEntered) return resolve(null);
					const raw = $iptNumber.val();
					if (!raw.trim()) return resolve(null);
					let num = UiUtil.strToInt(raw);
					if (opts.min) num = Math.max(opts.min, num);
					if (opts.max) num = Math.min(opts.max, num);
					if (opts.int) num = Math.round(num);

					if (opts.storageKey_default) {
						opts.isGlobal_default
							? StorageUtil.pSet(opts.storageKey_default, num)
							: StorageUtil.pSetForPage(opts.storageKey_default, num);
					}

					resolve(num);
				},
			});

			if (opts.$elePre) opts.$elePre.appendTo($modalInner);
			$iptNumber.appendTo($modalInner);
			if (opts.$elePost) opts.$elePost.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
			$iptNumber.focus();
			$iptNumber.select();
		});
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.textYesRemember] Text for "yes, and remember" button.
	 * @param [opts.textYes] Text for "yes" button.
	 * @param [opts.textNo] Text for "no" button.
	 * @param [opts.textSkip] Text for "skip" button.
	 * @param [opts.htmlDescription] Description HTML for the modal.
	 * @param [opts.storageKey] Storage key to use when "remember" options are passed.
	 * @param [opts.isGlobal] If the stored setting is global when "remember" options are passed.
	 * @param [opts.fnRemember] Custom function to run when saving the "yes and remember" option.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise} A promise which resolves to true/false if the user chose, or null otherwise.
	 */
	static async pGetUserBoolean (opts) {
		opts = opts || {};

		if (opts.storageKey) {
			const prev = await (opts.isGlobal ? StorageUtil.pGet(opts.storageKey) : StorageUtil.pGetForPage(opts.storageKey));
			if (prev != null) return prev;
		}

		return new Promise(resolve => {
			const $btnTrueRemember = opts.textYesRemember ? $(`<button class="btn btn-primary flex-v-center mr-2"><span class="glyphicon glyphicon-ok mr-2"></span><span>${opts.textYesRemember}</span></button>`)
				.click(() => {
					doClose(true, true);
					if (opts.fnRemember) {
						opts.fnRemember(true);
					} else {
						opts.isGlobal
							? StorageUtil.pSet(opts.storageKey, true)
							: StorageUtil.pSetForPage(opts.storageKey, true);
					}
				}) : null;

			const $btnTrue = $(`<button class="btn btn-primary flex-v-center mr-3"><span class="glyphicon glyphicon-ok mr-2"></span><span>${opts.textYes || "OK"}</span></button>`)
				.click(() => doClose(true, true));

			const $btnFalse = $(`<button class="btn btn-default btn-sm flex-v-center"><span class="glyphicon glyphicon-remove mr-2"></span><span>${opts.textNo || "Cancel"}</span></button>`)
				.click(() => doClose(true, false));

			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default btn-sm ml-3"><span class="glyphicon glyphicon-forward"></span><span>${opts.textSkip || "Skip"}</span></button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));

			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Choose",
				isMinHeight0: true,
				cbClose: (isDataEntered, value) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);

					if (!isDataEntered) return resolve(null);
					if (value == null) throw new Error(`Callback must receive a value!`); // sanity check
					resolve(value);
				},
			});

			if (opts.htmlDescription && opts.htmlDescription.trim()) $$`<div class="flex w-100 mb-1">${opts.htmlDescription}</div>`.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right py-1 px-1">${$btnTrueRemember}${$btnTrue}${$btnFalse}${$btnSkip}</div>`.appendTo($modalInner);
			$btnTrue.focus();
			$btnTrue.select();
		});
	}

	/**
	 * @param opts Options.
	 * @param opts.values Array of values.
	 * @param [opts.placeholder] Placeholder text.
	 * @param [opts.title] Prompt title.
	 * @param [opts.default] Default selected index.
	 * @param [opts.fnDisplay] Function which takes a value and returns display text.
	 * @param [opts.isResolveItem] True if the promise should resolve the item instead of the index.
	 * @param [opts.$elePost] Element to add below the select box.
	 * @param [opts.fnGetExtraState] Function which returns additional state from, generally, other elements in the modal.
	 * @param [opts.isAllowNull] If an empty input should be treated as null.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise} A promise which resolves to the index of the item the user selected (or an object if fnGetExtraState is passed), or null otherwise.
	 */
	static pGetUserEnum (opts) {
		opts = opts || {};
		return new Promise(resolve => {
			const $selEnum = $(`<select class="form-control mb-2"><option value="-1" disabled>${opts.placeholder || "Select..."}</option></select>`);

			if (opts.isAllowNull) $(`<option value="-1"></option>`).text(opts.fnDisplay ? opts.fnDisplay(null, -1) : "(None)").appendTo($selEnum);

			opts.values.forEach((v, i) => $(`<option value="${i}"></option>`).text(opts.fnDisplay ? opts.fnDisplay(v, i) : v).appendTo($selEnum));
			if (opts.default != null) $selEnum.val(opts.default);
			else $selEnum[0].selectedIndex = 0;

			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));

			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Select an Option",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);

					if (!isDataEntered) return resolve(null);
					const ix = Number($selEnum.val());
					if (!~ix) return resolve(null);
					if (opts.fnGetExtraState) {
						const out = {extraState: opts.fnGetExtraState()};
						if (opts.isResolveItem) out.item = opts.values[ix];
						else out.ix = ix;
						resolve(out)
					} else resolve(opts.isResolveItem ? opts.values[ix] : ix);
				},
			});
			$selEnum.appendTo($modalInner);
			if (opts.$elePost) opts.$elePost.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
			$selEnum.focus();
		});
	}

	/**
	 * @param opts Options.
	 * @param [opts.values] Array of values. Mutually incompatible with "valueGroups".
	 * @param [opts.valueGroups] Array of value groups (of the form `{name: "Group Name", values: [...]}`). Mutually incompatible with "values".
	 * @param [opts.title] Prompt title.
	 * @param [opts.htmlDescription] Description HTML for the modal.
	 * @param [opts.count] Number of choices the user can make (cannot be used with min/max).
	 * @param [opts.min] Minimum number of choices the user can make (cannot be used with count).
	 * @param [opts.max] Maximum number of choices the user can make (cannot be used with count).
	 * @param [opts.defaults] Array of default-selected indices.
	 * @param [opts.required] Array of always-selected indices.
	 * @param [opts.isResolveItems] True if the promise should resolve to an array of the items instead of the indices.
	 * @param [opts.fnDisplay] Function which takes a value and returns display text.
	 * @param [opts.modalOpts] Options to pass through to the underlying modal class.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise} A promise which resolves to the indices of the items the user selected, or null otherwise.
	 */
	static pGetUserMultipleChoice (opts) {
		return new Promise(resolve => {
			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));

			const prop = "formData";

			const initialState = {};
			if (opts.defaults) opts.defaults.forEach(ix => initialState[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsActive(prop, ix)] = true);
			if (opts.required) {
				opts.required.forEach(ix => {
					initialState[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsActive(prop, ix)] = true; // "requires" implies "default"
					initialState[ComponentUiUtil.getMetaWrpMultipleChoice_getPropIsRequired(prop, ix)] = true;
				});
			}

			const comp = BaseComponent.fromObject(initialState);

			let title = opts.title;
			if (!title) {
				if (opts.count != null) title = `Choose ${Parser.numberToText(opts.count).uppercaseFirst()}`;
				else if (opts.min != null && opts.max != null) title = `Choose Between ${Parser.numberToText(opts.min).uppercaseFirst()} and ${Parser.numberToText(opts.max).uppercaseFirst()} Options`;
				else if (opts.min != null) title = `Choose At Least ${Parser.numberToText(opts.min).uppercaseFirst()}`;
				else title = `Choose At Most ${Parser.numberToText(opts.max).uppercaseFirst()}`;
			}

			const {$ele: $wrpList, propIsAcceptable} = ComponentUiUtil.getMetaWrpMultipleChoice(comp, prop, opts);
			$wrpList.addClass(`mb-1`);

			const hkIsAcceptable = () => $btnOk.attr("disabled", !comp._state[propIsAcceptable]);
			comp._addHookBase(propIsAcceptable, hkIsAcceptable)
			hkIsAcceptable();

			const {$modalInner, doClose} = UiUtil.getShowModal({
				...(opts.modalOpts || {}),
				title,
				isMinHeight0: true,
				isUncappedHeight: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);

					if (!isDataEntered) return resolve(null);

					const ixs = ComponentUiUtil.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);

					if (!opts.isResolveItems) resolve(ixs);
					else if (opts.values) resolve(ixs.map(ix => opts.values[ix]));
					else if (opts.valueGroups) {
						const allValues = opts.valueGroups.map(it => it.values).flat();
						resolve(ixs.map(ix => allValues[ix]))
					}
				},
			});
			if (opts.htmlDescription) $modalInner.append(opts.htmlDescription);
			$wrpList.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right no-shrink pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
			$wrpList.focus();
		});
	}

	/**
	 * NOTE: designed to work with FontAwesome.
	 *
	 * @param opts Options.
	 * @param opts.values Array of icon metadata. Items should be of the form: `{name: "<n>", iconClass: "<c>", buttonClass: "<cs>", buttonClassActive: "<cs>"}`
	 * @param opts.title Prompt title.
	 * @param opts.default Default selected index.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<number>} A promise which resolves to the index of the item the user selected, or null otherwise.
	 */
	static pGetUserIcon (opts) {
		opts = opts || {};
		return new Promise(resolve => {
			let lastIx = opts.default != null ? opts.default : -1;
			const onclicks = [];

			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Select an Option",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);
					if (!isDataEntered) return resolve(null);
					return resolve(~lastIx ? lastIx : null);
				},
			});

			$$`<div class="flex flex-wrap flex-h-center mb-2">${opts.values.map((v, i) => {
				const $btn = $$`<div class="m-2 btn ${v.buttonClass || "btn-default"} ui__btn-xxl-square flex-col flex-h-center">
					${v.iconClass ? `<div class="ui-icn__wrp-icon ${v.iconClass} mb-1"></div>` : ""}
					${v.iconContent ? v.iconContent : ""}
					<div class="whitespace-normal w-100">${v.name}</div>
				</div>`
					.click(() => {
						lastIx = i;
						onclicks.forEach(it => it());
					})
					.toggleClass(v.buttonClassActive || "active", opts.default === i);
				if (v.buttonClassActive && opts.default === i) {
					$btn.removeClass("btn-default").addClass(v.buttonClassActive);
				}

				onclicks.push(() => {
					$btn.toggleClass(v.buttonClassActive || "active", lastIx === i);
					if (v.buttonClassActive) $btn.toggleClass("btn-default", lastIx !== i);
				});
				return $btn;
			})}</div>`.appendTo($modalInner);

			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));

			$$`<div class="flex-v-center flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
		});
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.default] Default value.
	 * @param [opts.autocomplete] Array of autocomplete strings. REQUIRES INCLUSION OF THE TYPEAHEAD LIBRARY.
	 * @param [opts.isCode] If the text is code.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @param [opts.fnIsValid] A function which checks if the current input is valid, and prevents the user from
	 *        submitting the value if it is.
	 * @param [opts.$elePost] Element to add below the input.
	 * @param [opts.cbPostRender] Callback to call after rendering the modal
	 * @return {Promise<String>} A promise which resolves to the string if the user entered one, or null otherwise.
	 */
	static pGetUserString (opts) {
		opts = opts || {};

		const propValue = "text";
		const comp = BaseComponent.fromObject({
			[propValue]: opts.default || "",
			isValid: true,
		});

		return new Promise(resolve => {
			const $iptStr = ComponentUiUtil.$getIptStr(
				comp,
				propValue,
				{
					html: `<input class="form-control mb-2" type="text">`,
					autocomplete: opts.autocomplete,
				},
			)
				.keydown(async evt => {
					if (evt.key === "Escape") return; // Already handled

					if (opts.autocomplete) {
						// prevent double-binding the return key if we have autocomplete enabled
						await MiscUtil.pDelay(17); // arbitrary delay to allow dropdown to render (~1000/60, i.e. 1 60 FPS frame)
						if ($modalInner.find(`.typeahead.dropdown-menu`).is(":visible")) return;
					}
					// return key
					if (evt.key === "Enter") doClose(true);
					evt.stopPropagation();
				});
			if (opts.isCode) $iptStr.addClass("code");

			if (opts.fnIsValid) {
				const hkText = () => comp._state.isValid = !comp._state.text.trim() || !!opts.fnIsValid(comp._state.text);
				comp._addHookBase(propValue, hkText)
				hkText();

				const hkIsValid = () => $iptStr.toggleClass("form-control--error", !comp._state.isValid);
				comp._addHookBase("isValid", hkIsValid)
				hkIsValid();
			}

			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => {
					if (!comp._state.isValid) return JqueryUtil.doToast({content: `Please enter valid input!`, type: "warning"});
					return doClose(true);
				});
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));
			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Enter Text",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);
					if (!isDataEntered) return resolve(null);
					const raw = $iptStr.val();
					return resolve(raw);
				},
			});
			$iptStr.appendTo($modalInner);
			if (opts.$elePost) opts.$elePost.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
			$iptStr.focus();
			$iptStr.select();

			if (opts.cbPostRender) {
				opts.cbPostRender({
					comp,
					$iptStr,
					propValue,
				});
			}
		});
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.buttonText] Prompt title.
	 * @param [opts.default] Default value.
	 * @param [opts.disabled] If the text area is disabled.
	 * @param [opts.isCode] If the text is code.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<String>} A promise which resolves to the string if the user entered one, or null otherwise.
	 */
	static pGetUserText (opts) {
		opts = opts || {};
		return new Promise(resolve => {
			const $iptStr = $(`<textarea class="form-control mb-2 resize-vertical w-100" ${opts.disabled ? "disabled" : ""}></textarea>`)
				.val(opts.default);
			if (opts.isCode) $iptStr.addClass("code");
			const $btnOk = $(`<button class="btn btn-primary mr-2">${opts.buttonText || "OK"}</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));
			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Enter Text",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);
					if (!isDataEntered) return resolve(null);
					const raw = $iptStr.val();
					if (!raw.trim()) return resolve(null);
					else return resolve(raw);
				},
			});
			$iptStr.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
			$iptStr.focus();
			$iptStr.select();
		});
	}

	/**
	 * @param opts Options.
	 * @param opts.title Prompt title.
	 * @param opts.default Default value.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<String>} A promise which resolves to the color if the user entered one, or null otherwise.
	 */
	static pGetUserColor (opts) {
		opts = opts || {};
		return new Promise(resolve => {
			const $iptRgb = $(`<input class="form-control mb-2" ${opts.default != null ? `value="${opts.default}"` : ""} type="color">`);
			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));
			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Choose Color",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);
					if (!isDataEntered) return resolve(null);
					const raw = $iptRgb.val();
					if (!raw.trim()) return resolve(null);
					else return resolve(raw);
				},
			});
			$iptRgb.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
			$iptRgb.focus();
			$iptRgb.select();
		});
	}

	/**
	 *
	 * @param [opts] Options object.
	 * @param [opts.title] Modal title.
	 * @param [opts.default] Default angle.
	 * @param [opts.stepButtons] Array of labels for quick-set buttons, which will be evenly spread around the clock.
	 * @param [opts.step] Number of steps in the gauge (default 360; would be e.g. 12 for a "clock").
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @returns {Promise<number>} A promise which resolves to the number of degrees if the user pressed "Enter," or null otherwise.
	 */
	static pGetUserDirection (opts) {
		const X = 0;
		const Y = 1;
		const DEG_CIRCLE = 360;

		opts = opts || {};
		const step = Math.max(2, Math.min(DEG_CIRCLE, opts.step || DEG_CIRCLE));
		const stepDeg = DEG_CIRCLE / step;

		function getAngle (p1, p2) {
			return Math.atan2(p2[Y] - p1[Y], p2[X] - p1[X]) * 180 / Math.PI;
		}

		return new Promise(resolve => {
			let active = false;
			let curAngle = Math.min(DEG_CIRCLE, opts.default) || 0;

			const $arm = $(`<div class="ui-dir__arm"></div>`);
			const handleAngle = () => $arm.css({transform: `rotate(${curAngle + 180}deg)`});
			handleAngle();

			const $pad = $$`<div class="ui-dir__face">${$arm}</div>`.on("mousedown touchstart", evt => {
				active = true;
				handleEvent(evt);
			});

			const $document = $(document);
			const evtId = `ui_user_dir_${CryptUtil.uid()}`;
			$document.on(`mousemove.${evtId} touchmove${evtId}`, evt => {
				handleEvent(evt);
			}).on(`mouseup.${evtId} touchend${evtId} touchcancel${evtId}`, evt => {
				evt.preventDefault();
				evt.stopPropagation();
				active = false;
			});
			const handleEvent = (evt) => {
				if (!active) return;

				const coords = [EventUtil.getClientX(evt), EventUtil.getClientY(evt)];

				const {top, left} = $pad.offset();
				const center = [left + ($pad.width() / 2), top + ($pad.height() / 2)];
				curAngle = getAngle(center, coords) + 90;
				if (step !== DEG_CIRCLE) curAngle = Math.round(curAngle / stepDeg) * stepDeg;
				else curAngle = Math.round(curAngle);
				handleAngle();
			};

			const BTN_STEP_SIZE = 26;
			const BORDER_PAD = 16;
			const CONTROLS_RADIUS = (92 + BTN_STEP_SIZE + BORDER_PAD) / 2;
			const $padOuter = opts.stepButtons ? (() => {
				const steps = opts.stepButtons;
				const SEG_ANGLE = 360 / steps.length;

				const $btns = [];

				for (let i = 0; i < steps.length; ++i) {
					const theta = (SEG_ANGLE * i * (Math.PI / 180)) - (1.5708); // offset by -90 degrees
					const x = CONTROLS_RADIUS * Math.cos(theta);
					const y = CONTROLS_RADIUS * Math.sin(theta);
					$btns.push(
						$(`<button class="btn btn-default btn-xxs absolute">${steps[i]}</button>`)
							.css({
								top: y + CONTROLS_RADIUS - (BTN_STEP_SIZE / 2),
								left: x + CONTROLS_RADIUS - (BTN_STEP_SIZE / 2),
								width: BTN_STEP_SIZE,
								height: BTN_STEP_SIZE,
								zIndex: 1002,
							})
							.click(() => {
								curAngle = SEG_ANGLE * i;
								handleAngle();
							}),
					);
				}

				const $wrpInner = $$`<div class="flex-vh-center relative">${$btns}${$pad}</div>`
					.css({
						width: CONTROLS_RADIUS * 2,
						height: CONTROLS_RADIUS * 2,
					});

				return $$`<div class="flex-vh-center">${$wrpInner}</div>`
					.css({
						width: (CONTROLS_RADIUS * 2) + BTN_STEP_SIZE + BORDER_PAD,
						height: (CONTROLS_RADIUS * 2) + BTN_STEP_SIZE + BORDER_PAD,
					})
			})() : null;

			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));
			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Select Direction",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);
					$document.off(`mousemove.${evtId} touchmove${evtId} mouseup.${evtId} touchend${evtId} touchcancel${evtId}`);
					if (!isDataEntered) return resolve(null);
					if (curAngle < 0) curAngle += 360;
					return resolve(curAngle); // TODO returning the step number is more useful if step is specified?
				},
			});
			$$`<div class="flex-vh-center mb-3">
				${$padOuter || $pad}
			</div>`.appendTo($modalInner);
			$$`<div class="flex-v-center flex-h-right pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
		});
	}

	/**
	 * @param [opts] Options.
	 * @param [opts.title] Prompt title.
	 * @param [opts.default] Default values. Should be an object of the form `{num, faces, bonus}`.
	 * @param [opts.isSkippable] If the prompt is skippable.
	 * @return {Promise<String>} A promise which resolves to a dice string if the user entered values, or null otherwise.
	 */
	static pGetUserDice (opts) {
		opts = opts || {};
		return new Promise(resolve => {
			const comp = BaseComponent.fromObject({
				num: (opts.default && opts.default.num) || 1,
				faces: (opts.default && opts.default.faces) || 6,
				bonus: (opts.default && opts.default.bonus) || null,
			});

			comp.render = function ($parent) {
				$parent.empty();

				const $iptNum = ComponentUiUtil.$getIptInt(this, "num", 0, {$ele: $(`<input class="form-control input-xs form-control--minimal text-center mr-1">`)})
					.appendTo($parent)
					.keydown(evt => {
						if (evt.key === "Escape") { $iptNum.blur(); return; }
						// return key
						if (evt.which === 13) doClose(true);
						evt.stopPropagation();
					});
				const $selFaces = ComponentUiUtil.$getSelEnum(this, "faces", {values: Renderer.dice.DICE})
					.addClass("mr-2").addClass("text-center").css("textAlignLast", "center");

				const $iptBonus = $(`<input class="form-control input-xs form-control--minimal text-center">`)
					.change(() => this._state.bonus = UiUtil.strToInt($iptBonus.val(), null, {fallbackOnNaN: null}))
					.keydown(evt => {
						if (evt.key === "Escape") { $iptBonus.blur(); return; }
						// return key
						if (evt.which === 13) doClose(true);
						evt.stopPropagation();
					});
				const hook = () => $iptBonus.val(this._state.bonus != null ? UiUtil.intToBonus(this._state.bonus) : this._state.bonus);
				comp._addHookBase("bonus", hook);
				hook();

				$$`<div class="flex-vh-center">${$iptNum}<div class="mr-1">d</div>${$selFaces}${$iptBonus}</div>`.appendTo($parent);
			};

			comp.getAsString = function () {
				return `${this._state.num}d${this._state.faces}${this._state.bonus ? UiUtil.intToBonus(this._state.bonus) : ""}`;
			};

			const $btnOk = $(`<button class="btn btn-primary mr-2">OK</button>`)
				.click(() => doClose(true));
			const $btnCancel = $(`<button class="btn btn-default">Cancel</button>`)
				.click(() => doClose(false));
			const $btnSkip = !opts.isSkippable ? null : $(`<button class="btn btn-default ml-3">Skip</button>`)
				.click(() => doClose(VeCt.SYM_UI_SKIP));
			const {$modalInner, doClose} = UiUtil.getShowModal({
				title: opts.title || "Enter Dice",
				isMinHeight0: true,
				cbClose: (isDataEntered) => {
					if (typeof isDataEntered === "symbol") return resolve(isDataEntered);
					if (!isDataEntered) return resolve(null);
					return resolve(comp.getAsString());
				},
			});

			comp.render($modalInner);

			$$`<div class="flex-v-center flex-h-center pb-1 px-1">${$btnOk}${$btnCancel}${$btnSkip}</div>`.appendTo($modalInner);
		});
	}
}

class DragReorderUiUtil {
	/**
	 * Create a draggable pad capable of re-ordering rendered components. This requires to components to have:
	 *  - an `id` getter
	 *  - a `pos` getter and setter
	 *  - a `height` getter
	 *
	 * @param opts Options object.
	 * @param opts.$parent The parent element containing the rendered components.
	 * @param opts.componentsParent The object which has the array of components as a property.
	 * @param opts.componentsProp The property name of the components array.
	 * @param opts.componentId This component ID.
	 * @param [opts.marginSide] The margin side; "r" or "l" (defaults to "l").
	 */
	static $getDragPad (opts) {
		opts = opts || {};

		const getComponentById = (id) => opts.componentsParent[opts.componentsProp].find(it => it.id === id);

		const dragMeta = {};
		const doDragCleanup = () => {
			dragMeta.on = false;
			dragMeta.$wrap.remove();
			dragMeta.$dummies.forEach($d => $d.remove());
			$(document.body).off(`mouseup.drag__stop`);
		};

		const doDragRender = () => {
			if (dragMeta.on) doDragCleanup();

			$(document.body).on(`mouseup.drag__stop`, () => {
				if (dragMeta.on) doDragCleanup();
			});

			dragMeta.on = true;
			dragMeta.$wrap = $(`<div class="flex-col ui-drag__wrp-drag-block"></div>`).appendTo(opts.$parent);
			dragMeta.$dummies = [];

			const ids = opts.componentsParent[opts.componentsProp].map(it => it.id);

			ids.forEach(id => {
				const $dummy = $(`<div class="w-100 ${id === opts.componentId ? "ui-drag__wrp-drag-dummy--highlight" : "ui-drag__wrp-drag-dummy--lowlight"}"></div>`)
					.height(getComponentById(id).height)
					.mouseup(() => {
						if (dragMeta.on) doDragCleanup();
					})
					.appendTo(dragMeta.$wrap);
				dragMeta.$dummies.push($dummy);

				if (id !== opts.componentId) { // on entering other areas, swap positions
					$dummy.mouseenter(() => {
						const cachedPos = getComponentById(id).pos;

						getComponentById(id).pos = getComponentById(opts.componentId).pos;
						getComponentById(opts.componentId).pos = cachedPos;

						doDragRender();
					});
				}
			});
		};

		return $(`<div class="m${opts.marginSide || "l"}-2 ui-drag__patch" title="Drag to Reorder">
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		</div>`).mousedown(() => doDragRender());
	}

	/**
	 * @param $fnGetRow Function which returns a $row element. Is a function instead of a value so it can be lazy-loaded later.
	 * @param opts Options object.
	 * @param opts.$parent
	 * @param opts.swapRowPositions
	 * @param [opts.$children] An array of row elements.
	 * @param [opts.$getChildren] Should return an array as described in the "$children" option.
	 */
	static $getDragPadOpts ($fnGetRow, opts) {
		if (!opts.$parent || !opts.swapRowPositions || (!opts.$children && !opts.$getChildren)) throw new Error("Missing required option(s)!");

		const dragMeta = {};
		const doDragCleanup = () => {
			dragMeta.on = false;
			dragMeta.$wrap.remove();
			dragMeta.$dummies.forEach($d => $d.remove());
			$(document.body).off(`mouseup.drag__stop`);
		};

		const doDragRender = () => {
			if (dragMeta.on) doDragCleanup();

			$(document.body).on(`mouseup.drag__stop`, () => {
				if (dragMeta.on) doDragCleanup();
			});

			dragMeta.on = true;
			dragMeta.$wrap = $(`<div class="flex-col ui-drag__wrp-drag-block"></div>`).appendTo(opts.$parent);
			dragMeta.$dummies = [];

			const $children = opts.$getChildren ? opts.$getChildren() : opts.$children;
			const ixRow = $children.indexOf($fnGetRow());

			$children.forEach(($child, i) => {
				const dimensions = {w: $child.outerWidth(true), h: $child.outerHeight(true)};
				const $dummy = $(`<div class="${i === ixRow ? "ui-drag__wrp-drag-dummy--highlight" : "ui-drag__wrp-drag-dummy--lowlight"}"></div>`)
					.width(dimensions.w).height(dimensions.h)
					.mouseup(() => {
						if (dragMeta.on) doDragCleanup();
					})
					.appendTo(dragMeta.$wrap);
				dragMeta.$dummies.push($dummy);

				if (i !== ixRow) { // on entering other areas, swap positions
					$dummy.mouseenter(() => {
						opts.swapRowPositions(i, ixRow);
						doDragRender();
					});
				}
			});
		};

		return $(`<div class="mr-2 ui-drag__patch" title="Drag to Reorder">
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		<div class="ui-drag__patch-col"><div>&#8729</div><div>&#8729</div><div>&#8729</div></div>
		</div>`).mousedown(() => doDragRender());
	}

	/**
	 * @param $fnGetRow Function which returns a $row element. Is a function instead of a value so it can be lazy-loaded later.
	 * @param $parent Parent elements to attach row elements to. Should have (e.g.) "relative" CSS positioning.
	 * @param parent Parent component which has a pod decomposable as {swapRowPositions, <$children|$getChildren>}.
	 * @return jQuery
	 */
	static $getDragPad2 ($fnGetRow, $parent, parent) {
		const {swapRowPositions, $children, $getChildren} = parent;
		const nxtOpts = {$parent, swapRowPositions, $children, $getChildren};
		return this.$getDragPadOpts($fnGetRow, nxtOpts)
	}
}

class SourceUiUtil {
	static _getValidOptions (options) {
		if (!options) throw new Error(`No options were specified!`);
		if (!options.$parent || !options.cbConfirm || !options.cbConfirmExisting || !options.cbCancel) throw new Error(`Missing options!`);
		options.mode = options.mode || "add";
		return options;
	}

	/**
	 * @param options Options object.
	 * @param options.$parent Parent element.
	 * @param options.cbConfirm Confirmation callback for inputting new sources.
	 * @param options.cbConfirmExisting Confirmation callback for selecting existing sources.
	 * @param options.cbCancel Cancellation callback.
	 * @param options.mode (Optional) Mode to build in, "select", "edit" or "add". Defaults to "select".
	 * @param options.source (Optional) Homebrew source object.
	 * @param options.isRequired (Optional) True if a source must be selected.
	 */
	static render (options) {
		options = SourceUiUtil._getValidOptions(options);
		options.$parent.empty();
		options.mode = options.mode || "select";

		const isEditMode = options.mode === "edit";

		let jsonDirty = false;
		const $iptName = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptName.blur(); })
			.change(() => {
				if (!jsonDirty && !isEditMode) $iptJson.val($iptName.val().replace(/[^-_a-zA-Z]/g, ""));
				$iptName.removeClass("form-control--error");
			});
		if (options.source) $iptName.val(options.source.full);
		const $iptAbv = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptAbv.blur(); })
			.change(() => {
				$iptAbv.removeClass("form-control--error");
			});
		if (options.source) $iptAbv.val(options.source.abbreviation);
		const $iptJson = $(`<input class="form-control ui-source__ipt-named" ${isEditMode ? "disabled" : ""}>`)
			.keydown(evt => { if (evt.key === "Escape") $iptJson.blur(); })
			.change(() => {
				jsonDirty = true;
				$iptJson.removeClass("form-control--error");
			});
		if (options.source) $iptJson.val(options.source.json);
		const $iptUrl = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptUrl.blur(); });
		if (options.source) $iptUrl.val(options.source.url);
		const $iptAuthors = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptAuthors.blur(); });
		if (options.source) $iptAuthors.val((options.source.authors || []).join(", "));
		const $iptConverters = $(`<input class="form-control ui-source__ipt-named">`)
			.keydown(evt => { if (evt.key === "Escape") $iptConverters.blur(); });
		if (options.source) $iptConverters.val((options.source.convertedBy || []).join(", "));

		const $btnOk = $(`<button class="btn btn-primary">OK</button>`)
			.click(() => {
				let incomplete = false;
				[$iptName, $iptAbv, $iptJson].forEach($ipt => {
					const val = $ipt.val();
					if (!val || !val.trim()) (incomplete = true) && $ipt.addClass("form-control--error");
				});
				if (incomplete) return;

				const jsonVal = $iptJson.val().trim();
				if (!isEditMode && BrewUtil.hasSourceJson(jsonVal)) {
					$iptJson.addClass("form-control--error");
					JqueryUtil.doToast({content: `The JSON identifier "${jsonVal}" already exists!`, type: "danger"});
					return;
				}

				const source = {
					json: jsonVal,
					abbreviation: $iptAbv.val().trim(),
					full: $iptName.val().trim(),
					url: $iptUrl.val().trim(),
					authors: $iptAuthors.val().trim().split(",").map(it => it.trim()).filter(Boolean),
					convertedBy: $iptConverters.val().trim().split(",").map(it => it.trim()).filter(Boolean),
				};

				options.cbConfirm(source, options.mode !== "edit");
			});

		const $btnCancel = options.isRequired && !isEditMode
			? null
			: $(`<button class="btn btn-default ml-2">Cancel</button>`).click(() => options.cbCancel());

		const $btnUseExisting = $(`<button class="btn btn-default">Use an Existing Source</button>`)
			.click(() => {
				$stageInitial.hideVe();
				$stageExisting.showVe();

				// cleanup
				[$iptName, $iptAbv, $iptJson].forEach($ipt => $ipt.removeClass("form-control--error"));
			});

		const $stageInitial = $$`<div class="h-100 w-100 flex-vh-center"><div class="flex-col">
			<h3 class="text-center">${isEditMode ? "Edit Homebrew Source" : "Add a Homebrew Source"}</h3>
			<div class="ui-source__row mb-2"><div class="col-12 flex-v-center">
				<span class="mr-2 ui-source__name help" title="The name or title for the homebrew you wish to create. This could be the name of a book or PDF; for example, 'Monster Manual'">Title</span>
				${$iptName}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 flex-v-center">
				<span class="mr-2 ui-source__name help" title="An abbreviated form of the title. This will be shown in lists on the site, and in the top-right corner of statblocks or data entries; for example, 'MM'">Abbreviation</span>
				${$iptAbv}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 flex-v-center">
				<span class="mr-2 ui-source__name help" title="This will be used to identify your homebrew universally, so should be unique to you and you alone">JSON Identifier</span>
				${$iptJson}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 flex-v-center">
				<span class="mr-2 ui-source__name help" title="A link to the original homebrew, e.g. a GM Binder page">Source URL</span>
				${$iptUrl}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 flex-v-center">
				<span class="mr-2 ui-source__name help" title="A comma-separated list of authors, e.g. 'John Doe, Joe Bloggs'">Author(s)</span>
				${$iptAuthors}
			</div></div>
			<div class="ui-source__row mb-2"><div class="col-12 flex-v-center">
				<span class="mr-2 ui-source__name help" title="A comma-separated list of people who converted the homebrew to 5etools' format, e.g. 'John Doe, Joe Bloggs'">Converted By</span>
				${$iptConverters}
			</div></div>
			<div class="text-center mb-2">${$btnOk}${$btnCancel}</div>

			${!isEditMode && BrewUtil.homebrewMeta.sources && BrewUtil.homebrewMeta.sources.length ? $$`<div class="flex-vh-center mb-3 mt-3"><span class="ui-source__divider"></span>or<span class="ui-source__divider"></span></div>
			<div class="flex-vh-center">${$btnUseExisting}</div>` : ""}
		</div></div>`.appendTo(options.$parent);

		const $selExisting = $$`<select class="form-control input-sm">
			<option disabled>Select</option>
			${(BrewUtil.homebrewMeta.sources || []).sort((a, b) => SortUtil.ascSortLower(a.full, b.full)).map(s => `<option value="${s.json.escapeQuotes()}">${s.full.escapeQuotes()}</option>`)}
		</select>`.change(() => $selExisting.removeClass("form-control--error"));
		$selExisting[0].selectedIndex = 0;

		const $btnConfirmExisting = $(`<button class="btn btn-default btn-sm">Confirm</button>`)
			.click(() => {
				if ($selExisting[0].selectedIndex !== 0) {
					const sourceJson = $selExisting.val();
					const source = BrewUtil.sourceJsonToSource(sourceJson);
					options.cbConfirmExisting(source);

					// cleanup
					$selExisting[0].selectedIndex = 0;
					$stageExisting.hideVe();
					$stageInitial.showVe();
				} else $selExisting.addClass("form-control--error");
			});

		const $btnBackExisting = $(`<button class="btn btn-default btn-sm mr-2">Back</button>`)
			.click(() => {
				$selExisting[0].selectedIndex = 0;
				$stageExisting.hideVe();
				$stageInitial.showVe();
			});

		const $stageExisting = $$`<div class="h-100 w-100 flex-vh-center ve-hidden"><div>
			<h3 class="text-center">Select a Homebrew Source</h3>
			<div class="mb-2"><div class="col-12 flex-vh-center">${$selExisting}</div></div>
			<div class="col-12 flex-vh-center">${$btnBackExisting}${$btnConfirmExisting}</div>
		</div></div>`.appendTo(options.$parent);
	}
}

class BaseComponent extends ProxyBase {
	constructor () {
		super();

		this.__locks = {};
		this.__rendered = {};

		// state
		this.__state = {...this._getDefaultState()};
		this._state = this._getProxy("state", this.__state);
	}

	_addHookBase (prop, hook) {
		return this._addHook("state", prop, hook);
	}

	_removeHookBase (prop, hook) {
		return this._removeHook("state", prop, hook);
	}

	_removeHooksBase (prop) {
		return this._removeHooks("state", prop);
	}

	_setState (toState) {
		this._proxyAssign("state", "_state", "__state", toState, true);
	}

	_getState () { return MiscUtil.copy(this.__state) }

	getPod () {
		this.__pod = this.__pod || {
			get: (prop) => this._state[prop],
			set: (prop, val) => this._state[prop] = val,
			delete: (prop) => delete this._state[prop],
			addHook: (prop, hook) => this._addHookBase(prop, hook),
			addHookAll: (hook) => this._addHookAll("state", hook),
			removeHook: (prop, hook) => this._removeHookBase(prop, hook),
			triggerCollectionUpdate: (prop) => this._triggerCollectionUpdate(prop),
			setState: (state) => this._setState(state),
			getState: () => this._getState(),
			assign: (toObj, isOverwrite) => this._proxyAssign("state", "_state", "__state", toObj, isOverwrite),
			pLock: lockName => this._pLock(lockName),
			unlock: lockName => this._unlock(lockName),
			component: this,
		};
		return this.__pod;
	}

	// to be overridden as required
	_getDefaultState () { return {}; }

	getBaseSaveableState () {
		return {
			state: MiscUtil.copy(this.__state),
		};
	}

	setBaseSaveableStateFrom (toLoad, isOverwrite = false) {
		toLoad.state && this._proxyAssignSimple("state", toLoad.state, isOverwrite);
	}

	/**
	 * @param opts Options object.
	 * @param opts.prop The state property.
	 * @param [opts.namespace] The render namespace.
	 */
	_getRenderedCollection (opts) {
		opts = opts || {};
		const renderedLookupProp = opts.namespace ? `${opts.namespace}.${opts.prop}` : opts.prop;
		return (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
	}

	/**
	 * Asynchronous version available below.
	 * @param opts Options object.
	 * @param opts.prop The state property.
	 * @param [opts.fnDeleteExisting] Function to run on deleted render meta. Arguments are `rendered, item`.
	 * @param [opts.fnReorderExisting] Function to run on all meta, as a final step. Useful for re-ordering elements.
	 * @param opts.fnUpdateExisting Function to run on existing render meta. Arguments are `rendered, item`.
	 * @param opts.fnGetNew Function to run which generates existing render meta. Arguments are `item`.
	 * @param [opts.isDiffMode] If a diff of the state should be taken/checked before updating renders.
	 * @param [opts.namespace] A namespace to store these renders under. Useful if multiple renders are being made from
	 *        the same collection.
	 */
	_renderCollection (opts) {
		opts = opts || {};

		const rendered = this._getRenderedCollection(opts);
		const toDelete = new Set(Object.keys(rendered));

		(this._state[opts.prop] || []).forEach((it, i) => {
			if (it.id == null) throw new Error(`Collection item did not have an ID!`);
			const meta = rendered[it.id];

			toDelete.delete(it.id);
			if (meta) {
				if (opts.isDiffMode) {
					// Hashing the stringified JSON relies on the property order remaining consistent, but this is fine
					const nxtHash = CryptUtil.md5(JSON.stringify(it));
					if (nxtHash !== meta.__hash) {
						meta.__hash = nxtHash;
					} else return;
				}

				meta.data = it; // update any existing pointers
				opts.fnUpdateExisting(meta, it, i);
			} else {
				const meta = opts.fnGetNew(it, i);

				// If the "get new" function returns null, skip rendering this entity
				if (meta == null) return;

				meta.data = it;
				if (!meta.$wrpRow) throw new Error(`A "$wrpRow" property is required in order for deletes!`);

				if (opts.isDiffMode) meta.hash = CryptUtil.md5(JSON.stringify(it));

				rendered[it.id] = meta;
			}
		});

		toDelete.forEach(id => {
			const meta = rendered[id];
			meta.$wrpRow.remove();
			delete rendered[id];
			if (opts.fnDeleteExisting) opts.fnDeleteExisting(meta);
		});

		if (opts.fnReorderExisting) {
			(this._state[opts.prop] || []).forEach((it, i) => {
				const meta = rendered[it.id];
				opts.fnReorderExisting(meta, it, i);
			});
		}
	}

	/**
	 * Synchronous version available above.
	 * @param [opts] Options object.
	 * @param opts.prop The state property.
	 * @param [opts.pFnDeleteExisting] Function to run on deleted render meta. Arguments are `rendered, item`.
	 * @param opts.pFnUpdateExisting Function to run on existing render meta. Arguments are `rendered, item`.
	 * @param opts.pFnGetNew Function to run which generates existing render meta. Arguments are `item`.
	 * @param [opts.isDiffMode] If updates should be run in "diff" mode (i.e. no update is run if nothing has changed).
	 * @param [opts.isMultiRender] If multiple renders will be produced.
	 * @param [opts.additionalCaches] Additional cache objects to be cleared on entity delete. Should be objects with
	 *        entity IDs as keys.
	 * @param [opts.namespace] A namespace to store these renders under. Useful if multiple renders are being made from
	 *        the same collection.
	 */
	async _pRenderCollection (opts) {
		opts = opts || {};

		const rendered = this._getRenderedCollection(opts);
		const entities = this._state[opts.prop];
		return this._pRenderCollection_doRender(rendered, entities, opts);
	}

	async _pRenderCollection_doRender (rendered, entities, opts) {
		opts = opts || {};

		const toDelete = new Set(Object.keys(rendered));

		// Run the external functions in serial, to prevent element re-ordering
		for (let i = 0; i < entities.length; ++i) {
			const it = entities[i];

			if (!it.id) throw new Error(`Collection item did not have an ID!`);
			// N.B.: Meta can be an array, if one item maps to multiple renders (e.g. the same is shown in two places)
			const meta = rendered[it.id];

			toDelete.delete(it.id);
			if (meta) {
				if (opts.isDiffMode) {
					// Hashing the stringified JSON relies on the property order remaining consistent, but this is fine
					const nxtHash = CryptUtil.md5(JSON.stringify(it));
					if (nxtHash !== meta.__hash) meta.__hash = nxtHash;
					else continue;
				}

				const nxtMeta = await opts.pFnUpdateExisting(meta, it);
				// Overwrite the existing renders in multi-render mode
				//    Otherwise, just ignore the result--single renders never modify their render
				if (opts.isMultiRender) rendered[it.id] = nxtMeta;
			} else {
				const meta = await opts.pFnGetNew(it);
				// If the generator decides there's nothing to render, skip this item
				if (meta == null) continue;

				if (opts.isMultiRender && meta.some(it => !it.$wrpRow)) throw new Error(`A "$wrpRow" property is required in order for deletes!`);
				if (!opts.isMultiRender && !meta.$wrpRow) throw new Error(`A "$wrpRow" property is required in order for deletes!`);

				if (opts.isDiffMode) meta.__hash = CryptUtil.md5(JSON.stringify(it));

				rendered[it.id] = meta;
			}
		}

		for (const id of toDelete) {
			const meta = rendered[id];
			if (opts.isMultiRender) meta.forEach(it => it.$wrpRow.remove());
			else meta.$wrpRow.remove();
			if (opts.additionalCaches) opts.additionalCaches.forEach(it => delete it[id]);
			delete rendered[id];
			if (opts.pFnDeleteExisting) await opts.pFnDeleteExisting(meta);
		}
	}

	/**
	 * Detach (and thus preserve) rendered collection elements so they can be re-used later.
	 * @param prop The state property.
	 * @param [namespace] A namespace to store these renders under. Useful if multiple renders are being made from
	 *        the same collection.
	 */
	_detachCollection (prop, namespace = null) {
		const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
		const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
		Object.values(rendered).forEach(it => it.$wrpRow.detach());
	}

	/**
	 * Wipe any rendered collection elements, and reset the render cache.
	 * @param prop The state property.
	 * @param [namespace] A namespace to store these renders under. Useful if multiple renders are being made from
	 *        the same collection.
	 */
	_resetCollectionRenders (prop, namespace = null) {
		const renderedLookupProp = namespace ? `${namespace}.${prop}` : prop;
		const rendered = (this.__rendered[renderedLookupProp] = this.__rendered[renderedLookupProp] || {});
		Object.values(rendered).forEach(it => it.$wrpRow.remove());
		delete this.__rendered[renderedLookupProp];
	}

	render () { throw new Error("Unimplemented!"); }

	// to be overridden as required
	getSaveableState () { return {...this.getBaseSaveableState()}; }
	setStateFrom (toLoad, isOverwrite = false) { this.setBaseSaveableStateFrom(toLoad, isOverwrite); }

	async _pLock (lockName) {
		while (this.__locks[lockName]) await this.__locks[lockName].lock;
		let unlock = null;
		const lock = new Promise(resolve => unlock = resolve);
		this.__locks[lockName] = {
			lock,
			unlock,
		}
	}

	async _pGate (lockName) {
		while (this.__locks[lockName]) await this.__locks[lockName].lock;
	}

	_unlock (lockName) {
		const lockMeta = this.__locks[lockName];
		if (lockMeta) {
			delete this.__locks[lockName];
			lockMeta.unlock();
		}
	}

	async _pDoProxySetBase (prop, value) { return this._pDoProxySet("state", this.__state, prop, value); }

	_triggerCollectionUpdate (prop) {
		if (!this._state[prop]) return;
		this._state[prop] = [...this._state[prop]];
	}

	static _toCollection (array) {
		if (array) return array.map(it => ({id: CryptUtil.uid(), entity: it}));
	}

	static _fromCollection (array) {
		if (array) return array.map(it => it.entity);
	}

	static fromObject (obj, ...noModCollections) {
		const comp = new this();
		Object.entries(MiscUtil.copy(obj)).forEach(([k, v]) => {
			if (v == null) comp.__state[k] = v;
			else if (noModCollections.includes(k) || noModCollections.includes("*")) comp.__state[k] = v;
			else if (typeof v === "object" && v instanceof Array) comp.__state[k] = BaseComponent._toCollection(v);
			else comp.__state[k] = v;
		});
		return comp;
	}

	static fromObjectNoMod (obj) { return this.fromObject(obj, "*"); }

	toObject (...noModCollections) {
		const cpy = MiscUtil.copy(this.__state);
		Object.entries(cpy).forEach(([k, v]) => {
			if (v == null) return;

			if (noModCollections.includes(k) || noModCollections.includes("*")) cpy[k] = v;
			else if (v instanceof Array && v.every(it => it && it.id)) cpy[k] = BaseComponent._fromCollection(v);
		});
		return cpy;
	}

	toObjectNoMod () { return this.toObject("*"); }
}

class RenderableCollectionBase {
	/**
	 * @param comp
	 * @param prop
	 * @param [opts]
	 * @param [opts.namespace]
	 * @param [opts.isDiffMode]
	 */
	constructor (comp, prop, opts) {
		opts = opts || {};
		this._comp = comp;
		this._prop = prop;
		this._namespace = opts.namespace;
		this._isDiffMode = opts.isDiffMode;
	}

	getNewRender (entity, i) {
		throw new Error(`Unimplemented!`);
	}

	doUpdateExistingRender (renderedMeta, entity, i) {
		throw new Error(`Unimplemented!`);
	}

	doDeleteExistingRender (renderedMeta) {
		// No-op
	}

	doReorderExistingComponent (renderedMeta, entity, i) {
		// No-op
	}

	/**
	 * @param [opts] Temporary override options.
	 * @param [opts.isDiffMode]
	 */
	render (opts) {
		opts = opts || {};
		this._comp._renderCollection({
			prop: this._prop,
			fnUpdateExisting: (rendered, ent, i) => this.doUpdateExistingRender(rendered, ent, i),
			fnGetNew: (entity, i) => this.getNewRender(entity, i),
			fnDeleteExisting: (rendered) => this.doDeleteExistingRender(rendered),
			fnReorderExisting: (rendered, ent, i) => this.doReorderExistingComponent(rendered, ent, i),
			namespace: this._namespace,
			isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
		});
	}
}

class RenderableCollectionAsyncBase {
	/**
	 * @param comp
	 * @param prop
	 * @param [opts]
	 * @param [opts.namespace]
	 * @param [opts.isDiffMode]
	 * @param [opts.isMultiRender]
	 * @param [opts.additionalCaches]
	 */
	constructor (comp, prop, opts) {
		opts = opts || {};
		this._comp = comp;
		this._prop = prop;
		this._namespace = opts.namespace;
		this._isDiffMode = opts.isDiffMode;
		this._isMultiRender = opts.isMultiRender;
		this._additionalCaches = opts.additionalCaches;
	}

	pGetNewRender (entity, i) {
		throw new Error(`Unimplemented!`);
	}

	pDoUpdateExistingRender (renderedMeta, entity, i) {
		throw new Error(`Unimplemented!`);
	}

	/**
	 * @param [opts] Temporary override options.
	 * @param [opts.isDiffMode]
	 */
	render (opts) {
		opts = opts || {};
		this._comp._pRenderCollection({
			prop: this._prop,
			fnUpdateExisting: (rendered, source, i) => this.pGetNewRender(rendered, source, i),
			fnGetNew: (entity, i) => this.pDoUpdateExistingRender(entity, i),
			namespace: this._namespace,
			isDiffMode: opts.isDiffMode != null ? opts.isDiffMode : this._isDiffMode,
			isMultiRender: this._isMultiRender,
			additionalCaches: this._additionalCaches,
		});
	}
}

class BaseLayeredComponent extends BaseComponent {
	constructor () {
		super();

		// layers
		this._layers = [];
		this.__layerMeta = {};
		this._layerMeta = this._getProxy("layerMeta", this.__layerMeta);
	}

	_addHookDeep (prop, hook) {
		this._addHookBase(prop, hook);
		this._addHook("layerMeta", prop, hook);
	}

	_removeHookDeep (prop, hook) {
		this._removeHookBase(prop, hook);
		this._removeHook("layerMeta", prop, hook);
	}

	_getBase (prop) {
		return this._state[prop];
	}

	_get (prop) {
		if (this._layerMeta[prop]) {
			for (let i = this._layers.length - 1; i >= 0; --i) {
				const val = this._layers[i].data[prop];
				if (val != null) return val;
			}
			// this should never fall through, but if it does, returning the base value is fine
		}
		return this._state[prop];
	}

	_addLayer (layer) {
		this._layers.push(layer);
		this._addLayer_addLayerMeta(layer);
	}

	_addLayer_addLayerMeta (layer) {
		Object.entries(layer.data).forEach(([k, v]) => this._layerMeta[k] = v != null);
	}

	_removeLayer (layer) {
		const ix = this._layers.indexOf(layer);
		if (~ix) {
			this._layers.splice(ix, 1);

			// regenerate layer meta
			Object.keys(this._layerMeta).forEach(k => delete this._layerMeta[k]);
			this._layers.forEach(l => this._addLayer_addLayerMeta(l));
		}
	}

	updateLayersActive (prop) {
		// this uses the fact that updating a proxy value to the same value still triggers hooks
		//   anything listening to changes in this flag will be forced to recalculate from base + all layers
		this._layerMeta[prop] = this._layers.some(l => l.data[prop] != null);
	}

	getBaseSaveableState () {
		return {
			state: MiscUtil.copy(this.__state),
			layers: MiscUtil.copy(this._layers.map(l => l.getSaveableState())),
		};
	}

	setBaseSaveableStateFrom (toLoad) {
		toLoad.state && Object.assign(this._state, toLoad.state);
		if (toLoad.layers) toLoad.layers.forEach(l => this._addLayer(CompLayer.fromSavedState(this, l)));
	}

	getPod () {
		this.__pod = this.__pod || {
			...super.getPod(),

			addHookDeep: (prop, hook) => this._addHookDeep(prop, hook),
			removeHookDeep: (prop, hook) => this._removeHookDeep(prop, hook),
			addHookAll: (hook) => this._addHookAll("state", hook),
			getBase: (prop) => this._getBase(prop),
			get: (prop) => this._get(prop),
			addLayer: (name, data) => {
				// FIXME
				const l = new CompLayer(this, name, data);
				this._addLayer(l);
				return l;
			},
			removeLayer: (layer) => this._removeLayer(layer),
			layers: this._layers, // FIXME avoid passing this directly to the child
		};
		return this.__pod;
	}
}

/**
 * A "layer" of state which is applied over the base state.
 *  This allows e.g. a temporary stat reduction to modify a statblock, without actually
 *  modifying the underlying component.
 */
class CompLayer extends ProxyBase {
	constructor (component, layerName, data) {
		super();

		this._name = layerName;
		this.__data = data;

		this.data = this._getProxy("data", this.__data);

		this._addHookAll("data", prop => component.updateLayersActive(prop));
	}

	getSaveableState () {
		return {
			name: this._name,
			data: MiscUtil.copy(this.__data),
		}
	}

	static fromSavedState (component, savedState) { return new CompLayer(component, savedState.name, savedState.data); }
}

const MixinComponentHistory = compClass => class extends compClass {
	constructor () {
		super(...arguments);
		this._histStackUndo = [];
		this._histStackRedo = [];
		this._isHistDisabled = true;
		this._histPropBlacklist = new Set();
		this._histPropWhitelist = null;

		this._histInitialState = null;
	}

	set isHistDisabled (val) { this._isHistDisabled = val; }
	addBlacklistProps (...props) { props.forEach(p => this._histPropBlacklist.add(p)); }
	addWhitelistProps (...props) {
		this._histPropWhitelist = this._histPropWhitelist || new Set();
		props.forEach(p => this._histPropWhitelist.add(p));
	}

	/**
	 * This should be initialised after all other hooks have been added
	 */
	initHistory () {
		// Track the initial state, and watch for further modifications
		this._histInitialState = MiscUtil.copy(this._state);
		this._isHistDisabled = false;

		this._addHookAll("state", prop => {
			if (this._isHistDisabled) return;
			if (this._histPropBlacklist.has(prop)) return;
			if (this._histPropWhitelist && !this._histPropWhitelist.has(prop)) return;

			this.recordHistory();
		});
	}

	recordHistory () {
		const stateCopy = MiscUtil.copy(this._state);

		// remove any un-tracked properties
		this._histPropBlacklist.forEach(prop => delete stateCopy[prop]);
		if (this._histPropWhitelist) Object.keys(stateCopy).filter(k => !this._histPropWhitelist.has(k)).forEach(k => delete stateCopy[k]);

		this._histStackUndo.push(stateCopy);
		this._histStackRedo = [];
	}

	_histAddExcludedProperties (stateCopy) {
		Object.entries(this._state).forEach(([k, v]) => {
			if (this._histPropBlacklist.has(k)) return stateCopy[k] = v;
			if (this._histPropWhitelist && !this._histPropWhitelist.has(k)) stateCopy[k] = v
		});
	}

	undo () {
		if (this._histStackUndo.length) {
			const lastHistDisabled = this._isHistDisabled;
			this._isHistDisabled = true;

			const curState = this._histStackUndo.pop();
			this._histStackRedo.push(curState);
			const toApply = MiscUtil.copy(this._histStackUndo.last() || this._histInitialState);
			this._histAddExcludedProperties(toApply);
			this._setState(toApply);

			this._isHistDisabled = lastHistDisabled;
		} else {
			const lastHistDisabled = this._isHistDisabled;
			this._isHistDisabled = true;

			const toApply = MiscUtil.copy(this._histInitialState);
			this._histAddExcludedProperties(toApply);
			this._setState(toApply);

			this._isHistDisabled = lastHistDisabled;
		}
	}

	redo () {
		if (!this._histStackRedo.length) return;

		const lastHistDisabled = this._isHistDisabled;
		this._isHistDisabled = true;

		const toApplyRaw = this._histStackRedo.pop();
		this._histStackUndo.push(toApplyRaw);
		const toApply = MiscUtil.copy(toApplyRaw);
		this._histAddExcludedProperties(toApply);
		this._setState(toApply);

		this._isHistDisabled = lastHistDisabled;
	}
};

// region Globally-linked state components
const MixinComponentGlobalState = compClass => class extends compClass {
	constructor () {
		super(...arguments);

		// Point our proxy at the singleton `__stateGlobal` object
		this._stateGlobal = this._getProxy("stateGlobal", MixinComponentGlobalState._Singleton.__stateGlobal);

		// Load the singleton's state, then fire all our hooks once it's ready
		MixinComponentGlobalState._Singleton._pLoadState()
			.then(() => {
				this._doFireHooksAll("stateGlobal");
				this._doFireAllHooks("stateGlobal");
				this._addHookAll("stateGlobal", MixinComponentGlobalState._Singleton._pSaveStateDebounced);
			});
	}

	get __stateGlobal () { return MixinComponentGlobalState._Singleton.__stateGlobal; }

	_addHookGlobal (prop, hook) {
		return this._addHook("stateGlobal", prop, hook);
	}
};

MixinComponentGlobalState._Singleton = class {
	static async _pSaveState () {
		return StorageUtil.pSet(VeCt.STORAGE_GLOBAL_COMPONENT_STATE, MiscUtil.copy(MixinComponentGlobalState._Singleton.__stateGlobal));
	}

	static async _pLoadState () {
		if (MixinComponentGlobalState._Singleton._pLoadingState) return MixinComponentGlobalState._Singleton._pLoadingState;
		return MixinComponentGlobalState._Singleton._pLoadingState = MixinComponentGlobalState._Singleton._pLoadState_();
	}

	static async _pLoadState_ () {
		Object.assign(MixinComponentGlobalState._Singleton.__stateGlobal, (await StorageUtil.pGet(VeCt.STORAGE_GLOBAL_COMPONENT_STATE)) || {});
	}

	static _getDefaultStateGlobal () {
		return {
			isUseSpellPoints: false,
		};
	}
}
MixinComponentGlobalState._Singleton.__stateGlobal = {...MixinComponentGlobalState._Singleton._getDefaultStateGlobal()};
MixinComponentGlobalState._Singleton._pSaveStateDebounced = MiscUtil.debounce(MixinComponentGlobalState._Singleton._pSaveState.bind(MixinComponentGlobalState._Singleton), 100);
MixinComponentGlobalState._Singleton._pLoadingState = null;

// endregion

class ComponentUiUtil {
	static trackHook (hooks, prop, hook) {
		hooks[prop] = hooks[prop] || [];
		hooks[prop].push(hook);
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.offset] Offset to add to value displayed.
	 * @param [opts.padLength] Number of digits to pad the number to.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 * @param [opts.isAllowNull] If an empty input should be treated as null.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the checkbox.
	 * @param [opts.hookTracker] Object in which to track hook.
	 * @param [opts.decorationLeft] Decoration to be added to the left-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.decorationRight] Decoration to be added to the right-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @return {JQuery}
	 */
	static $getIptInt (component, prop, fallbackEmpty = 0, opts) {
		return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil.strToInt, fallbackEmpty, opts);
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [fallbackEmpty] Fallback number if string is empty.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.max] Max allowed return value.
	 * @param [opts.min] Min allowed return value.
	 * @param [opts.offset] Offset to add to value displayed.
	 * @param [opts.padLength] Number of digits to pad the number to.
	 * @param [opts.fallbackOnNaN] Return value if not a number.
	 * @param [opts.isAllowNull] If an empty input should be treated as null.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the checkbox.
	 * @param [opts.decorationLeft] Decoration to be added to the left-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.decorationRight] Decoration to be added to the right-hand-side of the input. Can be `"ticker"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @return {JQuery}
	 */
	static $getIptNumber (component, prop, fallbackEmpty = 0, opts) {
		return ComponentUiUtil._$getIptNumeric(component, prop, UiUtil.strToNumber, fallbackEmpty, opts);
	}

	static _$getIptNumeric (component, prop, fnConvert, fallbackEmpty = 0, opts) {
		opts = opts || {};
		opts.offset = opts.offset || 0;

		const setIptVal = () => {
			if (opts.isAllowNull && component._state[prop] == null) {
				return $ipt.val(null);
			}

			const num = (component._state[prop] || 0) + opts.offset;
			const val = opts.padLength ? `${num}`.padStart(opts.padLength, "0") : num;
			$ipt.val(val);
		};

		const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal text-right">`)).disableSpellcheck()
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.change(() => {
				const raw = $ipt.val().trim();
				const cur = component._state[prop];

				if (opts.isAllowNull && !raw) return component._state[prop] = null;

				if (raw.startsWith("=")) {
					// if it starts with "=", force-set to the value provided
					component._state[prop] = fnConvert(raw.slice(1), fallbackEmpty, opts) - opts.offset;
				} else {
					// otherwise, try to modify the previous value
					const mUnary = prevValue != null && prevValue < 0
						? /^[+/*^]/.exec(raw) // If the previous value was `-X`, then treat minuses as normal values
						: /^[-+/*^]/.exec(raw);
					if (mUnary) {
						let proc = raw;
						proc = proc.slice(1).trim();
						const mod = fnConvert(proc, fallbackEmpty, opts);
						const full = `${cur}${mUnary[0]}${mod}`;
						component._state[prop] = fnConvert(full, fallbackEmpty, opts) - opts.offset;
					} else {
						component._state[prop] = fnConvert(raw, fallbackEmpty, opts) - opts.offset;
					}
				}

				// Ensure the input visually reflects the state
				if (cur === component._state[prop]) setIptVal();
			});

		let prevValue;
		const hook = () => {
			prevValue = component._state[prop];
			setIptVal();
		};
		if (opts.hookTracker) ComponentUiUtil.trackHook(opts.hookTracker, prop, hook);
		component._addHookBase(prop, hook);
		hook();

		if (opts.asMeta) return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
		else return $ipt;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.isNoTrim] If the text should not be trimmed.
	 * @param [opts.isAllowNull] If null should be allowed (and preferred) for empty inputs
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the checkbox.
	 * @param [opts.autocomplete] Array of autocomplete strings. REQUIRES INCLUSION OF THE TYPEAHEAD LIBRARY.
	 * @param [opts.decorationLeft] Decoration to be added to the left-hand-side of the input. Can be `"search"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.decorationRight] Decoration to be added to the right-hand-side of the input. Can be `"search"` or `"clear"`. REQUIRES `asMeta` TO BE SET.
	 * @param [opts.placeholder] Placeholder for the input.
	 */
	static $getIptStr (component, prop, opts) {
		opts = opts || {};

		// Validate options
		if ((opts.decorationLeft || opts.decorationRight) && !opts.asMeta) throw new Error(`Input must be created with "asMeta" option`);

		const $ipt = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.disableSpellcheck();
		UiUtil.bindTypingEnd({
			$ipt,
			fnKeyup: () => {
				const nxtVal = opts.isNoTrim ? $ipt.val() : $ipt.val().trim();
				component._state[prop] = opts.isAllowNull && !nxtVal ? null : nxtVal;
			},
		});

		if (opts.placeholder) $ipt.attr("placeholder", opts.placeholder);

		if (opts.autocomplete && opts.autocomplete.length) $ipt.typeahead({source: opts.autocomplete});
		const hook = () => {
			if (component._state[prop] == null) $ipt.val(null);
			else {
				// If the only difference is start/end whitespace, leave it; otherwise, adding spaces is frustrating
				if ($ipt.val().trim() !== component._state[prop]) $ipt.val(component._state[prop]);
			}
		};
		component._addHookBase(prop, hook);
		hook();

		if (opts.asMeta) return this._getIptDecoratedMeta(component, prop, $ipt, hook, opts);
		else return $ipt;
	}

	static _getIptDecoratedMeta (component, prop, $ipt, hook, opts) {
		const out = {$ipt, unhook: () => component._removeHookBase(prop, hook)};

		if (opts.decorationLeft || opts.decorationRight) {
			let $decorLeft;
			let $decorRight;

			if (opts.decorationLeft) {
				$ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--left`);
				$decorLeft = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationLeft, "left", opts);
			}

			if (opts.decorationRight) {
				$ipt.addClass(`ui-ideco__ipt ui-ideco__ipt--right`);
				$decorRight = ComponentUiUtil._$getDecor(component, prop, $ipt, opts.decorationRight, "right", opts);
			}

			out.$wrp = $$`<div class="relative w-100">${$ipt}${$decorLeft}${$decorRight}</div>`
		}

		return out;
	}

	static _$getDecor (component, prop, $ipt, decorType, side, opts) {
		switch (decorType) {
			case "search": {
				return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} no-events flex-vh-center"><span class="glyphicon glyphicon-search"></span></div>`);
			}
			case "clear": {
				return $(`<div class="ui-ideco__wrp ui-ideco__wrp--${side} flex-vh-center clickable" title="Clear"><span class="glyphicon glyphicon-remove"></span></div>`)
					.click(() => $ipt.val("").change().keydown().keyup());
			}
			case "ticker": {
				const isValidValue = val => {
					if (opts.max != null && val > opts.max) return false;
					if (opts.min != null && val < opts.min) return false;
					return true;
				};

				const handleClick = (delta) => {
					// TODO(future) this should be run first to evaluate any lingering expressions in the input, but it
					//  breaks when the number is negative, as we need to add a "=" to the front of the input before
					//  evaluating
					// $ipt.change();
					const nxt = component._state[prop] + delta;
					if (!isValidValue(nxt)) return;
					component._state[prop] = nxt;
					$ipt.focus();
				};

				const $btnUp = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">+</button>`)
					.click(() => handleClick(1));

				const $btnDown = $(`<button class="btn btn-default ui-ideco__btn-ticker bold no-select">\u2012</button>`)
					.click(() => handleClick(-1));

				return $$`<div class="ui-ideco__wrp ui-ideco__wrp--${side} flex-vh-center flex-col">
					${$btnUp}
					${$btnDown}
				</div>`;
			}
			case "spacer": {
				return "";
			}
			default: throw new Error(`Unimplemented!`);
		}
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @return {$}
	 */
	static $getIptEntries (component, prop, opts) {
		opts = opts || {};

		const $ipt = (opts.$ele || $(`<textarea class="form-control input-xs form-control--minimal resize-vertical"></textarea>`))
			.keydown(evt => { if (evt.key === "Escape") $ipt.blur(); })
			.change(() => component._state[prop] = UiUtil.getTextAsEntries($ipt.val().trim()));
		const hook = () => $ipt.val(UiUtil.getEntriesAsText(component._state[prop]));
		component._addHookBase(prop, hook);
		hook();
		return $ipt;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @return {JQuery}
	 */
	static $getIptColor (component, prop, opts) {
		opts = opts || {};

		const $ipt = (opts.$ele || $(`<input class="form-control input-xs form-control--minimal ui__ipt-color" type="color">`))
			.change(() => component._state[prop] = $ipt.val());
		const hook = () => $ipt.val(component._state[prop]);
		component._addHookBase(prop, hook);
		hook();
		return $ipt;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.text] Button text, if element is not specified.
	 * @param [opts.fnHookPost] Function to run after primary hook.
	 * @param [opts.stateName] State name.
	 * @param [opts.stateProp] State prop.
	 * @param [opts.isInverted] If the toggle display should be inverted.
	 * @param [opts.activeClass] CSS class to use when setting the button as "active."
	 * @param [opts.title]
	 * @param [opts.activeTitle] Title to use when setting the button as "active."
	 * @param [opts.inactiveTitle] Title to use when setting the button as "active."
	 * @return *
	 */
	static getBtnBool (component, prop, opts) {
		opts = opts || {};

		let ele = opts.ele;
		if (opts.html) ele = e_({outer: opts.html});

		const activeClass = opts.activeClass || "active";
		const stateName = opts.stateName || "state";
		const stateProp = opts.stateProp || "_state";

		const btn = (ele ? e_({ele}) : e_({
			ele: ele,
			tag: "button",
			clazz: "btn btn-xs btn-default",
			text: opts.text || "Toggle",
		}))
			.onClick(() => component[stateProp][prop] = !component[stateProp][prop])
			.onContextmenu(evt => {
				evt.preventDefault();
				component[stateProp][prop] = !component[stateProp][prop];
			});

		const hk = () => {
			btn.toggleClass(activeClass, opts.isInverted ? !component[stateProp][prop] : !!component[stateProp][prop]);
			if (opts.activeTitle || opts.inactiveTitle) btn.title(component[stateProp][prop] ? (opts.activeTitle || opts.title || "") : (opts.inactiveTitle || opts.title || ""));
			if (opts.fnHookPost) opts.fnHookPost(component[stateProp][prop]);
		};
		component._addHook(stateName, prop, hk);
		hk();

		return btn
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.text] Button text, if element is not specified.
	 * @param [opts.fnHookPost] Function to run after primary hook.
	 * @param [opts.stateName] State name.
	 * @param [opts.stateProp] State prop.
	 * @param [opts.isInverted] If the toggle display should be inverted.
	 * @param [opts.activeClass] CSS class to use when setting the button as "active."
	 * @param [opts.title]
	 * @param [opts.activeTitle] Title to use when setting the button as "active."
	 * @param [opts.inactiveTitle] Title to use when setting the button as "active."
	 * @return {JQuery}
	 */
	static $getBtnBool (component, prop, opts) {
		const nxtOpts = {...opts};
		if (nxtOpts.$ele) {
			nxtOpts.ele = nxtOpts.$ele[0];
			delete nxtOpts.$ele;
		}
		return $(this.getBtnBool(component, prop, nxtOpts));
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the input.
	 * @return {JQuery}
	 */
	static $getCbBool (component, prop, opts) {
		opts = opts || {};

		const $cb = (opts.$ele || $(`<input type="checkbox">`))
			.keydown(evt => {
				if (evt.key === "Escape") $cb.blur();
			})
			.change(() => component._state[prop] = $cb.prop("checked"));
		const hook = () => $cb.prop("checked", !!component._state[prop]);
		component._addHookBase(prop, hook);
		hook();

		return opts.asMeta ? ({$cb, unhook: () => component._removeHookBase(prop, hook)}) : $cb;
	}

	/**
	 * A select2-style dropdown.
	 * @param comp An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.isHiddenPerValue]
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.isAllowNull] If null is allowed.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.displayNullAs] If null values are allowed, display them as this string.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the select.
	 * @param [opts.isDisabled] If the selector should be display-only
	 * @return {JQuery}
	 */
	static $getSelSearchable (comp, prop, opts) {
		opts = opts || {};

		const $iptDisplay = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.addClass("ui-sel2__ipt-display")
			.attr("tabindex", "-1")
			.click(() => {
				if (opts.isDisabled) return;
				$iptSearch.focus().select();
			})
			.prop("disabled", !!opts.isDisabled)
			.disableSpellcheck();

		const handleSearchChange = () => {
			const cleanTerm = this._$getSelSearchable_getSearchString($iptSearch.val());
			metaOptions.forEach(it => {
				it.isVisible = it.searchTerm.includes(cleanTerm);
				it.$ele.toggleVe(it.isVisible && !it.isForceHidden);
			});
		};
		const handleSearchChangeDebounced = MiscUtil.debounce(handleSearchChange, 30);

		const $iptSearch = (opts.$ele || $(opts.html || `<input class="form-control input-xs form-control--minimal">`))
			.addClass("absolute ui-sel2__ipt-search")
			.keydown(evt => {
				if (opts.isDisabled) return;

				switch (evt.key) {
					case "Escape": evt.stopPropagation(); return $iptSearch.blur();

					case "ArrowDown": {
						evt.preventDefault();
						const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
						if (!visibleMetaOptions.length) return;
						visibleMetaOptions[0].$ele.focus();
						break;
					}

					case "Enter": {
						const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
						if (!visibleMetaOptions.length) return;
						comp._state[prop] = visibleMetaOptions[0].value;
						$iptSearch.blur();
						break;
					}

					default: handleSearchChangeDebounced();
				}
			})
			.change(() => handleSearchChangeDebounced())
			.click(() => {
				if (opts.isDisabled) return;
				$iptSearch.focus().select();
			})
			.prop("disabled", !!opts.isDisabled)
			.disableSpellcheck();

		const $wrpChoices = $(`<div class="absolute ui-sel2__wrp-options overflow-y-scroll"></div>`);

		const $wrp = $$`<div class="flex relative ui-sel2__wrp w-100">
			${$iptDisplay}
			${$iptSearch}
			${$wrpChoices}
			<div class="ui-sel2__disp-arrow absolute no-events bold"><span class="glyphicon glyphicon-menu-down"></span></div>
		</div>`;

		const procValues = opts.isAllowNull ? [null, ...opts.values] : opts.values;
		const metaOptions = procValues.map((v, i) => {
			const display = v == null ? (opts.displayNullAs || "\u2014") : opts.fnDisplay ? opts.fnDisplay(v) : v;

			const $ele = $(`<div class="flex-v-center py-1 px-1 clickable ui-sel2__disp-option ${v == null ? `italic` : ""}" tabindex="${i}">${display}</div>`)
				.click(() => {
					if (opts.isDisabled) return;

					comp._state[prop] = v;
					$(document.activeElement).blur();
					// Temporarily remove pointer events from the dropdown, so it collapses thanks to its :hover CSS
					$wrp.addClass("no-events");
					setTimeout(() => $wrp.removeClass("no-events"), 50);
				})
				.keydown(evt => {
					if (opts.isDisabled) return;

					switch (evt.key) {
						case "Escape": evt.stopPropagation(); return $ele.blur();

						case "ArrowDown": {
							evt.preventDefault();
							const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
							if (!visibleMetaOptions.length) return;
							const ixCur = visibleMetaOptions.indexOf(out);
							const nxt = visibleMetaOptions[ixCur + 1];
							if (nxt) nxt.$ele.focus();
							break;
						}

						case "ArrowUp": {
							evt.preventDefault();
							const visibleMetaOptions = metaOptions.filter(it => it.isVisible && !it.isForceHidden);
							if (!visibleMetaOptions.length) return;
							const ixCur = visibleMetaOptions.indexOf(out);
							const prev = visibleMetaOptions[ixCur - 1];
							if (prev) return prev.$ele.focus();
							$iptSearch.focus();
							break;
						}

						case "Enter": {
							comp._state[prop] = v;
							$ele.blur();
							break;
						}
					}
				})
				.appendTo($wrpChoices);

			const isForceHidden = opts.isHiddenPerValue && !!(opts.isAllowNull ? opts.isHiddenPerValue[i - 1] : opts.isHiddenPerValue[i]);
			if (isForceHidden) $ele.hideVe();

			const out = {
				value: v,
				isVisible: true,
				isForceHidden,
				searchTerm: this._$getSelSearchable_getSearchString(display),
				$ele,
			};
			return out;
		});

		const fnUpdateHidden = (isHiddenPerValue, isHideNull = false) => {
			let metaOptions_ = metaOptions;

			if (opts.isAllowNull) {
				metaOptions_[0].isForceHidden = isHideNull;
				metaOptions_ = metaOptions_.slice(1);
			}

			metaOptions_.forEach((it, i) => it.isForceHidden = !!isHiddenPerValue[i]);
			handleSearchChange();
		};

		const hk = () => {
			if (comp._state[prop] == null) $iptDisplay.addClass("italic").addClass("ve-muted").val(opts.displayNullAs || "\u2014");
			else $iptDisplay.removeClass("italic").removeClass("ve-muted").val(opts.fnDisplay ? opts.fnDisplay(comp._state[prop]) : comp._state[prop]);

			metaOptions.forEach(it => it.$ele.removeClass("active"))
			const metaActive = metaOptions.find(it => it.value == null ? comp._state[prop] == null : it.value === comp._state[prop]);
			if (metaActive) metaActive.$ele.addClass("active");
		};
		comp._addHookBase(prop, hk);
		hk();

		return opts.asMeta
			? ({
				$wrp,
				unhook: () => comp._removeHookBase(prop, hk),
				$iptDisplay,
				$iptSearch,
				fnUpdateHidden,
			})
			: $wrp;
	}

	static _$getSelSearchable_getSearchString (str) {
		if (str == null) return "";
		return str.trim().toLowerCase().replace(/\s+/g, " ");
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.$ele] Element to use.
	 * @param [opts.html] HTML to convert to element to use.
	 * @param [opts.isAllowNull] If null is allowed.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.displayNullAs] If null values are allowed, display them as this string.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the select.
	 * @param [opts.propProxy] Proxy prop.
	 */
	static $getSelEnum (component, prop, {values, $ele, html, isAllowNull, fnDisplay, displayNullAs, asMeta, propProxy = "state"} = {}) {
		const _propProxy = `_${propProxy}`

		let values_;

		let $sel = $ele || (html ? $(html) : null);
		// Use native API, if we can, for performance
		if (!$sel) { const sel = document.createElement("select"); sel.className = "form-control input-xs"; $sel = $(sel); }

		$sel.change(() => {
			const ix = Number($sel.val());
			if (~ix) component[_propProxy][prop] = values_[ix];
			else {
				if (isAllowNull) component[_propProxy][prop] = null;
				else component[_propProxy][prop] = values_[0];
			}
		});

		const setValues = (nxtValues, {isResetOnMissing = false} = {}) => {
			if (CollectionUtil.deepEquals(values_, nxtValues)) return;
			values_ = nxtValues;
			$sel.empty();
			// Use native API for performance
			if (isAllowNull) { const opt = document.createElement("option"); opt.value = "-1"; opt.text = displayNullAs || "\u2014"; $sel.append(opt); }
			values_.forEach((it, i) => { const opt = document.createElement("option"); opt.value = `${i}`; opt.text = fnDisplay ? fnDisplay(it) : it; $sel.append(opt); });

			if (isResetOnMissing) {
				// If the new value list doesn't contain our current value, reset our current value
				if (component[_propProxy][prop] != null && !nxtValues.includes(component[_propProxy][prop])) {
					if (isAllowNull) return component[_propProxy][prop] = null;
					else return component[_propProxy][prop] = nxtValues[0];
				}
			}

			hook();
		};

		const hook = () => {
			const searchFor = component[_propProxy][prop] === undefined ? null : component[_propProxy][prop];
			// Null handling is done in change handler
			const ix = values_.indexOf(searchFor);
			$sel.val(`${ix}`);
		};
		component._addHookBase(prop, hook);

		setValues(values);

		if (!asMeta) return $sel;

		return {
			$sel,
			unhook: () => component._removeHookBase(prop, hook),
			setValues,
		};
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.fnDisplay] Value display function.
	 */
	static $getPickEnum (component, prop, opts) {
		return this._$getPickEnumOrString(component, prop, opts);
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param [opts] Options Object.
	 * @param [opts.values] Values to display.
	 * @param [opts.isCaseInsensitive] If the values should be case insensitive.
	 */
	static $getPickString (component, prop, opts) {
		return this._$getPickEnumOrString(component, prop, {...opts, isFreeText: true});
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param [opts.values] Values to display.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.isFreeText] If the picker should accept free text.
	 * @param [opts.isCaseInsensitive] If the picker should accept free text.
	 */
	static _$getPickEnumOrString (component, prop, opts) {
		opts = opts || {};

		const getSubcompValues = () => {
			const initialValuesArray = (opts.values || []).concat(opts.isFreeText ? MiscUtil.copy((component._state[prop] || [])) : []);
			const initialValsCompWith = opts.isCaseInsensitive ? component._state[prop].map(it => it.toLowerCase()) : component._state[prop];
			return initialValuesArray
				.map(v => opts.isCaseInsensitive ? v.toLowerCase() : v)
				.mergeMap(v => ({[v]: component._state[prop] && initialValsCompWith.includes(v)}));
		};

		const initialVals = getSubcompValues();

		let $btnAdd;
		if (opts.isFreeText) {
			$btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add">+</button>`)
				.click(async () => {
					const input = await InputUiUtil.pGetUserString();
					if (input == null || input === VeCt.SYM_UI_SKIP) return;
					const inputClean = opts.isCaseInsensitive ? input.trim().toLowerCase() : input.trim();
					pickComp.getPod().set(inputClean, true);
				});
		} else {
			const menu = ContextUtil.getMenu(opts.values.map(it => new ContextUtil.Action(
				opts.fnDisplay ? opts.fnDisplay(it) : it,
				() => pickComp.getPod().set(it, true),
			)));

			$btnAdd = $(`<button class="btn btn-xxs btn-default ui-pick__btn-add">+</button>`)
				.click(evt => ContextUtil.pOpenMenu(evt, menu));
		}

		const pickComp = BaseComponent.fromObject(initialVals);
		pickComp.render = function ($parent) {
			$parent.empty();

			Object.entries(this._state).forEach(([k, v]) => {
				if (v === false) return;

				const $btnRemove = $(`<button class="btn btn-danger ui-pick__btn-remove text-center">×</button>`)
					.click(() => this._state[k] = false);
				$$`<div class="flex mx-1 mb-1 ui-pick__disp-pill"><div class="px-1 ui-pick__disp-text flex-v-center">${opts.fnDisplay ? opts.fnDisplay(k) : k}</div>${$btnRemove}</div>`.appendTo($parent);
			});
		};

		const $wrpPills = $(`<div class="flex flex-wrap w-100"></div>`);
		const $wrp = $$`<div class="flex-v-center">${$btnAdd}${$wrpPills}</div>`;
		pickComp._addHookAll("state", () => {
			component._state[prop] = Object.keys(pickComp._state).filter(k => pickComp._state[k]);
			pickComp.render($wrpPills);
		});
		pickComp.render($wrpPills);

		const hkParent = () => pickComp._proxyAssignSimple("state", getSubcompValues(), true);
		component._addHookBase(prop, hkParent);

		return $wrp;
	}

	/**
	 * @param component An instance of a class which extends BaseComponent.
	 * @param prop Component to hook on.
	 * @param opts Options Object.
	 * @param opts.values Values to display.
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.isDisallowNull] True if null is not an allowed value.
	 * @param [opts.asMeta] If a meta-object should be returned containing the hook and the wrapper.
	 * @param [opts.isIndent] If the checkboxes should be indented.
	 * @return {JQuery}
	 */
	static $getCbsEnum (component, prop, opts) {
		opts = opts || {};

		const $wrp = $(`<div class="flex-col w-100"></div>`);
		const metas = opts.values.map(it => {
			const $cb = $(`<input type="checkbox">`)
				.keydown(evt => {
					if (evt.key === "Escape") $cb.blur();
				})
				.change(() => {
					let didUpdate = false;
					const ix = (component._state[prop] || []).indexOf(it);
					if (~ix) component._state[prop].splice(ix, 1);
					else {
						if (component._state[prop]) component._state[prop].push(it);
						else {
							didUpdate = true;
							component._state[prop] = [it];
						}
					}
					if (!didUpdate) component._state[prop] = [...component._state[prop]];
				});

			$$`<label class="split-v-center my-1 stripe-odd ${opts.isIndent ? "ml-4" : ""}"><div class="no-wrap flex-v-center">${opts.fnDisplay ? opts.fnDisplay(it) : it}</div>${$cb}</label>`.appendTo($wrp);

			return {$cb, value: it};
		});

		const hook = () => metas.forEach(meta => meta.$cb.prop("checked", component._state[prop] && component._state[prop].includes(meta.value)));
		component._addHookBase(prop, hook);
		hook();

		return opts.asMeta ? {$wrp, unhook: () => component._removeHookBase(prop, hook)} : $wrp;
	}

	// region Multi Choice
	/**
	 * @param comp
	 * @param prop Base prop. This will be expanded with `__...`-suffixed sub-props as required.
	 * @param opts Options.
	 * @param [opts.values] Array of values. Mutually incompatible with "valueGroups".
	 * @param [opts.valueGroups] Array of value groups (of the form
	 *   `{name: "Group Name", text: "Optional group hint text", values: [...]}` ).
	 *   Mutually incompatible with "values".
	 * @param [opts.valueGroupSplitControlsLookup] A lookup of `<value group name> -> header controls` to embed in the UI.
	 * @param [opts.count] Number of choices the user can make (cannot be used with min/max).
	 * @param [opts.min] Minimum number of choices the user can make (cannot be used with count).
	 * @param [opts.max] Maximum number of choices the user can make (cannot be used with count).
	 * @param [opts.isResolveItems] True if the promise should resolve to an array of the items instead of the indices. // TODO maybe remove?
	 * @param [opts.fnDisplay] Function which takes a value and returns display text.
	 * @param [opts.required] Values which are required.
	 * @param [opts.ixsRequired] Indexes of values which are required.
	 */
	static getMetaWrpMultipleChoice (comp, prop, opts) {
		opts = opts || {};
		this._getMetaWrpMultipleChoice_doValidateOptions(opts);

		const rowMetas = [];
		const $eles = [];
		const ixsSelectionOrder = [];

		const propIsAcceptable = this.getMetaWrpMultipleChoice_getPropIsAcceptable(prop);
		const propPulse = this.getMetaWrpMultipleChoice_getPropPulse(prop);
		const propIxMax = this._getMetaWrpMultipleChoice_getPropValuesLength(prop);

		const cntRequired = ((opts.required || []).length) + ((opts.ixsRequired || []).length);
		const count = opts.count != null ? opts.count - cntRequired : null;
		const min = opts.min != null ? opts.min - cntRequired : null;
		const max = opts.max != null ? opts.max - cntRequired : null;

		const valueGroups = opts.valueGroups || [{values: opts.values}];

		let ixValue = 0;
		valueGroups.forEach((group, i) => {
			if (i !== 0) $eles.push($(`<hr class="w-100 hr-2 hr--dotted">`));

			if (group.name) {
				const $wrpName = $$`<div class="split-v-center py-1">
					<div class="flex-v-center"><span class="mr-2">‒</span><span>${group.name}</span></div>
					${opts.valueGroupSplitControlsLookup?.[group.name]}
				</div>`
				$eles.push($wrpName);
			}

			if (group.text) $eles.push($(`<div class="flex-v-center py-1"><div class="ml-1 mr-3"></div><i>${group.text}</i></div>`));

			group.values.forEach(v => {
				const ixValueFrozen = ixValue;

				const propIsActive = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixValueFrozen);
				const propIsRequired = this.getMetaWrpMultipleChoice_getPropIsRequired(prop, ixValueFrozen);

				const isHardRequired = (opts.required && opts.required.includes(v))
					|| (opts.ixsRequired && opts.ixsRequired.includes(ixValueFrozen));
				const isRequired = isHardRequired || comp._state[propIsRequired];

				// In the case of pre-existing selections, add these to our selection order tracking as they appear
				if (comp._state[propIsActive] && !comp._state[propIsRequired]) ixsSelectionOrder.push(ixValueFrozen);

				let hk;
				const $cb = isRequired
					? $(`<input type="checkbox" disabled checked title="This option is required.">`)
					: ComponentUiUtil.$getCbBool(comp, propIsActive);
				if (!isRequired) {
					hk = () => {
						// region Selection order
						const ixIx = ixsSelectionOrder.findIndex(it => it === ixValueFrozen);
						if (~ixIx) ixsSelectionOrder.splice(ixIx, 1);
						if (comp._state[propIsActive]) ixsSelectionOrder.push(ixValueFrozen);
						// endregion

						// region Enable/disable
						const activeRows = rowMetas.filter(it => comp._state[it.propIsActive]);

						if (count != null) {
							// If we're above the max allowed count, deselect a checkbox in FIFO order
							if (activeRows.length > count) {
								// FIFO (`.shift`) makes logical sense, but FILO (`.splice` second-from-last) _feels_ better
								const ixFirstSelected = ixsSelectionOrder.splice(ixsSelectionOrder.length - 2, 1)[0];
								if (ixFirstSelected != null) {
									const propIsActiveOther = this.getMetaWrpMultipleChoice_getPropIsActive(prop, ixFirstSelected);
									comp._state[propIsActiveOther] = false;

									comp._state[propPulse] = !comp._state[propPulse];
								}
								return;
							}
						}

						let isAcceptable = false;
						if (count != null) {
							if (activeRows.length === count) isAcceptable = true;
						} else {
							if (activeRows.length >= (min || 0) && activeRows.length <= (max || Number.MAX_SAFE_INTEGER)) isAcceptable = true;
						}

						// Save this to a flag in the state object that external code can read
						comp._state[propIsAcceptable] = isAcceptable;
						// endregion

						comp._state[propPulse] = !comp._state[propPulse];
					};
					comp._addHookBase(propIsActive, hk);
					hk();
				}

				const displayValue = opts.fnDisplay ? opts.fnDisplay(v, ixValueFrozen) : v;

				rowMetas.push({
					$cb,
					displayValue,
					value: v,
					propIsActive,
					unhook: () => {
						if (hk) comp._removeHookBase(propIsActive, hk);
					},
				});

				$eles.push($$`<label class="flex-v-center py-1 stripe-even">
					<div class="col-1 flex-vh-center">${$cb}</div>
					<div class="col-11 flex-v-center">${displayValue}</div>
				</label>`);

				ixValue++;
			});
		});

		// Sort the initial selection order (i.e. that from defaults) by lowest to highest, such that new clicks
		//   will remove from the first element in visual order
		ixsSelectionOrder.sort((a, b) => SortUtil.ascSort(a, b));

		comp.__state[propIxMax] = ixValue;

		// Always return this as a "meta" object
		const unhook = () => rowMetas.forEach(it => it.unhook());
		return {
			$ele: $$`<div class="flex-col w-100 overflow-y-auto">${$eles}</div>`,
			rowMetas, // Return this to allow for creating custom UI
			propIsAcceptable,
			propPulse,
			unhook,
			cleanup: () => {
				unhook();
				// This will trigger a final "pulse"
				Object.keys(comp._state)
					.filter(it => it.startsWith(`${prop}__`))
					.forEach(it => delete comp._state[it]);
			},
		};
	}

	static getMetaWrpMultipleChoice_getPropIsAcceptable (prop) { return `${prop}__isAcceptable`; }
	static getMetaWrpMultipleChoice_getPropPulse (prop) { return `${prop}__pulse`; }
	static _getMetaWrpMultipleChoice_getPropValuesLength (prop) { return `${prop}__length`; }
	static getMetaWrpMultipleChoice_getPropIsActive (prop, ixValue) { return `${prop}__isActive_${ixValue}`; }
	static getMetaWrpMultipleChoice_getPropIsRequired (prop, ixValue) { return `${prop}__isRequired_${ixValue}`; }

	static getMetaWrpMultipleChoice_getSelectedIxs (comp, prop) {
		const out = [];
		const len = comp._state[this._getMetaWrpMultipleChoice_getPropValuesLength(prop)] || 0;
		for (let i = 0; i < len; ++i) {
			if (comp._state[this.getMetaWrpMultipleChoice_getPropIsActive(prop, i)]) out.push(i);
		}
		return out;
	}

	static getMetaWrpMultipleChoice_getSelectedValues (comp, prop, {values, valueGroups}) {
		const selectedIxs = this.getMetaWrpMultipleChoice_getSelectedIxs(comp, prop);
		if (values) return selectedIxs.map(ix => values[ix]);

		const selectedIxsSet = new Set(selectedIxs);
		const out = [];
		let ixValue = 0;
		valueGroups.forEach(group => {
			group.values.forEach(v => {
				if (selectedIxsSet.has(ixValue)) out.push(v);
				ixValue++;
			});
		});
		return out;
	}

	static _getMetaWrpMultipleChoice_doValidateOptions (opts) {
		if ((Number(!!opts.values) + Number(!!opts.valueGroups)) !== 1) throw new Error(`Exactly one of "values" and "valueGroups" must be specified!`);

		if (opts.count != null && (opts.min != null || opts.max != null)) throw new Error(`Chooser must be either in "count" mode or "min/max" mode!`);
		// If no mode is specified, default to a "count 1" chooser
		if (opts.count == null && opts.min == null && opts.max == null) opts.count = 1;
	}
	// endregion

	/**
	 * @param comp An instance of a class which extends BaseComponent.
	 * @param opts Options Object.
	 * @param opts.propMin
	 * @param opts.propMax
	 * @param opts.propCurMin
	 * @param [opts.propCurMax]
	 * @param [opts.fnDisplay] Value display function.
	 * @param [opts.fnDisplayTooltip]
	 * @param [opts.sparseValues]
	 */
	static $getSliderRange (comp, opts) {
		opts = opts || {};
		const slider = new ComponentUiUtil.RangeSlider({comp, ...opts});
		return slider.$get();
	}

	static $getSliderNumber (
		comp,
		prop,
		{
			min,
			max,
			step,
			$ele,
			asMeta,
		} = {},
	) {
		const $slider = ($ele || $(`<input type="range">`))
			.change(() => comp._state[prop] = Number($slider.val()));

		if (min != null) $slider.attr("min", min);
		if (max != null) $slider.attr("max", max);
		if (step != null) $slider.attr("step", step);

		const hk = () => $slider.val(comp._state[prop]);
		comp._addHookBase(prop, hk);
		hk();

		return asMeta ? ({$slider, unhook: () => comp._removeHookBase(prop, hk)}) : $slider;
	}
}
ComponentUiUtil.RangeSlider = class {
	constructor (
		{
			comp,
			propMin,
			propMax,
			propCurMin,
			propCurMax,
			fnDisplay,
			fnDisplayTooltip,
			sparseValues,
		},
	) {
		this._comp = comp;
		this._propMin = propMin;
		this._propMax = propMax;
		this._propCurMin = propCurMin;
		this._propCurMax = propCurMax;
		this._fnDisplay = fnDisplay;
		this._fnDisplayTooltip = fnDisplayTooltip;
		this._sparseValues = sparseValues;

		this._isSingle = !this._propCurMax;

		// region Make a copy of the interesting bits of the parent component, so we can freely change them without
		//   outside performance implications
		const compCpyState = {
			[this._propMin]: this._comp._state[this._propMin],
			[this._propCurMin]: this._comp._state[this._propCurMin],
			[this._propMax]: this._comp._state[this._propMax],
		};
		if (!this._isSingle) compCpyState[this._propCurMax] = this._comp._state[this._propCurMax];
		this._compCpy = BaseComponent.fromObject(compCpyState);

		// Sync parent changes to our state
		this._comp._addHook("state", this._propMin, () => this._compCpy._state[this._propMin] = this._comp._state[this._propMin]);
		this._comp._addHook("state", this._propCurMin, () => this._compCpy._state[this._propCurMin] = this._comp._state[this._propCurMin]);
		this._comp._addHook("state", this._propMax, () => this._compCpy._state[this._propMax] = this._comp._state[this._propMax]);

		if (!this._isSingle) this._comp._addHook("state", this._propCurMax, () => this._compCpy._state[this._propCurMax] = this._comp._state[this._propCurMax]);
		// endregion

		this._cacheRendered = null;
		this._dispTrackOuter = null;
		this._dispTrackInner = null;
		this._thumbLow = null;
		this._thumbHigh = null;
		this._dragMeta = null;
	}

	$get () {
		const out = this.get();
		return $(out);
	}

	get () {
		this.constructor._init();
		this.constructor._ALL_SLIDERS.add(this);

		if (this._cacheRendered) return this._cacheRendered;

		// region Top part
		const dispValueLeft = this._isSingle ? this._getSpcSingleValue() : this._getDispValue({isVisible: true, side: "left"});
		const dispValueRight = this._getDispValue({isVisible: true, side: "right"});

		this._dispTrackInner = this._isSingle ? null : e_({
			tag: "div",
			clazz: "ui-slidr__track-inner h-100 absolute",
		});

		this._thumbLow = this._getThumb();
		this._thumbHigh = this._isSingle ? null : this._getThumb();

		this._dispTrackOuter = e_({
			tag: "div",
			clazz: `relative w-100 ui-slidr__track-outer`,
			children: [
				this._dispTrackInner,
				this._thumbLow,
				this._thumbHigh,
			].filter(Boolean),
		});

		const wrpTrack = e_({
			tag: "div",
			clazz: `flex-v-center w-100 h-100 ui-slidr__wrp-track clickable`,
			mousedown: evt => {
				const thumb = this._getClosestThumb(evt);
				this._handleMouseDown(evt, thumb);
			},
			children: [
				this._dispTrackOuter,
			],
		});

		const wrpTop = e_({
			tag: "div",
			clazz: "flex-v-center w-100 ui-slidr__wrp-top",
			children: [
				dispValueLeft,
				wrpTrack,
				dispValueRight,
			].filter(Boolean),
		});
		// endregion

		// region Bottom part
		const wrpPips = e_({
			tag: "div",
			clazz: `w-100 flex relative clickable h-100 ui-slidr__wrp-pips`,
			mousedown: evt => {
				const thumb = this._getClosestThumb(evt);
				this._handleMouseDown(evt, thumb);
			},
		});

		const wrpBottom = e_({
			tag: "div",
			clazz: "w-100 flex-vh-center ui-slidr__wrp-bottom",
			children: [
				this._isSingle ? this._getSpcSingleValue() : this._getDispValue({side: "left"}), // Pad the start
				wrpPips,
				this._getDispValue({side: "right"}), // and the end
			].filter(Boolean),
		});
		// endregion

		// region Hooks
		const hkChangeValue = () => {
			const curMin = this._compCpy._state[this._propCurMin];
			const pctMin = this._getLeftPositionPercentage({value: curMin});
			this._thumbLow.style.left = `calc(${pctMin}% - ${this.constructor._W_THUMB_PX / 2}px)`;
			const toDisplayLeft = this._fnDisplay ? `${this._fnDisplay(curMin)}`.qq() : curMin;
			const toDisplayLeftTooltip = this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMin)}`.qq() : null;
			if (!this._isSingle) {
				dispValueLeft
					.html(toDisplayLeft)
					.tooltip(toDisplayLeftTooltip);
			}

			if (!this._isSingle) {
				this._dispTrackInner.style.left = `${pctMin}%`;

				const curMax = this._compCpy._state[this._propCurMax];
				const pctMax = this._getLeftPositionPercentage({value: curMax});
				this._dispTrackInner.style.right = `${100 - pctMax}%`;
				this._thumbHigh.style.left = `calc(${pctMax}% - ${this.constructor._W_THUMB_PX / 2}px)`;
				dispValueRight
					.html(this._fnDisplay ? `${this._fnDisplay(curMax)}`.qq() : curMax)
					.tooltip(this._fnDisplayTooltip ? `${this._fnDisplayTooltip(curMax)}`.qq() : null);
			} else {
				dispValueRight
					.html(toDisplayLeft)
					.tooltip(toDisplayLeftTooltip);
			}
		};

		const hkChangeLimit = () => {
			const pips = [];

			if (!this._sparseValues) {
				const numPips = this._compCpy._state[this._propMax] - this._compCpy._state[this._propMin];
				let pipIncrement = 1;
				// Cap the number of pips
				if (numPips > ComponentUiUtil.RangeSlider._MAX_PIPS) pipIncrement = Math.ceil(numPips / ComponentUiUtil.RangeSlider._MAX_PIPS);

				let i, len;
				for (
					i = this._compCpy._state[this._propMin], len = this._compCpy._state[this._propMax] + 1;
					i < len;
					i += pipIncrement
				) {
					pips.push(this._getWrpPip({
						isMajor: i === this._compCpy._state[this._propMin] || i === (len - 1),
						value: i,
					}));
				}

				// Ensure the last pip is always rendered, even if we're reducing pips
				if (i !== this._compCpy._state[this._propMax]) pips.push(this._getWrpPip({isMajor: true, value: this._compCpy._state[this._propMax]}));
			} else {
				const len = this._sparseValues.length;
				this._sparseValues.forEach((val, i) => {
					pips.push(this._getWrpPip({
						isMajor: i === 0 || i === (len - 1),
						value: val,
					}));
				})
			}

			wrpPips.empty();
			e_({
				ele: wrpPips,
				children: pips,
			});

			hkChangeValue();
		};

		this._compCpy._addHook("state", this._propMin, hkChangeLimit);
		this._compCpy._addHook("state", this._propMax, hkChangeLimit);
		this._compCpy._addHook("state", this._propCurMin, hkChangeValue);
		if (!this._isSingle) this._compCpy._addHook("state", this._propCurMax, hkChangeValue);

		hkChangeLimit();
		// endregion

		const wrp = e_({
			tag: "div",
			clazz: "flex-col w-100 ui-slidr__wrp",
			children: [
				wrpTop,
				wrpBottom,
			],
		});

		return this._cacheRendered = wrp;
	}

	destroy () {
		this.constructor._ALL_SLIDERS.delete(this);
		if (this._cacheRendered) this._cacheRendered.remove();
	}

	_getDispValue ({isVisible, side}) {
		return e_({
			tag: "div",
			clazz: `overflow-hidden ui-slidr__disp-value no-shrink no-grow flex-vh-center bold no-select ${isVisible ? `ui-slidr__disp-value--visible` : ""} ui-slidr__disp-value--${side}`,
		});
	}

	_getSpcSingleValue () {
		return e_({
			tag: "div",
			clazz: `px-2`,
		});
	}

	_getThumb () {
		const thumb = e_({
			tag: "div",
			clazz: "ui-slidr__thumb absolute clickable",
			mousedown: evt => this._handleMouseDown(evt, thumb),
		}).attr("draggable", true);

		return thumb;
	}

	_getWrpPip ({isMajor, value} = {}) {
		const style = this._getWrpPip_getStyle({value});

		const pip = e_({
			tag: "div",
			clazz: `ui-slidr__pip ${isMajor ? `ui-slidr__pip--major` : `absolute`}`,
		});

		const dispLabel = e_({
			tag: "div",
			clazz: "absolute ui-slidr__pip-label flex-vh-center ve-small no-wrap",
			html: isMajor ? this._fnDisplay ? `${this._fnDisplay(value)}`.qq() : value : "",
			title: isMajor && this._fnDisplayTooltip ? `${this._fnDisplayTooltip(value)}`.qq() : null,
		});

		return e_({
			tag: "div",
			clazz: "flex-col flex-vh-center absolute no-select",
			children: [
				pip,
				dispLabel,
			],
			style,
		});
	}

	_getWrpPip_getStyle ({value}) {
		return `left: ${this._getLeftPositionPercentage({value})}%`;
	}

	_getLeftPositionPercentage ({value}) {
		if (this._sparseValues) {
			const ix = this._sparseValues.sort(SortUtil.ascSort).indexOf(value);
			if (!~ix) throw new Error(`Value "${value}" was not in the list of sparse values!`);
			return (ix / (this._sparseValues.length - 1)) * 100;
		}

		const min = this._compCpy._state[this._propMin]; const max = this._compCpy._state[this._propMax];
		return ((value - min) / (max - min)) * 100;
	}

	/**
	 * Convert pixel-space to track-space.
	 * Example usage:
	 * ```
	 * click: evt => {
	 *   const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
	 *   const value = this._getRelativeValue(evt, {trackOriginX, trackWidth});
	 *   this._handleClick(evt, value);
	 * }
	 * ```
	 */
	_getRelativeValue (evt, {trackOriginX, trackWidth}) {
		const xEvt = EventUtil.getClientX(evt) - trackOriginX;

		if (this._sparseValues) {
			const ixMax = this._sparseValues.length - 1;
			const rawVal = Math.round((xEvt / trackWidth) * ixMax);
			return this._sparseValues[Math.min(ixMax, Math.max(0, rawVal))];
		}

		const min = this._compCpy._state[this._propMin]; const max = this._compCpy._state[this._propMax];

		const rawVal = min
			+ Math.round(
				(xEvt / trackWidth) * (max - min),
			);

		return Math.min(max, Math.max(min, rawVal)); // Clamp eet
	}

	_getClosestThumb (evt) {
		if (this._isSingle) return this._thumbLow;

		const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();
		const value = this._getRelativeValue(evt, {trackOriginX, trackWidth});

		if (value < this._compCpy._state[this._propCurMin]) return this._thumbLow;
		if (value > this._compCpy._state[this._propCurMax]) return this._thumbHigh;

		const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);
		if (distToMax < distToMin) return this._thumbHigh;
		return this._thumbLow;
	}

	_getDistsToCurrentMinAndMax (value) {
		if (this._isSingle) throw new Error(`Can not get distance to max value for singleton slider!`);

		// Move the closest slider to this pip's location
		const distToMin = Math.abs(this._compCpy._state[this._propCurMin] - value);
		const distToMax = Math.abs(this._compCpy._state[this._propCurMax] - value);
		return {distToMin, distToMax}
	}

	_handleClick (evt, value) {
		evt.stopPropagation();
		evt.preventDefault();

		// If lower than the lowest value, set the low value
		if (value < this._compCpy._state[this._propCurMin]) this._compCpy._state[this._propCurMin] = value;

		// If higher than the highest value, set the high value
		if (value > this._compCpy._state[this._propCurMax]) this._compCpy._state[this._propCurMax] = value;

		// Move the closest slider to this pip's location
		const {distToMin, distToMax} = this._getDistsToCurrentMinAndMax(value);

		if (distToMax < distToMin) this._compCpy._state[this._propCurMax] = value;
		else this._compCpy._state[this._propCurMin] = value;
	}

	_handleMouseDown (evt, thumb) {
		evt.preventDefault();
		evt.stopPropagation();

		// region Set drag metadata
		const {x: trackOriginX, width: trackWidth} = this._dispTrackOuter.getBoundingClientRect();

		thumb.addClass(`ui-slidr__thumb--hover`);

		this._dragMeta = {
			trackOriginX,
			trackWidth,
			thumb,
		};
		// endregion

		this._handleMouseMove(evt);
	}

	_handleMouseUp () {
		const wasActive = this._doDragCleanup();

		// On finishing a slide, push our state to the parent comp
		if (wasActive) {
			const nxtState = {
				[this._propMin]: this._compCpy._state[this._propMin],
				[this._propMax]: this._compCpy._state[this._propMax],
				[this._propCurMin]: this._compCpy._state[this._propCurMin],
			};
			if (!this._isSingle) nxtState[this._propCurMax] = this._compCpy._state[this._propCurMax];

			this._comp._proxyAssignSimple("state", nxtState);
		}
	}

	_handleMouseMove (evt) {
		if (!this._dragMeta) return;

		const val = this._getRelativeValue(evt, this._dragMeta);

		if (this._dragMeta.thumb === this._thumbLow) {
			if (val > this._compCpy._state[this._propCurMax]) return;
			this._compCpy._state[this._propCurMin] = val;
		} else if (this._dragMeta.thumb === this._thumbHigh) {
			if (val < this._compCpy._state[this._propCurMin]) return;
			this._compCpy._state[this._propCurMax] = val;
		}
	}

	_doDragCleanup () {
		const isActive = this._dragMeta != null;

		if (this._dragMeta?.thumb) this._dragMeta.thumb.removeClass(`ui-slidr__thumb--hover`);

		this._dragMeta = null;

		return isActive;
	}

	static _init () {
		if (this._isInit) return;
		document.addEventListener("mousemove", evt => {
			for (const slider of this._ALL_SLIDERS) {
				slider._handleMouseMove(evt);
			}
		});

		document.addEventListener("mouseup", evt => {
			for (const slider of this._ALL_SLIDERS) {
				slider._handleMouseUp(evt);
			}
		});
	}
}
ComponentUiUtil.RangeSlider._isInit = false;
ComponentUiUtil.RangeSlider._ALL_SLIDERS = new Set();
ComponentUiUtil.RangeSlider._W_THUMB_PX = 16;
ComponentUiUtil.RangeSlider._W_LABEL_PX = 24;
ComponentUiUtil.RangeSlider._MAX_PIPS = 40;

// Expose classes for Node/VTTs as appropriate
const utilsUiExports = {
	ProxyBase,
	UiUtil,
	ListUiUtil,
	ProfUiUtil,
	TabUiUtil,
	SearchUiUtil,
	SearchWidget,
	InputUiUtil,
	DragReorderUiUtil,
	SourceUiUtil,
	BaseComponent,
	ComponentUiUtil,
	RenderableCollectionBase,
};
if (typeof module !== "undefined") module.exports = utilsUiExports;
else Object.assign(window, utilsUiExports);

}).toString());



EXT_LIB_SCRIPTS.push((function lib_script_6 () {
// A port of 5etools' `hist.js`

Hist = {}

Hist.util = {
	getCleanHash (hash) {
		return hash.replace(/,+/g, ",").replace(/,$/, "").toLowerCase();
	},

	getHashParts (location) {
		if (location[0] === "#") location = location.slice(1);
		return location.toLowerCase().replace(/%27/g, "'").split(HASH_PART_SEP);
	},

	getSubHash (location, key) {
		const [link, ...sub] = Hist.util.getHashParts(location);
		const hKey = `${key}${HASH_SUB_KV_SEP}`;
		const part = sub.find(it => it.startsWith(hKey));
		if (part) return part.slice(hKey.length);
		return null;
	},

	setSubhash (location, key, val) {
		if (key.endsWith(HASH_SUB_KV_SEP)) key = key.slice(0, -1);

		const [link, ...sub] = Hist.util.getHashParts(location);
		if (!link) return "";

		const hKey = `${key}${HASH_SUB_KV_SEP}`;
		const out = [link];
		if (sub.length) sub.filter(it => !it.startsWith(hKey)).forEach(it => out.push(it));
		if (val != null) out.push(`${hKey}${val}`);

		return Hist.util.getCleanHash(out.join(HASH_PART_SEP));
	}
};

}).toString());



EXT_LIB_API_SCRIPTS.push((function lib_script_7 () {
/**
 * This is a small library for (mostly 2D) vector mathematics.
 * Internally, the vectors used by this library are simple arrays of numbers.
 * The functions provided by this library do not alter the input vectors, 
 * treating each vector as an immutable object.
 */
var VecMath = (function() {
    
    /**
     * Adds two vectors.
     * @param {vec} a
     * @param {vec} b
     * @return {vec}
     */
    var add = function(a, b) {
        var result = [];
        for(var i=0; i<a.length; i++) {
            result[i] = a[i] + b[i];
        }
        return result;
    };
    
    
    /**
     * Creates a cloned copy of a vector.
     * @param {vec} v
     * @return {vec}
     */
    var clone = function(v) {
        var result = [];
        for(var i=0; i < v.length; i++) {
            result.push(v[i]);
        }
        return result;
    };
    
    
    /** 
     * Returns an array representing the cross product of two 3D vectors. 
     * @param {vec3} a
     * @param {vec3} b
     * @return {vec3}
     */
    var cross = function(a, b) {
        var x = a[1]*b[2] - a[2]*b[1];
        var y = a[2]*b[0] - a[0]*b[2];
        var z = a[0]*b[1] - a[1]*b[0];
        return [x, y, z];
    };
    
    
    /** 
     * Returns the degree of a vector - the number of dimensions it has.
     * @param {vec} vector
     * @return {int}
     */
    var degree = function(vector) {
        return vector.length;
    };
    
    
    /**
     * Computes the distance between two points.
     * @param {vec} pt1
     * @param {vec} pt2
     * @return {number}
     */
    var dist = function(pt1, pt2) {
        var v = vec(pt1, pt2);
        return length(v);
    };
    
    
    /** 
     * Returns the dot product of two vectors. 
     * @param {vec} a
     * @param {vec} b
     * @return {number}
     */
    var dot = function(a, b) {
        var result = 0;
        for(var i = 0; i < a.length; i++) {
            result += a[i]*b[i];
        }
        return result;
    };
    
    
    /**
     * Tests if two vectors are equal.
     * @param {vec} a
     * @param {vec} b
     * @param {float} [tolerance] A tolerance threshold for comparing vector 
     *                            components.  
     * @return {boolean} true iff the each of the vectors' corresponding 
     *                  components are equal.
     */
    var equal = function(a, b, tolerance) {
        if(a.length != b.length)
            return false;
        
        for(var i=0; i<a.length; i++) {
            if(tolerance !== undefined) {
                if(Math.abs(a[i] - b[i]) > tolerance) {
                    return false;
                }
            }
            else if(a[i] != b[i])
                return false;
        }
        return true;
    };
    
    
    
    /** 
     * Returns the length of a vector. 
     * @param {vec} vector
     * @return {number}
     */
    var length = function(vector) {
        var length = 0;
        for(var i=0; i < vector.length; i++) {
            length += vector[i]*vector[i];
        }
        return Math.sqrt(length);
    };
    
    
    
    /**
     * Computes the normalization of a vector - its unit vector.
     * @param {vec} v
     * @return {vec}
     */
    var normalize = function(v) {
        var vHat = [];
        
        var vLength = length(v);
        for(var i=0; i < v.length; i++) {
            vHat[i] = v[i]/vLength;
        }
        
        return vHat;
    };
    
    
    /**
     * Computes the projection of vector b onto vector a.
     * @param {vec} a
     * @param {vec} b
     * @return {vec}
     */
    var projection = function(a, b) {
        var scalar = scalarProjection(a, b);
        var aHat = normalize(a);
        
        return scale(aHat, scalar);
    };
    
    
    /** 
     * Computes the distance from a point to an infinitely stretching line. 
     * Works for either 2D or 3D points.
     * @param {vec2 || vec3} pt
     * @param {vec2 || vec3} linePt1   A point on the line.
     * @param {vec2 || vec3} linePt2   Another point on the line.
     * @return {number}
     */
    var ptLineDist = function(pt, linePt1, linePt2) {
        var a = vec(linePt1, linePt2);
        var b = vec(linePt1, pt);
        
        // Make 2D vectors 3D to compute the cross product.
        if(!a[2])
            a[2] = 0;
        if(!b[2])
            b[2] = 0;
        
        var aHat = normalize(a);
        var aHatCrossB = cross(aHat, b);
        return length(aHatCrossB);
    };
    
    
    /** 
     * Computes the distance from a point to a line segment. 
     * Works for either 2D or 3D points.
     * @param {vec2 || vec3} pt
     * @param {vec2 || vec3} linePt1   The start point of the segment.
     * @param {vec2 || vec3} linePt2   The end point of the segment.
     * @return {number}
     */
    var ptSegDist = function(pt, linePt1, linePt2) {
        var a = vec(linePt1, linePt2);
        var b = vec(linePt1, pt);
        var aDotb = dot(a,b);
        
        // Is pt behind linePt1?
        if(aDotb < 0) {
            return length(vec(pt, linePt1));
        }
        
        // Is pt after linePt2?
        else if(aDotb > dot(a,a)) {
            return length(vec(pt, linePt2));
        }
        
        // Pt must be between linePt1 and linePt2.
        else {
            return ptLineDist(pt, linePt1, linePt2);
        }
    };
    
    
    /**
     * Computes the scalar projection of b onto a.
     * @param {vec2} a
     * @param {vec2} b
     * @return {vec2}
     */
    var scalarProjection = function(a, b) {
        var aDotB = dot(a, b);
        var aLength = length(a);
        
        return aDotB/aLength;
    };
    
    
    
    /**
     * Computes a scaled vector.
     * @param {vec2} v
     * @param {number} scalar
     * @return {vec2}
     */
    var scale = function(v, scalar) {
        var result = [];
        
        for(var i=0; i<v.length; i++) {
            result[i] = v[i]*scalar;
        }
        return result;
    };
    
    
    /** 
     * Computes the difference of two vectors.
     * @param {vec} a
     * @param {vec} b
     * @return {vec}
     */
    var sub = function(a, b) {
        var result = [];
        for(var i=0; i<a.length; i++) {
            result.push(a[i] - b[i]);
        }
        return result;
    };
    
    
    /** 
     * Returns the vector from pt1 to pt2. 
     * @param {vec} pt1
     * @param {vec} pt2
     * @return {vec}
     */
    var vec = function(pt1, pt2) {
        var result = [];
        for(var i=0; i<pt1.length; i++) {
            result.push( pt2[i] - pt1[i] );
        }
        
        return result;
    };
    
    
    // The exposed API.
    return {
        add: add,
        clone: clone,
        cross: cross,
        degree: degree,
        dist: dist,
        dot: dot,
        equal: equal,
        length: length,
        normalize: normalize,
        projection: projection,
        ptLineDist: ptLineDist,
        ptSegDist: ptSegDist,
        scalarProjection: scalarProjection,
        scale: scale,
        sub: sub,
        vec: vec
    };
})();


// Perform unit tests. Inform us in the log if any test fails. Otherwise,
// succeed silently.
(function() {
    /**
     * Does a unit test. If the test evaluates to false, then it displays with
     * a message that the unit test failed. Otherwise it passes silently.
     * @param {boolean} test    Some expression to test.
     * @param {string} failMsg  A message displayed if the test fails.
     */
    var assert = function(test, failMsg) {
        if(!test) {
            log("UNIT TEST FAILED: " + failMsg);
        }
    };
    
    
    var a = [1, 5];
    var b = [17, -8];
    
    
    // VecMath.equal
    assert(
        VecMath.equal([2, -3, 4, 8], [2, -3, 4, 8]),
        "VecMath.equal([2, -3, 4, 8], [2, -3, 4, 8])"
    );
    assert(
        !VecMath.equal([1, 3, 5], [-2, 4, -6]),
        "!VecMath.equal([1, 3, 5], [-2, 4, -6])"
    );
    assert(
        !VecMath.equal([1, 3, 5], [1, 3, 4]),
        "!VecMath.equal([1, 3, 5], [1, 3, 4])"
    );
    assert(
        !VecMath.equal([1,2,3], [1,2]),
        "!VecMath.equal([1,2,3], [1,2])"
    );
    assert(
        !VecMath.equal([1,2], [1,2,3]),
        "!VecMath.equal([1,2], [1,2,3])"
    );
    
    // VecMath.add
    assert(
        VecMath.equal(
            VecMath.add([1, 2, 3], [3, -5, 10]),
            [4, -3, 13]
        ),
        "VecMath.add([1, 2, 3], [3, -5, 10]) equals [4, -3, 13]"
    );
    assert(
        VecMath.equal(
            VecMath.add([0, 0, 0], [1, 2, 3]),
            [1, 2, 3]
        ),
        "VecMath.add([0, 0, 0], [1, 2, 3]) equals [1, 2, 3]"
    );
    
    // VecMath.clone
    assert(
        VecMath.equal( VecMath.clone(a), a),
        "VecMath.equal( VecMath.clone(a), a)"
    );
    assert(
        VecMath.clone(a) != a,
        "VecMath.clone(a) != a"
    );
    
    // VecMath.cross
    assert(
        VecMath.equal(
            VecMath.cross([1, 0, 0], [0, 1, 0]),
            [0, 0, 1]
        ),
        "VecMath.cross([1, 0, 0], [0, 1, 0]) equals [0, 0, 1]"
    );
    assert(
        VecMath.equal(
            VecMath.cross([1,2,3], [-10, 3, 5]),
            [1, -35, 23]
        ),
        "VecMath.cross([1,2,3], [-10, 3, 5]) equals [1, -35, 23]"
    );
    
    // VecMath.degree
    assert(
        VecMath.degree([1,2,3]) == 3,
        "VecMath.degree([1,2,3]) == 3"
    );
    assert(
        VecMath.degree([1]) == 1,
        "VecMath.degree([1]) == 1"
    );
    assert(
        VecMath.degree([1,1,1,1,1]) == 5,
        "VecMath.degree([1,1,1,1,1]) == 5"
    );
    
    // VecMath.dist
    assert(
        VecMath.dist([1,2], [4,6]) == 5,
        "VecMath.dist([1,2], [4,6]) == 5"
    );
    assert(
        VecMath.dist([3,4], [-3, -4]) == 10,
        "VecMath.dist([3,4], [-3, -4]) == 10"
    );
    
    // VecMath.dot
    assert(
        VecMath.dot([1, 2, 3], [-1, -2, -3]) == -14,
        "VecMath.dot([1, 2, 3], [-1, -2, -3]) == -14"
    );
    assert(
        VecMath.dot([1,0], [0,1]) == 0,
        "VecMath.dot([1,0], [0,1]) == 0"
    );
    assert(
        VecMath.dot([1,0], [0,-1]) == 0,
        "VecMath.dot([1,0], [0,-1]) == 0"
    );
    assert(
        VecMath.dot([1,0], [-1, 0]) == -1,
        "VecMath.dot([1,0], [-1, 0]) == -1"
    );
    assert(
        VecMath.dot([1,0], [1, 0]) == 1,
        "VecMath.dot([1,0], [1, 0]) == 1"
    );
    
    // VecMath.length
    assert(
        VecMath.length([1,0,0]) == 1,
        "VecMath.length([1,0,0]) == 1"
    );
    assert(
        VecMath.length([3,4]) == 5,
        "VecMath.length([3,4]) == 5"
    );
    assert(
        VecMath.length([-3, 0, 4, 0]) == 5,
        "VecMath.length([-3, 0, 4, 0]) == 5"
    );
    
    // VecMath.normalize
    assert(
        VecMath.equal(
            VecMath.normalize([3,0]),
            [1, 0]
        ),
        "VecMath.normalize([3,0]) equals [1,0]"
    );
    assert(
        VecMath.equal(
            VecMath.normalize([0,-3]),
            [0, -1]
        ),
        "VecMath.normalize([0,-3]) equals [0,-1]"
    );
    
    // VecMath.projection
    assert(
        VecMath.equal(
            VecMath.projection([5,0], [3, 4]),
            [3, 0]
        ),
        "VecMath.projection([5,0], [3, 4]) equals [3, 0]"
    );
    assert(
        VecMath.equal(
            VecMath.projection([5,5], [0, 6]),
            [3, 3],
            0.001
        ),
        "VecMath.projection([5,5], [0, 6]) equals [3, 3]"
    );
    
    // VecMath.ptLineDist
    assert(
        VecMath.ptLineDist([0,3], [-100,5], [100,5]) == 2,
        "VecMath.ptLineDist([0,3], [-100,5], [100,5]) == 2"
    );
    assert(
        VecMath.ptLineDist([3,0], [5,5], [5,10]) == 2,
        "VecMath.ptLineDist([3,0], [5,5], [5,10]) == 2"
    );
    
    // VecMath.ptSegDist
    assert(
        VecMath.ptSegDist([0,3], [-5,5], [5,5]) == 2,
        "VecMath.ptSegDist([0,3], [-5,5], [5,5]) == 2"
    );
    assert(
        VecMath.ptSegDist([3,0], [5,-5], [5,5]) == 2,
        "VecMath.ptSegDist([3,0], [5,-5], [5,5]) == 2"
    );
    assert(
        VecMath.ptSegDist([3,4], [-5,0], [0,0]) == 5,
        "VecMath.ptSegDist([3,4], [-5,0], [0,0]) == 5"
    );
    assert(
        VecMath.ptSegDist([-2,-4], [1,0], [5,0]) == 5,
        "VecMath.ptSegDist([-2,-4], [1,0], [5,0]) == 5"
    );
    
    // VecMath.scalarProjection
    assert(
        VecMath.scalarProjection([5,0], [3, 4]) == 3,
        "VecMath.scalarProjection([5,0], [3, 4]) == 3"
    );
    
    // VecMath.scale
    assert(
        VecMath.equal(
            VecMath.scale([1,-2,3], 6),
            [6, -12, 18]
        ),
        "VecMath.scale([1,-2,3], 6) equals [6, -12, 18]"
    );
    
    // VecMath.sub
    assert(
        VecMath.equal(
            VecMath.sub([10, 8, 6], [-4, 6, 1]),
            [14, 2, 5]
        ),
        "VecMath.sub([10, 8, 6], [-4, 6, 1]) equals [14, 2, 5]"
    );
    
    // VecMath.vec
    assert(
        VecMath.equal(
            VecMath.vec([1,1], [3,4]),
            [2,3]
        ),
        "VecMath.vec([1,1], [3,4]) equals [2,3]"
    );
})();

}).toString());



EXT_LIB_API_SCRIPTS.push((function lib_script_8 () {
/**
 * This script provides a library for performing affine matrix operations
 * inspired by the [glMatrix library](http://glmatrix.net/) developed by
 * Toji and SinisterChipmunk.
 *
 * Unlike glMatrix, this library does not have operations for vectors.
 * However, my VectorMath script provides a library providing many kinds of
 * common vector operations.
 *
 * This project has no behavior on its own, but its functions are used by
 * other scripts to do some cool things, particular for math involving 2D and
 * 3D geometry.
 */
var MatrixMath = (function() {
  /**
   * An NxN square matrix, represented as a 2D array of numbers in column-major
   * order. For example, mat[3][2] would get the value in column 3 and row 2.
   * order.
   * @typedef {number[][]} Matrix
   */

  /**
   * An N-degree vector.
   * @typedef {number[]} Vector
   */

  /**
   * Gets the adjugate of a matrix, the tranpose of its cofactor matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function adjoint(mat) {
    var cofactorMat = MatrixMath.cofactorMatrix(mat);
    return MatrixMath.transpose(cofactorMat);
  }

   /**
    * Produces a clone of an NxN square matrix.
    * @param  {Matrix} mat
    * @return {Matrix}
    */
  function clone(mat) {
    return _.map(mat, function(column) {
      return _.map(column, function(value) {
        return value;
      });
    });
  }

  /**
   * Gets the cofactor of a matrix at a specified column and row.
   * @param  {Matrix} mat
   * @param  {uint} col
   * @param  {uint} row
   * @return {number}
   */
  function cofactor(mat, col, row) {
    return Math.pow(-1, col+row)*MatrixMath.minor(mat, col, row);
  }

  /**
   * Gets the cofactor matrix of a matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function cofactorMatrix(mat) {
    var result = [];
    var size = MatrixMath.size(mat);
    for(var col=0; col<size; col++) {
      result[col] = [];
      for(var row=0; row<size; row++) {
        result[col][row] = MatrixMath.cofactor(mat, col, row);
      }
    }
    return result;
  }

  /**
   * Gets the determinant of an NxN matrix.
   * @param  {Matrix} mat
   * @return {number}
   */
  function determinant(mat) {
    var size = MatrixMath.size(mat);

    if(size === 2)
      return mat[0][0]*mat[1][1] - mat[1][0]*mat[0][1];
    else {
      var sum = 0;
      for(var col=0; col<size; col++) {
        sum += mat[col][0] * MatrixMath.cofactor(mat, col, 0);
      }
      return sum;
    }
  }

  /**
   * Tests if two matrices are equal.
   * @param  {Matrix} a
   * @param  {Matrix} b
   * @param {number} [tolerance=0]
   *        If specified, this specifies the amount of tolerance to use for
   *        each value of the matrices when testing for equality.
   * @return {boolean}
   */
  function equal(a, b, tolerance) {
    tolerance = tolerance || 0;
    var sizeA = MatrixMath.size(a);
    var sizeB = MatrixMath.size(b);

    if(sizeA !== sizeB)
      return false;

    for(var col=0; col<sizeA; col++) {
      for(var row=0; row<sizeA; row++) {
        if(Math.abs(a[col][row] - b[col][row]) > tolerance)
          return false;
      }
    }
    return true;
  }

  /**
   * Produces an identity matrix of some size.
   * @param  {uint} size
   * @return {Matrix}
   */
  function identity(size) {
    var mat = [];
    for(var col=0; col<size; col++) {
      mat[col] = [];
      for(var row=0; row<size; row++) {
        if(row === col)
          mat[col][row] = 1;
        else
          mat[col][row] = 0;
      }
    }
    return mat;
  }

  /**
   * Gets the inverse of a matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function inverse(mat) {
    var determinant = MatrixMath.determinant(mat);
    if(determinant === 0)
      return undefined;

    var adjoint = MatrixMath.adjoint(mat);
    var result = [];
    var size = MatrixMath.size(mat);
    for(var col=0; col<size; col++) {
      result[col] = [];
      for(var row=0; row<size; row++) {
        result[col][row] = adjoint[col][row]/determinant;
      }
    }
    return result;
  }

  /**
   * Gets the determinant of a matrix omitting some column and row.
   * @param  {Matrix} mat
   * @param  {uint} col
   * @param  {uint} row
   * @return {number}
   */
  function minor(mat, col, row) {
    var reducedMat = MatrixMath.omit(mat, col, row);
    return determinant(reducedMat);
  }


  /**
   * Returns the matrix multiplication of a*b.
   * This function works for non-square matrices (and also for transforming
   * vectors by a matrix).
   * For matrix multiplication to work, the # of columns in A must be equal
   * to the # of rows in B.
   * The resulting matrix will have the same number of rows as A and the
   * same number of columns as B.
   * If b was given as a vector, then the result will also be a vector.
   * @param  {Matrix} a
   * @param  {Matrix|Vector} b
   * @return {Matrix|Vector}
   */
  function multiply(a, b) {
    // If a vector is given for b, convert it to a nx1 matrix, where n
    // is the length of b.
    var bIsVector = _.isNumber(b[0]);
    if(bIsVector)
      b = [b];

    var colsA = a.length;
    var rowsA = a[0].length;
    var colsB = b.length;
    var rowsB = b[0].length;
    if(colsA !== rowsB)
      throw new Error('MatrixMath.multiply ERROR: # columns in A must be ' +
        'the same as the # rows in B. Got A: ' + rowsA + 'x' + colsA +
        ', B: ' + rowsB + 'x' + colsB + '.');

    var result = [];
    for(var col=0; col<colsB; col++) {
      result[col] = [];
      for(var row=0; row<rowsA; row++) {
        result[col][row] = 0;
        for(var i=0; i<colsA; i++) {
          result[col][row] += a[i][row] * b[col][i];
        }
      }
    }

    if(bIsVector)
      result = result[0];
    return result;
  }

  /**
   * Returns a matrix with a column and row omitted.
   * @param  {Matrix} mat
   * @param  {uint} col
   * @param  {uint} row
   * @return {Matrix}
   */
  function omit(mat, col, row) {
    var result = [];

    var size = MatrixMath.size(mat);
    for(var i=0; i<size; i++) {
      if(i === col)
        continue;

      var column = [];
      result.push(column);
      for(var j=0; j<size; j++) {
        if(j !== row)
          column.push(mat[i][j]);
      }
    }
    return result;
  }

  /**
   * Produces a 2D rotation affine transformation. The direction of the
   * rotation depends upon the coordinate system.
   * @param  {number} angle
   *         The angle, in radians.
   * @return {Matrix}
   */
  function rotate(angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return [[cos, sin, 0], [-sin, cos, 0], [0,0,1]];
  }

  /**
   * Produces a 2D scale affine transformation matrix.
   * The matrix is used to transform homogenous coordinates, so it is
   * actually size 3 instead of size 2, despite being used for 2D geometry.
   * @param  {(number|Vector)} amount
   *         If specified as a number, then it is a uniform scale. Otherwise,
   *         it defines a scale by parts.
   * @return {Matrix}
   */
  function scale(amount) {
    if(_.isNumber(amount))
      amount = [amount, amount];
    return [[amount[0], 0, 0], [0, amount[1], 0], [0, 0, 1]];
  }

  /**
   * Gets the size N of a NxN square matrix.
   * @param  {Matrix} mat
   * @return {uint}
   */
  function size(mat) {
    return mat[0].length;
  }

  /**
   * Produces a 2D translation affine transformation matrix.
   * The matrix is used to transform homogenous coordinates, so it is
   * actually size 3 instead of size 2, despite being used for 2D geometry.
   * @param  {Vector} vec
   * @return {Matrix}
   */
  function translate(vec) {
    return [[1,0,0], [0,1,0],[vec[0], vec[1], 1]];
  }

  /**
   * Returns the transpose of a matrix.
   * @param  {Matrix} mat
   * @return {Matrix}
   */
  function transpose(mat) {
    var result = [];

    var size = MatrixMath.size(mat);
    for(var col=0; col<size; col++) {
      result[col] = [];
      for(var row=0; row<size; row++) {
        result[col][row] = mat[row][col];
      }
    }
    return result;
  }


  return {
    adjoint: adjoint,
    clone: clone,
    cofactor: cofactor,
    cofactorMatrix: cofactorMatrix,
    determinant: determinant,
    equal: equal,
    identity: identity,
    inverse: inverse,
    minor: minor,
    multiply: multiply,
    omit: omit,
    rotate: rotate,
    scale: scale,
    size: size,
    translate: translate,
    transpose: transpose
  };
})();



// Perform unit tests. Inform us in the log if any test fails. Otherwise,
// succeed silently.
(function() {
  /**
   * Asserts that some boolean expression is true. Otherwise, it throws
   * an error.
   * @param {boolean} test    Some expression to test.
   * @param {string} failMsg  A message displayed if the test fails.
   */
  function assert(test, failMsg) {
    if(!test)
      throw new Error(failMsg);
  }

  function assertEqual(actual, expected, tolerance) {
    assert(MatrixMath.equal(actual, expected, tolerance),
      'Expected: ' + JSON.stringify(expected) +
      '\nActual: ' + JSON.stringify(actual));
  }

  /**
   * Performs a unit test.
   * If it fails, then the test's name and the error is displayed.
   * It is silent if the test passes.
   * @param  {string} testName
   * @param  {function} testFn
   */
  function unitTest(testName, testFn) {
    try {
      testFn();
    }
    catch(err) {
      log('TEST ' + testName);
      log('ERROR: ');
      var messageLines = err.message.split('\n');
      _.each(messageLines, function(line) {
        log(line);
      });
    }
  }


  unitTest('MatrixMath.equal()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var b = [[1,2,3], [4,5,6], [7,8,9]];
    var c = [[0,0,0], [1,1,1], [2,2,2]];
    assert(MatrixMath.equal(a,b));
    assert(!MatrixMath.equal(a,c));
  });

  unitTest('MatrixMath.adjoint()', function() {
    // Example taken from http://www.mathwords.com/a/adjoint.htm
    var a = [[1,0,1], [2,4,0], [3,5,6]];

    var actual = MatrixMath.adjoint(a);
    var expected = [[24, 5, -4], [-12,3,2], [-2,-5,4]];

    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.clone()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var clone = MatrixMath.clone(a);
    assertEqual(a, clone);
    assert(a !== clone, 'should not be equal by reference.');
  });

  unitTest('MatrixMath.cofactor()', function() {
    // Example taken from http://www.mathwords.com/c/cofactor_matrix.htm.
    var a = [[1,0,1], [2,4,0], [3,5,6]];

    var actual = MatrixMath.cofactor(a,0,0);
    var expected = 24;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,1,0);
    var expected = 5;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,2,0);
    var expected = -4;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,0,1);
    var expected = -12;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,1,1);
    var expected = 3;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,2,1);
    var expected = 2;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,0,2);
    var expected = -2;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,1,2);
    var expected = -5;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var actual = MatrixMath.cofactor(a,2,2);
    var expected = 4;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);
  });

  unitTest('MatrixMath.cofactorMatrix()', function() {
    // Example taken from http://www.mathwords.com/c/cofactor_matrix.htm.
    var a = [[1,0,1], [2,4,0], [3,5,6]];
    var actual = MatrixMath.cofactorMatrix(a);
    var expected = [[24, -12, -2], [5, 3, -5], [-4, 2, 4]];
    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.determinant()', function() {
    var a = [[1,2], [3,4]];
    var actual = MatrixMath.determinant(a);
    var expected = -2;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);

    var a = [[1,5,0,2], [3,1,1,-1], [-2,0,0,0], [1,-1,-2,3]];
    var actual = MatrixMath.determinant(a);
    var expected = -6;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);
  });

  unitTest('MatrixMath.identity()', function() {
    var actual = MatrixMath.identity(3);
    var expected = [[1,0,0], [0,1,0], [0,0,1]];
    assertEqual(actual, expected);

    var actual = MatrixMath.identity(2);
    var expected = [[1,0], [0,1]];
    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.inverse()', function() {
    // Example taken from http://www.mathwords.com/i/inverse_of_a_matrix.htm
    var a = [[1,0,1], [2,4,0], [3,5,6]];
    var actual = MatrixMath.inverse(a);
    var expected = [[12/11, 5/22, -2/11],
                    [-6/11, 3/22, 1/11],
                    [-1/11, -5/22, 2/11]];
    assertEqual(actual, expected);

    var inverse = MatrixMath.multiply(a, actual);
    var expected = MatrixMath.identity(3);
    assertEqual(inverse, expected, 0.001);
  });

  unitTest('MatrixMath.minor()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var actual = MatrixMath.minor(a, 1, 1);
    var expected = -12;
    assert(actual === expected, 'Got ' + actual + '\nExpected ' + expected);
  });

  unitTest('MatrixMath.multiply()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var b = [[9,8,7], [6,5,4], [3,2,1]];
    var actual = MatrixMath.multiply(a,b);
    var expected = [[90, 114, 138], [54,69,84], [18,24,30]];
    assertEqual(actual, expected);
  });

  unitTest('Matrix.multiply() to transform a vector', function() {
    // A 2D point in homogenous coordinates.
    var pt = [1,2,1];

    var scale = MatrixMath.scale([10,20]);
    var rotate = MatrixMath.rotate(Math.PI/2);
    var translate = MatrixMath.translate([2,-8]);

    var m = MatrixMath.multiply(scale, rotate);
    m = MatrixMath.multiply(m, translate);

    // Transform the point.
    var actual = MatrixMath.multiply(m, pt);
    var expected = [60, 60, 1];
    assertEqual(actual, expected, 0.01);
  });

  unitTest('MatrixMath.omit()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var actual = MatrixMath.omit(a, 1, 2);
    var expected = [[1,2], [7,8]];
    assertEqual(actual, expected);
  });

  unitTest('MatrixMath.size()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    assert(MatrixMath.size(a) === 3);

    var b = [[1,2],[3,4]];
    assert(MatrixMath.size(b) === 2);
  });

  unitTest('MatrixMath.transpose()', function() {
    var a = [[1,2,3], [4,5,6], [7,8,9]];
    var expected = [[1,4,7], [2,5,8], [3,6,9]];
    var transpose = MatrixMath.transpose(a);
    assertEqual(transpose, expected);
  });



})();

}).toString());



EXT_LIB_API_SCRIPTS.push((function lib_script_9 () {
/**
 * PathMath script
 *
 * This is a library that provides mathematical operations involving Paths.
 * It intended to be used by other scripts and has no stand-alone
 * functionality of its own. All the library's operations are exposed by the
 * PathMath object created by this script.
 */
var PathMath = (() => {
    'use strict';

    /**
     * A vector used to define a homogeneous point or a direction.
     * @typedef {number[]} Vector
     */

    /**
     * A line segment defined by two homogeneous 2D points.
     * @typedef {Vector[]} Segment
     */

    /**
     * Information about a path's 2D transform.
     * @typedef {Object} PathTransformInfo
     * @property {number} angle
     *           The path's rotation angle in radians.
     * @property {number} cx
     *           The x coordinate of the center of the path's bounding box.
     * @property {number} cy
     *           The y coordinate of the center of the path's bounding box.
     * @property {number} height
     *           The unscaled height of the path's bounding box.
     * @property {number} scaleX
     *           The path's X-scale.
     * @property {number} scaleY
     *           The path's Y-scale.
     * @property {number} width
     *           The unscaled width of the path's bounding box.
     */

    /**
     * Rendering information for shapes.
     * @typedef {Object} RenderInfo
     * @property {string} [controlledby]
     * @property {string} [fill]
     * @property {string} [stroke]
     * @property {string} [strokeWidth]
     */

    /**
     * Some shape defined by a path.
     * @abstract
     */
    class PathShape {
      constructor(vertices) {
        this.vertices = vertices || [];
      }

      /**
       * Gets the distance from this shape to some point.
       * @abstract
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        throw new Error('Must be defined by subclass.');
      }

      /**
       * Gets the bounding box of this shape.
       * @return {BoundingBox}
       */
      getBoundingBox() {
        if(!this._bbox) {
          let left, right, top, bottom;
          _.each(this.vertices, (v, i) => {
            if(i === 0) {
              left = v[0];
              right = v[0];
              top = v[1];
              bottom = v[1];
            }
            else {
              left = Math.min(left, v[0]);
              right = Math.max(right, v[0]);
              top = Math.min(top, v[1]);
              bottom = Math.max(bottom, v[1]);
            }
          });
          let width = right - left;
          let height = bottom - top;
          this._bbox = new BoundingBox(left, top, width, height);
        }
        return this._bbox;
      }

      /**
       * Checks if this shape intersects another shape.
       * @abstract
       * @param {PathShape} other
       * @return {boolean}
       */
      intersects(other) {
        throw new Error('Must be defined by subclass.');
      }

      /**
       * Renders this path.
       * @param {string} pageId
       * @param {string} layer
       * @param {RenderInfo} renderInfo
       */
      render(pageId, layer, renderInfo) {
        let segments = this.toSegments();
        let pathData = segmentsToPath(segments);
        _.extend(pathData, renderInfo, {
          _pageid: pageId,
          layer
        });
        createObj('path', pathData);
      }

      /**
       * Returns the segments that make up this shape.
       * @abstract
       * @return {Segment[]}
       */
      toSegments() {
        throw new Error('Must be defined by subclass.');
      }

      /**
       * Produces a copy of this shape, transformed by an affine
       * transformation matrix.
       * @param {MatrixMath.Matrix} matrix
       * @return {PathShape}
       */
      transform(matrix) {
        let vertices = _.map(this.vertices, v => {
          return MatrixMath.multiply(matrix, v);
        });
        let Clazz = this.constructor;
        return new Clazz(vertices);
      }
    }

    /**
     * An open shape defined by a path or list of vertices.
     */
    class Path extends PathShape {

      /**
       * @param {(Roll20Path|vec3[])} path
       */
      constructor(path) {
        super();
        if(_.isArray(path))
          this.vertices = path;
        else {
          this._segments = toSegments(path);
          _.each(this._segments, (seg, i) => {
            if(i === 0)
              this.vertices.push(seg[0]);
            this.vertices.push(seg[1]);
          });
        }

        this.numVerts = this.vertices.length;
      }

      /**
       * Gets the distance from this path to some point.
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        let dist = _.chain(this.toSegments())
        .map(seg => {
          let [ p, q ] = seg;
          return VecMath.ptSegDist(pt, p, q);
        })
        .min()
        .value();
        return dist;
      }

      /**
       * Checks if this path intersects with another path.
       * @param {Polygon} other
       * @return {boolean}
       */
      intersects(other) {
        let thisBox = this.getBoundingBox();
        let otherBox = other.getBoundingBox();

        // If the bounding boxes don't intersect, then the paths won't
        // intersect.
        if(!thisBox.intersects(otherBox))
          return false;

        // Naive approach: Since our shortcuts didn't return, check each
        // path's segments for intersections with each of the other
        // path's segments. This takes O(n^2) time.
        return !!_.find(this.toSegments(), seg1 => {
          return !!_.find(other.toSegments(), seg2 => {
            return !!segmentIntersection(seg1, seg2);
          });
        });
      }

      /**
       * Produces a list of segments defining this path.
       * @return {Segment[]}
       */
      toSegments() {
        if(!this._segments) {
          this._segments = _.map(_.range(this.numVerts - 1), i => {
            let v = this.vertices[i];
            let vNext = this.vertices[i + 1];
            return [v, vNext];
          });
        }
        return this._segments;
      }
    }

    /**
     * A closed shape defined by a path or a list of vertices.
     */
    class Polygon extends PathShape {

      /**
       * @param {(Roll20Path|vec3[])} path
       */
      constructor(path) {
        super();
        if(_.isArray(path))
          this.vertices = path;
        else {
          this._segments = toSegments(path);
          this.vertices = _.map(this._segments, seg => {
            return seg[0];
          });
        }

        this.numVerts = this.vertices.length;
        if(this.numVerts < 3)
          throw new Error('A polygon must have at least 3 vertices.');
      }

      /**
       * Determines whether a point lies inside the polygon using the
       * winding algorithm.
       * See: http://geomalgorithms.com/a03-_inclusion.html
       * @param {vec3} p
       * @return {boolean}
       */
      containsPt(p) {
        // A helper function that tests if a point is "left" of a line segment.
        let _isLeft = (p0, p1, p2) => {
          return (p1[0] - p0[0])*(p2[1] - p0[1]) - (p2[0]-p0[0])*(p1[1]-p0[1]);
        };

        let total = 0;
        _.each(this.vertices, (v1, i) => {
          let v2 = this.vertices[(i+1) % this.numVerts];

          // Check for valid up intersect.
          if(v1[1] <= p[1] && v2[1] > p[1]) {
            if(_isLeft(v1, v2, p) > 0)
              total++;
          }

          // Check for valid down intersect.
          else if(v1[1] > p[1] && v2[1] <= p[1]) {
            if(_isLeft(v1, v2, p) < 0)
              total--;
          }
        });
        return !!total; // We are inside if our total windings are non-zero.
      }

      /**
       * Gets the distance from this polygon to some point.
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        if(this.containsPt(pt))
          return 0;
        else
          return _.chain(this.toSegments())
          .map(seg => {
            let [ p, q ] = seg;
            return VecMath.ptSegDist(pt, p, q);
          })
          .min()
          .value();
      }

      /**
       * Gets the area of this polygon.
       * @return {number}
       */
      getArea() {
        let triangles = this.tessellate();
        return _.reduce(triangles, (area, tri) => {
          return area + tri.getArea();
        }, 0);
      }

      /**
       * Determines whether each vertex along the polygon is convex (1)
       * or concave (-1). A vertex lying on a straight line is assined 0.
       * @return {int[]}
       */
      getConvexness() {
        return Polygon.getConvexness(this.vertices);
      }

      /**
       * Gets the convexness information about each vertex.
       * @param {vec3[]}
       * @return {int[]}
       */
      static getConvexness(vertices) {
        let totalAngle = 0;
        let numVerts = vertices.length;
        let vertexCurves = _.map(vertices, (v, i) => {
          let vPrev = vertices[(i-1 + numVerts) % numVerts];
          let vNext = vertices[(i+1 + numVerts) % numVerts];

          let u = VecMath.sub(v, vPrev);
          let w = VecMath.sub(vNext, v);
          let uHat = VecMath.normalize(u);
          let wHat = VecMath.normalize(w);

          let cross = VecMath.cross(uHat, wHat);
          let sign = cross[2];
          if(sign)
            sign = sign/Math.abs(sign);

          let dot = VecMath.dot(uHat, wHat);
          let angle = Math.acos(dot)*sign;
          totalAngle += angle;

          return sign;
        });

        if(totalAngle < 0)
          return _.map(vertexCurves, curve => {
            return -curve;
          });
        else
          return vertexCurves;
      }

      /**
       * Checks if this polygon intersects with another polygon.
       * @param {(Polygon|Path)} other
       * @return {boolean}
       */
      intersects(other) {
        let thisBox = this.getBoundingBox();
        let otherBox = other.getBoundingBox();

        // If the bounding boxes don't intersect, then the polygons won't
        // intersect.
        if(!thisBox.intersects(otherBox))
          return false;

        // If either polygon contains the first point of the other, then
        // they intersect.
        if(this.containsPt(other.vertices[0]) ||
          (other instanceof Polygon && other.containsPt(this.vertices[0])))
          return true;

        // Naive approach: Since our shortcuts didn't return, check each
        // polygon's segments for intersections with each of the other
        // polygon's segments. This takes O(n^2) time.
        return !!_.find(this.toSegments(), seg1 => {
          return !!_.find(other.toSegments(), seg2 => {
            return !!segmentIntersection(seg1, seg2);
          });
        });
      }

      /**
       * Checks if this polygon intersects a Path.
       * @param {Path} path
       * @return {boolean}
       */
      intersectsPath(path) {
        let segments1 = this.toSegments();
        let segments2 = PathMath.toSegments(path);

        // The path intersects if any point is inside this polygon.
        if(this.containsPt(segments2[0][0]))
          return true;

        // Check if any of the segments intersect.
        return !!_.find(segments1, seg1 => {
          return _.find(segments2, seg2 => {
            return PathMath.segmentIntersection(seg1, seg2);
          });
        });
      }

      /**
       * Tessellates a closed path representing a simple polygon
       * into a bunch of triangles.
       * @return {Triangle[]}
       */
      tessellate() {
        let triangles = [];
        let vertices = _.clone(this.vertices);

        // Tessellate using ear-clipping algorithm.
        while(vertices.length > 0) {
          if(vertices.length === 3) {
            triangles.push(new Triangle(vertices[0], vertices[1], vertices[2]));
            vertices = [];
          }
          else {
            // Determine whether each vertex is convex, concave, or linear.
            let convexness = Polygon.getConvexness(vertices);
            let numVerts = vertices.length;

            // Find the next ear to clip from the polygon.
            let earIndex = _.find(_.range(numVerts), i => {
              let v = vertices[i];
              let vPrev = vertices[(numVerts + i -1) % numVerts];
              let vNext = vertices[(numVerts + i + 1) % numVerts];

              let vConvexness = convexness[i];
              if(vConvexness === 0) // The vertex lies on a straight line. Clip it.
                return true;
              else if(vConvexness < 0) // The vertex is concave.
                return false;
              else { // The vertex is convex and might be an ear.
                let triangle = new Triangle(vPrev, v, vNext);

                // The vertex is not an ear if there is at least one other
                // vertex inside its triangle.
                return !_.find(vertices, (v2, j) => {
                  if(v2 === v || v2 === vPrev || v2 === vNext)
                    return false;
                  else {
                    return triangle.containsPt(v2);
                  }
                });
              }
            });

            let v = vertices[earIndex];
            let vPrev = vertices[(numVerts + earIndex -1) % numVerts];
            let vNext = vertices[(numVerts + earIndex + 1) % numVerts];
            triangles.push(new Triangle(vPrev, v, vNext));
            vertices.splice(earIndex, 1);
          }
        }
        return triangles;
      }

      /**
       * Produces a list of segments defining this polygon.
       * @return {Segment[]}
       */
      toSegments() {
        if(!this._segments) {
          this._segments = _.map(this.vertices, (v, i) => {
            let vNext = this.vertices[(i + 1) % this.numVerts];
            return [v, vNext];
          });
        }
        return this._segments;
      }
    }

    /**
     * A 3-sided polygon that is great for tessellation!
     */
    class Triangle extends Polygon {
      /**
       * @param {vec3} p1
       * @param {vec3} p2
       * @param {vec3} p3
       */
      constructor(p1, p2, p3) {
        if(_.isArray(p1))
          [p1, p2, p3] = p1;
        super([p1, p2, p3]);

        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
      }

      /**
       * @inheritdoc
       */
      getArea() {
        let base = VecMath.sub(this.p2, this.p1);
        let width = VecMath.length(base);
        let height = VecMath.ptLineDist(this.p3, this.p1, this.p2);

        return width*height/2;
      }
    }

    /**
     * A circle defined by its center point and radius.
     */
    class Circle extends PathShape {

      /**
       * @param {vec3} pt
       * @param {number} r
       */
      constructor(pt, r) {
        super();
        this.center = pt;
        this.radius = r;
        this.diameter = 2*r;
      }

      /**
       * Checks if a point is contained within this circle.
       * @param {vec3} pt
       * @return {boolean}
       */
      containsPt(pt) {
        let dist = VecMath.dist(this.center, pt);
        return dist <= this.radius;
      }

      /**
       * Gets the distance from this circle to some point.
       * @param {vec3} pt
       * @return {number}
       */
      distanceToPoint(pt) {
        if(this.containsPt(pt))
          return 0;
        else {
          return VecMath.dist(this.center, pt) - this.radius;
        }
      }

      /**
       * Gets this circle's area.
       * @return {number}
       */
      getArea() {
        return Math.PI*this.radius*this.radius;
      }

      /**
       * Gets the circle's bounding box.
       * @return {BoundingBox}
       */
      getBoundingBox() {
        let left = this.center[0] - this.radius;
        let top = this.center[1] - this.radius;
        let dia = this.radius*2;
        return new BoundingBox(left, top, dia, dia);
      }

      /**
       * Gets this circle's circumference.
       * @return {number}
       */
      getCircumference() {
        return Math.PI*this.diameter;
      }

      /**
       * Checks if this circle intersects another circle.
       * @param {Circle} other
       * @return {boolean}
       */
      intersects(other) {
        let dist = VecMath.dist(this.center, other.center);
        return dist <= this.radius + other.radius;
      }

      /**
       * Checks if this circle intersects a polygon.
       * @param {Polygon} poly
       * @return {boolean}
       */
      intersectsPolygon(poly) {

        // Quit early if the bounding boxes don't overlap.
        let thisBox = this.getBoundingBox();
        let polyBox = poly.getBoundingBox();
        if(!thisBox.intersects(polyBox))
          return false;

        if(poly.containsPt(this.center))
          return true;
        return !!_.find(poly.toSegments(), seg => {
          return this.segmentIntersection(seg);
        });
      }

      /**
       * Renders this circle.
       * @param {string} pageId
       * @param {string} layer
       * @param {RenderInfo} renderInfo
       */
      render(pageId, layer, renderInfo) {
        let data = createCircleData(this.radius)
        _.extend(data, renderInfo, {
          _pageid: pageId,
          layer,
          left: this.center[0],
          top: this.center[1]
        });
        createObj('path', data);
      }

      /**
       * Gets the intersection coefficient between this circle and a Segment,
       * if such an intersection exists. Otherwise, undefined is returned.
       * @param {Segment} segment
       * @return {Intersection}
       */
      segmentIntersection(segment) {
        if(this.containsPt(segment[0])) {
          let pt = segment[0];
          let s = 0;
          let t = VecMath.dist(this.center, segment[0])/this.radius;
          return [pt, s, t];
        }
        else {
          let u = VecMath.sub(segment[1], segment[0]);
          let uHat = VecMath.normalize(u);
          let uLen = VecMath.length(u);
          let v = VecMath.sub(this.center, segment[0]);

          let height = VecMath.ptLineDist(this.center, segment[0], segment[1]);
          let base = Math.sqrt(this.radius*this.radius - height*height);

          if(isNaN(base))
            return undefined;

          let scalar = VecMath.scalarProjection(u, v)-base;
          let s = scalar/uLen;

          if(s >= 0 && s <= 1) {
            let t = 1;
            let pt = VecMath.add(segment[0], VecMath.scale(uHat, scalar));
            return [pt, s, t];
          }
          else
            return undefined;
        }
      }
    }

    /**
     * The bounding box for a path/polygon.
     */
    class BoundingBox {
      /**
       * @param {Number} left
       * @param {Number} top
       * @param {Number} width
       * @param {Number} height
       */
      constructor(left, top, width, height) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.right = left + width;
        this.bottom = top + height;
      }

      /**
       * Adds two bounding boxes.
       * @param  {BoundingBox} a
       * @param  {BoundingBox} b
       * @return {BoundingBox}
       */
      static add(a, b) {
        var left = Math.min(a.left, b.left);
        var top = Math.min(a.top, b.top);
        var right = Math.max(a.left + a.width, b.left + b.width);
        var bottom = Math.max(a.top + a.height, b.top + b.height);

        return new BoundingBox(left, top, right - left, bottom - top);
      }

      /**
       * Gets the area of this bounding box.
       * @return {number}
       */
      getArea() {
        return this.width * this.height;
      }

      /**
       * Checks if this bounding box intersects another bounding box.
       * @param {BoundingBox} other
       * @return {boolean}
       */
      intersects(other) {
        return !( this.left > other.right ||
                  this.right < other.left ||
                  this.top > other.bottom ||
                  this.bottom < other.top);
      }

      /**
       * Renders the bounding box.
       * @param {string} pageId
       * @param {string} layer
       * @param {RenderInfo} renderInfo
       */
      render(pageId, layer, renderInfo) {
        let verts = [
          [this.left, this.top, 1],
          [this.right, this.top, 1],
          [this.right, this.bottom, 1],
          [this.left, this.bottom, 1]
        ];
        let poly = new Polygon(verts);
        poly.render(pageId, layer, renderInfo);
      }
    }

    /**
     * Returns the partial path data for creating a circular path.
     * @param  {number} radius
     * @param {int} [sides]
     *        If specified, then a polygonal path with the specified number of
     *        sides approximating the circle will be created instead of a true
     *        circle.
     * @return {PathData}
     */
    function createCircleData(radius, sides) {
      var _path = [];
      if(sides) {
        var cx = radius;
        var cy = radius;
        var angleInc = Math.PI*2/sides;
        path.push(['M', cx + radius, cy]);
        _.each(_.range(1, sides+1), function(i) {
          var angle = angleInc*i;
          var x = cx + radius*Math.cos(angle);
          var y = cy + radius*Math.sin(angle);
          path.push(['L', x, y]);
        });
      }
      else {
        var r = radius;
        _path = [
          ['M', 0,      r],
          ['C', 0,      r*0.5,  r*0.5,  0,      r,      0],
          ['C', r*1.5,  0,      r*2,    r*0.5,  r*2.0,  r],
          ['C', r*2.0,  r*1.5,  r*1.5,  r*2.0,  r,      r*2.0],
          ['C', r*0.5,  r*2,    0,      r*1.5,  0,      r]
        ];
      }
      return {
        height: radius*2,
        _path: JSON.stringify(_path),
        width: radius*2
      };
    }

    /**
     * Computes the distance from a point to some path.
     * @param {vec3} pt
     * @param {(Roll20Path|PathShape)} path
     */
    function distanceToPoint(pt, path) {
      if(!(path instanceof PathShape))
        path = new Path(path);
      return path.distanceToPoint(pt);
    }

    /**
     * Gets a point along some Bezier curve of arbitrary degree.
     * @param {vec3[]} points
     *        The points of the Bezier curve. The points between the first and
     *        last point are the control points.
     * @param {number} scalar
     *        The parametric value for the point we want along the curve.
     *        This value is expected to be in the range [0, 1].
     * @return {vec3}
     */
    function getBezierPoint(points, scalar) {
      if(points.length < 2)
        throw new Error('Bezier curve cannot have less than 2 points.');
      else if(points.length === 2) {
        let u = VecMath.sub(points[1], points[0]);
        u = VecMath.scale(u, scalar);
        return VecMath.add(points[0], u);
      }
      else {
        let newPts = _.chain(points)
        .map((cur, i) => {
          if(i === 0)
            return undefined;

          let prev = points[i-1];
          return getBezierPoint([prev, cur], scalar);
        })
        .compact()
        .value();

        return getBezierPoint(newPts, scalar);
      }
    }


    /**
     * Calculates the bounding box for a list of paths.
     * @param {Roll20Path | Roll20Path[]} paths
     * @return {BoundingBox}
     */
    function getBoundingBox(paths) {
      if(!_.isArray(paths))
        paths = [paths];

      var result;
      _.each(paths, function(p) {
        var pBox = _getSingleBoundingBox(p);
        if(result)
          result = BoundingBox.add(result, pBox);
        else
          result = pBox;
      });
      return result;
    }

    /**
     * Returns the center of the bounding box countaining a path or list
     * of paths. The center is returned as a 2D homongeneous point
     * (It has a third component which is always 1 which is helpful for
     * affine transformations).
     * @param {(Roll20Path|Roll20Path[])} paths
     * @return {Vector}
     */
    function getCenter(paths) {
        if(!_.isArray(pathjs))
            paths = [paths];

        var bbox = getBoundingBox(paths);
        var cx = bbox.left + bbox.width/2;
        var cy = bbox.top + bbox.height/2;

        return [cx, cy, 1];
    }

    /**
     * @private
     * Calculates the bounding box for a single path.
     * @param  {Roll20Path} path
     * @return {BoundingBox}
     */
    function _getSingleBoundingBox(path) {
        var pathData = normalizePath(path);

        var width = pathData.width;
        var height = pathData.height;
        var left = pathData.left - width/2;
        var top = pathData.top - height/2;

        return new BoundingBox(left, top, width, height);
    }

    /**
     * Gets the 2D transform information about a path.
     * @param  {Roll20Path} path
     * @return {PathTransformInfo}
     */
    function getTransformInfo(path) {
        var scaleX = path.get('scaleX');
        var scaleY = path.get('scaleY');
        var angle = path.get('rotation')/180*Math.PI;

        // The transformed center of the path.
        var cx = path.get('left');
        var cy = path.get('top');

        // The untransformed width and height.
        var width = path.get('width');
        var height = path.get('height');

        return {
            angle: angle,
            cx: cx,
            cy: cy,
            height: height,
            scaleX: scaleX,
            scaleY: scaleY,
            width: width
        };
    }

    /**
     * Checks if a path is closed, and is therefore a polygon.
     * @param {(Roll20Path|Segment[])}
     * @return {boolean}
     */
    function isClosed(path) {
      // Convert to segments.
      if(!_.isArray(path))
        path = toSegments(path);
      return (_.isEqual(path[0][0], path[path.length-1][1]));
    }


    /**
     * Produces a merged path string from a list of path objects.
     * @param {Roll20Path[]} paths
     * @return {String}
     */
    function mergePathStr(paths) {
        var merged = [];
        var bbox = getBoundingBox(paths);

        _.each(paths, function(p) {
            var pbox = getBoundingBox(p);

            // Convert the path to a normalized polygonal path.
            p = normalizePath(p);
            var parsed = JSON.parse(p._path);
            _.each(parsed, function(pathTuple, index) {
                var dx = pbox.left - bbox.left;
                var dy = pbox.top - bbox.top;

                // Move and Line tuples
                var x = pathTuple[1] + dx;
                var y = pathTuple[2] + dy;
                merged.push([pathTuple[0], x, y]);
            });
        });

        return JSON.stringify(merged);
    }

    /**
     * Reproduces the data for a polygonal path such that the scales are 1 and
     * its rotate is 0.
     * This can also normalize freehand paths, but they will be converted to
     * polygonal paths. The quatric Bezier curves used in freehand paths are
     * so short though, that it doesn't make much difference though.
     * @param {Roll20Path}
     * @return {PathData}
     */
    function normalizePath(path) {
        var segments = toSegments(path);
        return segmentsToPath(segments);
    }

    /**
     * Computes the intersection between the projected lines of
     * two homogenous 2D line segments.
     *
     * Explanation of the fancy mathemagics:
     * Let A be the first point in seg1 and B be the second point in seg1.
     * Let C be the first point in seg2 and D be the second point in seg2.
     * Let U be the vector from A to B.
     * Let V be the vector from C to D.
     * Let UHat be the unit vector of U.
     * Let VHat be the unit vector of V.
     *
     * Observe that if the dot product of UHat and VHat is 1 or -1, then
     * seg1 and seg2 are parallel, so they will either never intersect or they
     * will overlap. We will ignore the case where seg1 and seg2 are parallel.
     *
     * We can represent any point P along the line projected by seg1 as
     * P = A + SU, where S is some scalar value such that S = 0 yeilds A,
     * S = 1 yields B, and P is on seg1 if and only if 0 <= S <= 1.
     *
     * We can also represent any point Q along the line projected by seg2 as
     * Q = C + TV, where T is some scalar value such that T = 0 yeilds C,
     * T = 1 yields D, and Q is on seg2 if and only if 0 <= T <= 1.
     *
     * Assume that seg1 and seg2 are not parallel and that their
     * projected lines intersect at some point P.
     * Therefore, we have A + SU = C + TV.
     *
     * We can rearrange this such that we have C - A = SU - TV.
     * Let vector W = C - A, thus W = SU - TV.
     * Also, let coeffs = [S, T, 1].
     *
     * We can now represent this system of equations as the matrix
     * multiplication problem W = M * coeffs, where in column-major
     * form, M = [U, -V, [0,0,1]].
     *
     * By matrix-multiplying both sides by M^-1, we get
     * M^-1 * W = M^-1 * M * coeffs = coeffs, from which we can extract the
     * values for S and T.
     *
     * We can now get the point of intersection on the projected lines of seg1
     * and seg2 by substituting S in P = A + SU or T in Q = C + TV.
     *
     * @param {Segment} seg1
     * @param {Segment} seg2
     * @return {Intersection}
     *      The point of intersection in homogenous 2D coordiantes and its
     *      scalar coefficients along seg1 and seg2,
     *      or undefined if the segments are parallel.
     */
    function raycast(seg1, seg2) {
      var u = VecMath.sub(seg1[1], seg1[0]);
      var v = VecMath.sub(seg2[1], seg2[0]);
      var w = VecMath.sub(seg2[0], seg1[0]);

      // Can't use 0-length vectors.
      if(VecMath.length(u) === 0 || VecMath.length(v) === 0)
          return undefined;

      // If the two segments are parallel, then either they never intersect
      // or they overlap. Either way, return undefined in this case.
      var uHat = VecMath.normalize(u);
      var vHat = VecMath.normalize(v);
      var uvDot = VecMath.dot(uHat,vHat);
      if(Math.abs(uvDot) > 0.9999)
          return undefined;

      // Build the inverse matrix for getting the intersection point's
      // parametric coefficients along the projected segments.
      var m = [[u[0], u[1], 0], [-v[0], -v[1], 0], [0, 0, 1]];
      var mInv = MatrixMath.inverse(m);

      // Get the parametric coefficients for getting the point of intersection
      // on the projected semgents.
      var coeffs = MatrixMath.multiply(mInv, w);
      var s = coeffs[0];
      var t = coeffs[1];

      var uPrime = VecMath.scale(u, s);
      return [VecMath.add(seg1[0], uPrime), s, t];
    }

    /**
     * Computes the intersection between two homogenous 2D line segments,
     * if it exists. To figure out the intersection, a raycast is performed
     * between the two segments.
     * Seg1 and seg2 also intersect at that point if and only if 0 <= S, T <= 1.
     * @param {Segment} seg1
     * @param {Segment} seg2
     * @return {Intersection}
     *      The point of intersection in homogenous 2D coordiantes and its
     *      parametric coefficients along seg1 and seg2,
     *      or undefined if the segments don't intersect.
     */
    function segmentIntersection(seg1, seg2) {
      let intersection = raycast(seg1, seg2);
      if(!intersection)
        return undefined;

      // Return the intersection only if it lies on both the segments.
      let s = intersection[1];
      let t = intersection[2];
      if(s >= 0 && s <= 1 && t >= 0 && t <= 1)
        return intersection;
      else
        return undefined;
    }


    /**
     * Produces the data for creating a path from a list of segments forming a
     * continuous path.
     * @param {Segment[]}
     * @return {PathData}
     */
    function segmentsToPath(segments) {
        var left = segments[0][0][0];
        var right = segments[0][0][0];
        var top = segments[0][0][1];
        var bottom = segments[0][0][1];

        // Get the bounds of the segment.
        var pts = [];
        var isFirst = true;
        _.each(segments, function(segment) {
            var p1 = segment[0];
            if(isFirst) {
                isFirst = false;
                pts.push(p1);
            }

            var p2 = segment[1];

            left = Math.min(left, p1[0], p2[0]);
            right = Math.max(right, p1[0], p2[0]);
            top = Math.min(top, p1[1], p2[1]);
            bottom = Math.max(bottom, p1[1], p2[1]);

            pts.push(p2);
        });

        // Get the path's left and top coordinates.
        var width = right-left;
        var height = bottom-top;
        var cx = left + width/2;
        var cy = top + height/2;

        // Convert the points to a _path.
        var _path = [];
        var firstPt = true;
        _.each(pts, function(pt) {
            var type = 'L';
            if(firstPt) {
                type = 'M';
                firstPt = false;
            }
            _path.push([type, pt[0]-left, pt[1]-top]);
        });

        return {
            _path: JSON.stringify(_path),
            left: cx,
            top: cy,
            width: width,
            height: height
        };
    }

    /**
     * Converts a path into a list of line segments.
     * This supports freehand paths, but not elliptical paths.
     * @param {(Roll20Path|Roll20Path[])} path
     * @return {Segment[]}
     */
    function toSegments(path) {
        if(_.isArray(path))
            return _toSegmentsMany(path);

        var _path = JSON.parse(path.get('_path'));
        var transformInfo = getTransformInfo(path);

        var segments = [];
        var prevPt;

        _.each(_path, tuple => {
            let type = tuple[0];

            // Convert the previous point and tuple into segments.
            let newSegs = [];
            if(type === 'C') { // Cubic Bezier
              newSegs = _toSegmentsC(prevPt, tuple, transformInfo);
              if(newSegs.length > 0)
                prevPt = newSegs[newSegs.length - 1][1];
            }
            if(type === 'L') { // Line
              newSegs = _toSegmentsL(prevPt, tuple, transformInfo);
              if(newSegs.length > 0)
                prevPt = newSegs[0][1];
            }
            if(type === 'M') { // Move
              prevPt = tupleToPoint(tuple, transformInfo);
            }
            if(type === 'Q') { // Freehand (tiny Quadratic Bezier)
              newSegs = _toSegmentsQ(prevPt, tuple, transformInfo);
              if(newSegs.length > 0)
                prevPt = newSegs[0][1];
            }

            _.each(newSegs, s => {
              segments.push(s);
            });
        });

        return segments;
    }

    /**
     * Converts a 'C' type path point to a list of segments approximating the
     * curve.
     * @private
     * @param {vec3} prevPt
     * @param {PathTuple} tuple
     * @param {PathTransformInfo} transformInfo
     * @return {Segment[]}
     */
    function _toSegmentsC(prevPt, tuple, transformInfo) {
      let cPt1 = tupleToPoint(['L', tuple[1], tuple[2]], transformInfo);
      let cPt2 = tupleToPoint(['L', tuple[3], tuple[4]], transformInfo);
      let pt = tupleToPoint(['L', tuple[5], tuple[6]], transformInfo);
      let points = [prevPt, cPt1, cPt2, pt];

      // Choose the number of segments based on the rough approximate arc length.
      // Each segment should be <= 10 pixels.
      let approxArcLength = VecMath.dist(prevPt, cPt1) + VecMath.dist(cPt1, cPt2) + VecMath.dist(cPt2, pt);
      let numSegs = Math.max(Math.ceil(approxArcLength/10), 1);

      let bezierPts = [prevPt];
      _.each(_.range(1, numSegs), i => {
        let scalar = i/numSegs;
        let bPt = getBezierPoint(points, scalar);
        bezierPts.push(bPt);
      });
      bezierPts.push(pt);

      return _.chain(bezierPts)
      .map((cur, i) => {
        if(i === 0)
          return undefined;

        let prev = bezierPts[i-1];
        return [prev, cur];
      })
      .compact()
      .value();
    }

    /**
     * Converts an 'L' type path point to a segment.
     * @private
     * @param {vec3} prevPt
     * @param {PathTuple} tuple
     * @param {PathTransformInfo} transformInfo
     * @return {Segment[]}
     */
    function _toSegmentsL(prevPt, tuple, transformInfo) {
      // Transform the point to 2D homogeneous map coordinates.
      let pt = tupleToPoint(tuple, transformInfo);

      let segments = [];
      if(!(prevPt[0] == pt[0] && prevPt[1] == pt[1]))
        segments.push([prevPt, pt]);
      return segments;
    }

    /**
     * Converts a 'Q' type path point to a segment approximating
     * the freehand curve.
     * @private
     * @param {vec3} prevPt
     * @param {PathTuple} tuple
     * @param {PathTransformInfo} transformInfo
     * @return {Segment[]}
     */
    function _toSegmentsQ(prevPt, tuple, transformInfo) {
      // Freehand Bezier paths are very small, so let's just
      // ignore the control point for it entirely.
      tuple[1] = tuple[3];
      tuple[2] = tuple[4];

      // Transform the point to 2D homogeneous map coordinates.
      let pt = tupleToPoint(tuple, transformInfo);

      let segments = [];
      if(!(prevPt[0] == pt[0] && prevPt[1] == pt[1]))
        segments.push([prevPt, pt]);
      return segments;
    }

    /**
     * Converts several paths into a single list of segments.
     * @private
     * @param  {Roll20Path[]} paths
     * @return {Segment[]}
     */
    function _toSegmentsMany(paths) {
        return _.chain(paths)
          .reduce(function(allSegments, path) {
              return allSegments.concat(toSegments(path));
          }, [])
          .value();
    }

    /**
     * Transforms a tuple for a point in a path into a point in
     * homogeneous 2D map coordinates.
     * @param  {PathTuple} tuple
     * @param  {PathTransformInfo} transformInfo
     * @return {Vector}
     */
    function tupleToPoint(tuple, transformInfo) {
        var width = transformInfo.width;
        var height = transformInfo.height;
        var scaleX = transformInfo.scaleX;
        var scaleY = transformInfo.scaleY;
        var angle = transformInfo.angle;
        var cx = transformInfo.cx;
        var cy = transformInfo.cy;

        // The point in path coordinates, relative to the path center.
        var x = tuple[1] - width/2;
        var y = tuple[2] - height/2;
        var pt = [x,y,1];

        // The transform of the point from path coordinates to map
        // coordinates.
        var scale = MatrixMath.scale([scaleX, scaleY]);
        var rotate = MatrixMath.rotate(angle);
        var transform = MatrixMath.translate([cx, cy]);
        transform = MatrixMath.multiply(transform, rotate);
        transform = MatrixMath.multiply(transform, scale);

        return MatrixMath.multiply(transform, pt);
    }

    on('chat:message', function(msg) {
        if(msg.type === 'api' && msg.content.indexOf('!pathInfo')  === 0) {
            log('!pathInfo');

            try {
                var path = findObjs({
                    _type: 'path',
                    _id: msg.selected[0]._id
                })[0];
                log(path);
                log(path.get('_path'));

                var segments = toSegments(path);
                log('Segments: ');
                log(segments);

                var pathData = segmentsToPath(segments);
                log('New path data: ');
                log(pathData);

                var curPage = path.get('_pageid');
                _.extend(pathData, {
                    stroke: '#ff0000',
                    _pageid: curPage,
                    layer: path.get('layer')
                });

                var newPath = createObj('path', pathData);
                log(newPath);
            }
            catch(err) {
                log('!pathInfo ERROR: ');
                log(err.message);
            }

        }
    });

    return {
        BoundingBox,
        Circle,
        Path,
        Polygon,
        Triangle,

        createCircleData,
        distanceToPoint,
        getBezierPoint,
        getBoundingBox,
        getCenter,
        getTransformInfo,
        mergePathStr,
        normalizePath,
        raycast,
        segmentIntersection,
        segmentsToPath,
        toSegments,
        tupleToPoint
    };
})();

}).toString());
